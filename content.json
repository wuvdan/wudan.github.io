{"meta":{"title":"一个孤独的搬码猿","subtitle":"iOSer","description":"","author":"","url":"https://github.com/wuvdan/wuvdan.github.io.git","root":"/"},"pages":[{"title":"关于","date":"2020-04-20T09:34:06.518Z","updated":"2020-04-20T09:34:06.514Z","comments":true,"path":"about/index.html","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/about/index.html","excerpt":"","text":"基本信息 性别：男 出生年月：1996-10 概要我是一个专注于iOS开发的职业工作者，可以使用Swift或Objective-C进行代码开发，喜欢编程，对新知识有渴望的探知欲。平时的爱好就是喜欢看看博客和写写博客，记录自己的学习经历。自己的职业规划是成为一名iOS开发高级工程师。 工作经历 2020-04 ~ 至今： 合肥城市泊车投资有限公司(iOS开发工程师) 2019-08 ~ 2020-4： 安徽好马科技有限公司(iOS开发工程师) 2018-08 ~ 2019-08： 杭州银江医联网股份有限公司(iOS开发工程师) 2017-07 ~ 2018-08：杭州会友科技有限公司(iOS开发工程师) 1. 掌上排水宝 时间: 2019-04 ~ 至今 工作职责： 项目需求研讨 Bug修改 迭代上线 工作内容： 新功能开发 修改Bug 增加用户体验 页面优化 难点： TableView优化 表单上传 项目经历2. 医易通(医护端) 时间: 2018-08 ~ 2019-08 工作职责： 项目需求研讨 Bug修改 迭代上线 工作内容： 新功能开发 修改Bug 增加用户体验 页面优化 难点： XIB使用 3. 芽儿阅读 时间: 2018-03 ~ 2018-06 工作职责： 项目需求研讨 项目代码开发 迭代上线 工作内容： 新功能开发 产品维护 难点： 远程通知处理 CollectionViewCell复用 专业技能： 第三方开源库熟练使用 极光推送 友盟分享、友盟统计 原生QQ/微信等第三方登录和分享 AppStore流程：熟悉上架、转让、更新等流程 技能清单： UI控件、工具库封装 熟悉面向对象编程，了解iOS产品开发流程 熟练使用StoryBoard/Xib布局和纯代码布局 掌握Swift语言 对软件开发有较强的逻辑分析能力，良好的文档阅读能力 热爱编程，喜欢研究新技术 联系方式 QQ/WeChat: 158019325 E-mial: wuvdan@163.com 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"404 Not Found","date":"2020-01-17T06:55:27.700Z","updated":"2020-01-17T06:55:12.377Z","comments":true,"path":"404.html","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/404.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-17T07:56:07.558Z","updated":"2020-01-17T07:56:07.552Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-17T07:55:54.265Z","updated":"2020-01-17T07:55:54.259Z","comments":true,"path":"tag/index.html","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS自定义控件-自定义Alter弹窗","slug":"iOS自定义控件-自定义Alter弹窗","date":"2020-01-20T02:09:01.000Z","updated":"2020-04-21T09:04:36.308Z","comments":true,"path":"2020/01/20/iOS自定义控件-自定义Alter弹窗/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/20/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89Alter%E5%BC%B9%E7%AA%97/","excerpt":"","text":"模仿微信底部弹窗样式。 接口文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface WDAlterSheetModel : NSObject&#x2F;&#x2F;&#x2F; 仅显示主标题 黑色 ，16号字体&#x2F;&#x2F;&#x2F; @param title 标题内容+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title;&#x2F;&#x2F;&#x2F; 主标题（黑色 ，16号字体）和副标题（灰色 ，10号字体）&#x2F;&#x2F;&#x2F; @param title 主标题内容&#x2F;&#x2F;&#x2F; @param subTitle 副标题内容+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title subTitle:(NSString *)subTitle;&#x2F;&#x2F;&#x2F; 仅显示主标题 16号字体&#x2F;&#x2F;&#x2F; @param title 标题内容&#x2F;&#x2F;&#x2F; @param titleColor 颜色配置+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor;&#x2F;&#x2F;&#x2F; 仅显示主标题&#x2F;&#x2F;&#x2F; @param title 主标题内容&#x2F;&#x2F;&#x2F; @param titleColor 颜色配置&#x2F;&#x2F;&#x2F; @param titleFount 字体配置+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor titleFont:(UIFont *)titleFount;&#x2F;&#x2F;&#x2F; 主标题和副标题&#x2F;&#x2F;&#x2F; @param title 主标题内容&#x2F;&#x2F;&#x2F; @param titleColor 主标题颜色配置&#x2F;&#x2F;&#x2F; @param titleFont 主标题字体配置&#x2F;&#x2F;&#x2F; @param subTitle 副标题内容&#x2F;&#x2F;&#x2F; @param subTitleColor 副标题字体配置&#x2F;&#x2F;&#x2F; @param subTitleFont 副标题字体配置+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor titleFont:(UIFont *)titleFont subTitle:(NSString *)subTitle subTitleColor:(UIColor *)subTitleColor subTitleFont:(UIFont *)subTitleFont;@end&#x2F;&#x2F; 点击回调（取消按钮除外）typedef void (^DidSelectedBlock)(NSUInteger index);@interface WDAlterSheetView : UIControl&#x2F;&#x2F;&#x2F; 仅显示按钮 默认样式&#x2F;&#x2F;&#x2F; @param items 按钮文字数组+ (void)showAlterWithTitleItems:(NSArray&lt;NSString *&gt; *)items didSelectBlock:(DidSelectedBlock)selectBlock;&#x2F;&#x2F;&#x2F; 仅显示按钮 自定义样式按钮&#x2F;&#x2F;&#x2F; @param items 按钮样式模型数组+ (void)showAlterWithTitleAttItems:(NSArray&lt;WDAlterSheetModel *&gt; *)items didSelectBlock:(DidSelectedBlock)selectBlock;&#x2F;&#x2F;&#x2F; 显示按钮（默认样式） + 取消按钮&#x2F;&#x2F;&#x2F; @param items 按钮文字数组&#x2F;&#x2F;&#x2F; @param cancelText 取消按钮文字&#x2F;&#x2F;&#x2F; @param cancelColor 取消按钮颜色+ (void)showAlterWithTitleItems:(NSArray&lt;NSString *&gt; *)items cancelText:(NSString *)cancelText cancelColor:(UIColor * _Nullable)cancelColor &#x2F;&#x2F; 默认颜色红色 didSelectBlock:(DidSelectedBlock)selectBlock;&#x2F;&#x2F;&#x2F; 显示按钮（自定义样式） + 取消按钮&#x2F;&#x2F;&#x2F; @param items 按钮样式模型数组&#x2F;&#x2F;&#x2F; @param cancelText 取消按钮文字&#x2F;&#x2F;&#x2F; @param cancelColor 取消按钮颜色+ (void)showAlterWithTitleAttItems:(NSArray&lt;WDAlterSheetModel *&gt; *)items cancelText:(NSString *)cancelText cancelColor:(UIColor * _Nullable)cancelColor &#x2F;&#x2F; 默认颜色红色 didSelectBlock:(DidSelectedBlock)selectBlock;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501#import &quot;WDAlterSheetView.h&quot;&#x2F;&#x2F; 按钮高度static CGFloat KButtonHeight &#x3D; 55;&#x2F;&#x2F; 取消按钮与其他间距static CGFloat KSpace &#x3D; 8;&#x2F;&#x2F; 圆角static CGFloat KCornersSpace &#x3D; 10;&#x2F;&#x2F; 屏幕高度static CGFloat kScreenHeight() &#123; return [[UIScreen mainScreen] bounds].size.height;&#125;&#x2F;&#x2F; 屏幕宽度static CGFloat kScreenWidth() &#123; return [[UIScreen mainScreen] bounds].size.width;&#125;&#x2F;&#x2F; 是否是刘海屏static BOOL kDevice_iPhoneX() &#123; BOOL isPhoneX &#x3D; NO; if (@available(iOS 11.0, *)) &#123; isPhoneX &#x3D; [[UIApplication sharedApplication] delegate].window.safeAreaInsets.bottom &gt; 0.0; &#125; return isPhoneX;&#125;&#x2F;&#x2F; 主标题颜色static UIColor * kTitleColor() &#123; return [UIColor colorWithRed:0.1 green:0.1 blue:0.1 alpha:1];&#125;&#x2F;&#x2F; 副标题颜色static UIColor * kSubTitleColor() &#123; return [UIColor colorWithRed:0.90 green:0.90 blue:0.90 alpha:1];&#125;&#x2F;&#x2F; 间隙颜色static UIColor * kSpaceColor() &#123; return [UIColor colorWithRed:0.95 green:0.95 blue:0.95 alpha:1];&#125;&#x2F;&#x2F; 分割线颜色static UIColor * kSpaceLineColor() &#123; return [UIColor colorWithRed:0.90 green:0.90 blue:0.90 alpha:1];&#125;&#x2F;&#x2F; 主标题字体static UIFont * kTitleFont() &#123; return [UIFont systemFontOfSize:16];&#125;&#x2F;&#x2F; 副标题字体static UIFont * kSubTitleFont() &#123; return [UIFont systemFontOfSize:12];&#125;@interface WDAlterSheetModel ()&#x2F;&#x2F; 文字@property (nonatomic, copy) NSString *title;@property (nonatomic, copy) NSString *subTitle;&#x2F;&#x2F; 颜色@property (nonatomic, strong) UIColor *titleColor;@property (nonatomic, strong) UIColor *subTitleColor;&#x2F;&#x2F; 字体@property (nonatomic, strong) UIFont *titleFont;@property (nonatomic, strong) UIFont *subTitleFont;@end@implementation WDAlterSheetModel+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title &#123; return [self setupWithTitle:title titleColor:kTitleColor()];&#125;+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title subTitle:(NSString *)subTitle &#123; return [self setupWithTitle:title titleColor:kTitleColor() titleFont:kTitleFont() subTitle:subTitle subTitleColor:kSubTitleColor() subTitleFont:kSubTitleFont()];&#125;+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor &#123; return [self setupWithTitle:title titleColor:titleColor titleFont:kTitleFont()];&#125;+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor titleFont:(UIFont *)titleFont &#123; return [self setupWithTitle:title titleColor:titleColor titleFont:titleFont subTitle:@&quot;&quot; subTitleColor:kSubTitleColor() subTitleFont:kSubTitleFont()];&#125;+ (WDAlterSheetModel *)setupWithTitle:(NSString *)title titleColor:(UIColor *)titleColor titleFont:(UIFont *)titleFont subTitle:(NSString *)subTitle subTitleColor:(UIColor *)subTitleColor subTitleFont:(UIFont *)subTitleFont &#123; WDAlterSheetModel *model &#x3D; [[WDAlterSheetModel alloc] init]; model.title &#x3D; title; model.titleColor &#x3D; titleColor; model.titleFont &#x3D; titleFont; model.subTitle &#x3D; subTitle; model.subTitleColor &#x3D; subTitleColor; model.subTitleFont &#x3D; subTitleFont; return model;&#125;@end@interface WDAlterSheetControl : UIControl@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, strong) UILabel *subTitleLabel;@property (nonatomic, copy) NSArray&lt;NSLayoutConstraint *&gt; *totalLayoutConstraints;@property (nonatomic, strong) UIView *bottomLineView;@end@implementation WDAlterSheetControl- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; self.backgroundColor &#x3D; [UIColor whiteColor]; _titleLabel &#x3D; [[UILabel alloc] init]; _titleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO; _titleLabel.textAlignment &#x3D; NSTextAlignmentCenter; [self addSubview:_titleLabel]; _subTitleLabel &#x3D; [[UILabel alloc] init]; _subTitleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO; _subTitleLabel.textAlignment &#x3D; NSTextAlignmentCenter; [self addSubview:_subTitleLabel]; _bottomLineView &#x3D; [[UIView alloc] init]; _bottomLineView.backgroundColor &#x3D; kSpaceLineColor(); [self addSubview:_bottomLineView]; self.totalLayoutConstraints &#x3D; @[ [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:-2], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:2], ]; [self addConstraints:self.totalLayoutConstraints]; &#125; return self;&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; _bottomLineView.frame &#x3D; CGRectMake(0, CGRectGetHeight(self.frame) - 0.5, CGRectGetWidth(self.frame), 0.5); if (_subTitleLabel.text.length &#x3D;&#x3D; 0) &#123; [self removeConstraints:self.totalLayoutConstraints]; [self addConstraints:@[ [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125;&#125;@end@interface WDAlterSheetLastControl : UIControl@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, strong) UILabel *subTitleLabel;@property (nonatomic, copy) NSArray&lt;NSLayoutConstraint *&gt; *totalLayoutConstraints;@property (nonatomic, strong) UIView *bottomView;@end@implementation WDAlterSheetLastControl- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; self.backgroundColor &#x3D; [UIColor whiteColor]; _titleLabel &#x3D; [[UILabel alloc] init]; _titleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO; _titleLabel.textAlignment &#x3D; NSTextAlignmentCenter; [self addSubview:_titleLabel]; _subTitleLabel &#x3D; [[UILabel alloc] init]; _subTitleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO; _subTitleLabel.textAlignment &#x3D; NSTextAlignmentCenter; [self addSubview:_subTitleLabel]; _bottomView &#x3D; [[UIView alloc] init]; _bottomView.translatesAutoresizingMaskIntoConstraints &#x3D; NO; _bottomView.backgroundColor &#x3D; [UIColor clearColor]; [self addSubview:_bottomView]; self.totalLayoutConstraints &#x3D; @[ [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:-2 - (kDevice_iPhoneX() ? 34 : 0)], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:2 - (kDevice_iPhoneX() ? 34 : 0)], ]; NSMutableArray *array &#x3D; [NSMutableArray array]; [array addObjectsFromArray:@[ [NSLayoutConstraint constraintWithItem:_bottomView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeBottom multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_bottomView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeHeight multiplier:1 constant:kDevice_iPhoneX() ? 34 : 0], [NSLayoutConstraint constraintWithItem:_bottomView attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeLeading multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_bottomView attribute:NSLayoutAttributeTrailing relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeTrailing multiplier:1 constant:0] ]]; [array addObjectsFromArray:self.totalLayoutConstraints]; [self addConstraints:array]; &#125; return self;&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; if (_subTitleLabel.text.length &#x3D;&#x3D; 0) &#123; [self removeConstraints:self.totalLayoutConstraints]; [self addConstraints:@[ [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:- (kDevice_iPhoneX() ? 34 : 0) &#x2F; 2], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_subTitleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:- (kDevice_iPhoneX() ? 34 : 0) &#x2F; 2], ]]; &#125;&#125;@end@interface WDAlterSheetView ()@property (nonatomic, strong) UIView *backView;@property (nonatomic, assign) CGFloat totalHeight;@property (nonatomic, copy) DidSelectedBlock selectedBlock;@end@implementation WDAlterSheetView+ (instancetype)shared &#123; static dispatch_once_t onceToken; static WDAlterSheetView *view &#x3D; nil; dispatch_once(&amp;onceToken, ^&#123; view &#x3D; [[WDAlterSheetView alloc] init]; view.frame &#x3D; [[UIScreen mainScreen] bounds]; &#125;); return view;&#125;- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; [self addTarget:self action:@selector(hidenView) forControlEvents: UIControlEventTouchUpInside]; &#125; return self;&#125;+ (void)showAlterWithTitleItems:(NSArray&lt;NSString *&gt; *)items didSelectBlock:(DidSelectedBlock)selectBlock &#123; [self showAlterWithTitleItems:items cancelText:@&quot;&quot; cancelColor:nil didSelectBlock:selectBlock];&#125;+ (void)showAlterWithTitleItems:(NSArray&lt;NSString *&gt; *)items cancelText:(NSString *)cancelText cancelColor:(UIColor *)cancelColor didSelectBlock:(DidSelectedBlock)selectBlock &#123; NSMutableArray&lt;WDAlterSheetModel *&gt; *array &#x3D; [NSMutableArray arrayWithCapacity:items.count]; for (NSString *title in items) &#123; WDAlterSheetModel *model &#x3D; [WDAlterSheetModel setupWithTitle:title]; [array addObject:model]; &#125; [self showAlterWithTitleAttItems:array cancelText:cancelText cancelColor:cancelColor didSelectBlock:selectBlock];&#125;+ (void)showAlterWithTitleAttItems:(NSArray&lt;WDAlterSheetModel *&gt; *)items didSelectBlock:(DidSelectedBlock)selectBlock &#123; [self showAlterWithTitleAttItems:items cancelText:@&quot;&quot; cancelColor:nil didSelectBlock:selectBlock];&#125;+ (void)showAlterWithTitleAttItems:(NSArray&lt;WDAlterSheetModel *&gt; *)items cancelText:(NSString *)cancelText cancelColor:(UIColor *)cancelColor didSelectBlock:(DidSelectedBlock)selectBlock &#123; NSAssert(items.count &gt; 0, @&quot;Thead Reason &#x3D;&#x3D;&#x3D;&gt; [WDAlterSheetView · itmes&#96;count not be null]&quot;); WDAlterSheetView *view &#x3D; [WDAlterSheetView shared]; view.selectedBlock &#x3D; selectBlock; [view addSubViews]; CGFloat cornersSpace &#x3D; KCornersSpace; if (items.firstObject.subTitle.length &#x3D;&#x3D; 0) &#123; cornersSpace &#x3D; 0; &#125; NSMutableArray *array &#x3D; [NSMutableArray arrayWithArray:items]; if (cancelText.length !&#x3D; 0) &#123; WDAlterSheetModel *cancelModel &#x3D; [WDAlterSheetModel setupWithTitle:cancelText titleColor:cancelColor]; if (cancelColor &#x3D;&#x3D; nil) &#123; cancelModel &#x3D; [WDAlterSheetModel setupWithTitle:cancelText titleColor:[UIColor redColor]]; &#125; [array addObject:cancelModel]; &#125; [array enumerateObjectsUsingBlock:^(WDAlterSheetModel * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (idx &#x3D;&#x3D; array.count - 1) &#123; WDAlterSheetLastControl *button &#x3D; [view createLastButtonWithModel:obj tag:idx]; if (cancelText.length &#x3D;&#x3D; 0) &#123; if (kDevice_iPhoneX()) &#123; button.frame &#x3D; CGRectMake(0, KButtonHeight * (items.count - 1) + cornersSpace, kScreenWidth(), KButtonHeight + 34); &#125; else &#123; button.frame &#x3D; CGRectMake(0, KButtonHeight * (items.count - 1) + cornersSpace, kScreenWidth(), KButtonHeight); &#125; &#125; else &#123; if (kDevice_iPhoneX()) &#123; button.frame &#x3D; CGRectMake(0, KButtonHeight * items.count + KSpace + cornersSpace, kScreenWidth(), KButtonHeight + 34); &#125; else &#123; button.frame &#x3D; CGRectMake(0, KButtonHeight * items.count + KSpace + cornersSpace, kScreenWidth(), KButtonHeight); &#125; &#125; [view.backView addSubview:button]; &#125; else &#123; WDAlterSheetControl *button &#x3D; [view createButtonWithModel:obj tag:idx]; if (idx &#x3D;&#x3D; 0) &#123; button.bottomLineView.hidden &#x3D; idx &#x3D;&#x3D; items.count - 1; button.frame &#x3D; CGRectMake(0, 0, kScreenWidth(), KButtonHeight + cornersSpace); &#125; else &#123; button.bottomLineView.hidden &#x3D; idx &#x3D;&#x3D; items.count - 2; button.frame &#x3D; CGRectMake(0, cornersSpace + KButtonHeight * idx, kScreenWidth(), KButtonHeight); &#125; [view.backView addSubview:button]; &#125; &#125;]; [view showView]; CGFloat totoalHeight &#x3D; KButtonHeight * items.count; if (cancelText.length !&#x3D; 0) &#123; totoalHeight +&#x3D; KSpace + KButtonHeight; &#125; if (kDevice_iPhoneX()) &#123; totoalHeight +&#x3D; 34; &#125; view.backView.frame &#x3D; CGRectMake(0, kScreenHeight(), kScreenWidth(), totoalHeight); [UIView animateWithDuration:0.35 animations:^&#123; view.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0.35]; view.backView.frame &#x3D; CGRectMake(0, kScreenHeight() - totoalHeight, kScreenWidth(), totoalHeight); &#125;]; [self setupRoundedCornersWithView:view.backView]; view.totalHeight &#x3D; totoalHeight;&#125;#pragma mark - Private#pragma mark Operation Methods- (UIView *)kWindowView &#123; if ([self viewController].view !&#x3D; nil) &#123; return [self viewController].view; &#125; else if ([UIApplication sharedApplication].delegate.window !&#x3D; nil) &#123; return [UIApplication sharedApplication].delegate.window; &#125; else &#123; return [UIApplication sharedApplication].keyWindow; &#125;&#125;- (void)hidenView &#123; [UIView animateWithDuration:0.35 animations:^&#123; self.backView.frame &#x3D; CGRectMake(0, kScreenHeight(), kScreenWidth(), self.totalHeight); self.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0]; &#125; completion:^(BOOL finished) &#123; [self removeSubViews]; [self removeFromSuperview]; &#125;];&#125;- (void)showView &#123; self.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0]; [[self kWindowView] addSubview:self];&#125;- (void)addSubViews &#123; _backView &#x3D; [[UIView alloc] init]; _backView.backgroundColor &#x3D; kSpaceColor(); [self addSubview:_backView];&#125;- (void)removeSubViews &#123; [_backView removeFromSuperview];&#125;#pragma mark Target Action Method- (void)buttonDidClickTargetAction:(UIControl *)sender &#123; sender.backgroundColor &#x3D; [UIColor whiteColor]; [self hidenView]; if (sender.tag !&#x3D; 0) &#123; if (self.selectedBlock) &#123; self.selectedBlock(sender.tag - 1); &#125; &#125;&#125;- (void)buttonTouchUpOutSideTargetAction:(UIControl *)sender &#123; sender.backgroundColor &#x3D; [UIColor colorWithRed:0.93 green:0.93 blue:0.93 alpha:1];&#125;#pragma mark Common UI Create Methods- (UIButton *)creatButton:(NSString *)title tag:(NSUInteger)tag &#123; UIButton *button &#x3D; [[UIButton alloc] init]; button.tag &#x3D; tag; [button setTitle:title forState:UIControlStateNormal]; button.titleLabel.font &#x3D; kTitleFont(); button.backgroundColor &#x3D; [UIColor whiteColor]; [button addTarget:self action:@selector(buttonDidClickTargetAction:) forControlEvents:UIControlEventTouchUpInside]; return button;&#125;- (WDAlterSheetControl *)createButtonWithModel:(WDAlterSheetModel *)model tag:(NSUInteger)tag &#123; WDAlterSheetControl *v &#x3D; [[WDAlterSheetControl alloc] init]; v.titleLabel.text &#x3D; model.title; v.titleLabel.textColor &#x3D; model.titleColor; v.titleLabel.font &#x3D; model.titleFont; v.subTitleLabel.text &#x3D; model.subTitle; v.subTitleLabel.textColor &#x3D; model.subTitleColor; v.subTitleLabel.font &#x3D; model.subTitleFont; v.tag &#x3D; tag; [v addTarget:self action:@selector(buttonTouchUpOutSideTargetAction:) forControlEvents:UIControlEventTouchDown]; [v addTarget:self action:@selector(buttonDidClickTargetAction:) forControlEvents:UIControlEventTouchUpInside]; return v;&#125;- (WDAlterSheetLastControl *)createLastButtonWithModel:(WDAlterSheetModel *)model tag:(NSUInteger)tag &#123; WDAlterSheetLastControl *v &#x3D; [[WDAlterSheetLastControl alloc] init]; v.titleLabel.text &#x3D; model.title; v.titleLabel.textColor &#x3D; model.titleColor; v.titleLabel.font &#x3D; model.titleFont; v.subTitleLabel.text &#x3D; model.subTitle; v.subTitleLabel.textColor &#x3D; model.subTitleColor; v.subTitleLabel.font &#x3D; model.subTitleFont; v.tag &#x3D; tag; [v addTarget:self action:@selector(buttonTouchUpOutSideTargetAction:) forControlEvents:UIControlEventTouchDown]; [v addTarget:self action:@selector(buttonDidClickTargetAction:) forControlEvents:UIControlEventTouchUpInside]; return v;&#125;- (UIViewController *)viewController &#123; UIResponder *next &#x3D; [self nextResponder]; do &#123; if ([next isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)next; &#125; next &#x3D; [next nextResponder]; &#125; while (next !&#x3D; nil); return nil;&#125;#pragma mark - Tool Method+ (void)setupRoundedCornersWithView:(UIView *)view &#123; CAShapeLayer *mask &#x3D; [CAShapeLayer layer]; UIBezierPath * path &#x3D; [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerTopRight) cornerRadii:CGSizeMake(15, 15)]; mask.path &#x3D; path.CGPath; mask.frame &#x3D; view.bounds; CAShapeLayer *borderLayer &#x3D; [CAShapeLayer layer]; borderLayer.path &#x3D; path.CGPath; borderLayer.fillColor &#x3D; [UIColor clearColor].CGColor; borderLayer.strokeColor &#x3D; [UIColor clearColor].CGColor; borderLayer.lineWidth &#x3D; 0; borderLayer.frame &#x3D; view.bounds; view.layer.mask &#x3D; mask; [view.layer addSublayer:borderLayer];&#125;@end 使用实例12345WDAlterSheetModel *m1 &#x3D; [WDAlterSheetModel setupWithTitle:@&quot;拍摄&quot; titleColor:UIColor.blackColor titleFont:[UIFont systemFontOfSize:16] subTitle:@&quot;照片或视频&quot; subTitleColor:UIColor.lightGrayColor subTitleFont:[UIFont systemFontOfSize:11]];WDAlterSheetModel *m2 &#x3D; [WDAlterSheetModel setupWithTitle:@&quot;从手机相册选择&quot; titleColor:UIColor.blackColor];[WDAlterSheetView showAlterWithTitleAttItems:@[m1, m2] cancelText:@&quot;取消&quot; cancelColor:[UIColor redColor] didSelectBlock:^(NSUInteger index) &#123; NSLog(@&quot;点击了：%lu&quot;, index);&#125;]; 示例图","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS底层-KVO","slug":"iOS底层-KVO","date":"2020-01-16T09:10:36.000Z","updated":"2020-01-20T01:49:43.576Z","comments":true,"path":"2020/01/16/iOS底层-KVO/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%BA%95%E5%B1%82-KVO/","excerpt":"","text":"类的单个属性观察观察值的4中模式 123456&#x2F;** * NSKeyValueObservingOptionNew 新值 * NSKeyValueObservingOptionOld 旧值 * NSKeyValueObservingOptionInitial 注册发送通知，改变时发送通知 * NSKeyValueObservingOptionPrior 改变之前发送通知，改变后发送通知 *&#x2F; 针对Person类里面的name属性进行观察 1[person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil]; 查看观察 123- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@&quot;%@&quot;, change);&#125; 打印效果 12342019-03-22 09:20:16.875033+0800 KVO[1844:81256] &#123; kind &#x3D; 1; new &#x3D; 0;&#125; 类的里面嵌套其他的属性观察观察Person里面Dog类的age，通过点语法直接监听 1[person addObserver:self forKeyPath:@&quot;dog.age&quot; options:NSKeyValueObservingOptionNew context:nil]; 输入结果 12342019-03-22 09:23:25.854859+0800 KVO[1876:84141] &#123; kind &#x3D; 1; new &#x3D; 11;&#125; 一次性观察多个值例如观察Person里面的Dog的age和level，则在Person类中重新+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key 12345678+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;dog&quot;]) &#123; NSArray *array &#x3D; @[@&quot;_dog.name&quot;, @&quot;_dog.level&quot;]; keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:array]; &#125; return keyPaths;&#125; 直接观察Dog类 1[person addObserver:self forKeyPath:@&quot;dog&quot; options:NSKeyValueObservingOptionNew context:nil]; 打印结果 12342019-03-22 09:27:11.485240+0800 KVO[1929:87568] &#123; kind &#x3D; 1; new &#x3D; &quot;&lt;Dog: 0x6000027c0b80&gt;&quot;;&#125; 手动模式在Person类中重写+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key 1234+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; &#x2F;&#x2F; 修改为手动模式 return NO;&#125; 手动触发 12[self.person willChangeValueForKey:@&quot;name&quot;];[self.person didChangeValueForKey:@&quot;name&quot;]; 观察容器类需要利用KVC例如观察person中的array 1[[self.person mutableArrayValueForKey:@&quot;array&quot;] addObject:@&quot;obj&quot;]; 输出结果 12345672019-03-22 11:02:13.996095+0800 KVO[5521:170395] &#123; indexes &#x3D; &quot;&lt;_NSCachedIndexSet: 0x600002216160&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]&quot;; kind &#x3D; 2; new &#x3D; ( obj );&#125; KVO的底层实现实质：观察值的setter方法通过runtime，新建一个子类继承于观察类（NSKVONotifing_类名），动态的修改了观察类的类型为子类的类型,在子类里面重写set方法，调用 12345- (void)setName:(NSString *)name &#123; [self willChangeValueForKey:@&quot;name&quot;]; [super setName:name]; [self didChangeValueForKey:@&quot;name&quot;]; &#125;","categories":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"KVO","slug":"KVO","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/KVO/"}]},{"title":"iOS底层-属性关键词","slug":"iOS底层-属性关键词","date":"2020-01-16T09:10:36.000Z","updated":"2020-01-20T01:50:09.236Z","comments":true,"path":"2020/01/16/iOS底层-属性关键词/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%BA%95%E5%B1%82-%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E8%AF%8D/","excerpt":"","text":"@property默认格式：@syntheszie var = _var; ARC中，默认修饰 基本数据类型@property (atomic, assign) 对象数据类型@property (atomic, strong) 修饰词解释 nonatomic 非原子性访问，不对set方法加锁，不是安全线程，但是性能高。 atomic 原子性访问，对生成的 set 方法加互斥锁 @synchronized(锁对象），安全线程（不是绝对安全线程）,性能差。 strongARC中使用，修饰OC对象，拥有关系，引用计数器+1。 reatainMRC中使用，修饰OC对象，拥有关系，引用计数器+1。 assign修饰基础数据类型，直接赋值，非拥有关系，不使用引用计数器。 weak修饰协议，控件，非拥有关系，指向的对象销毁，指针会自动置为nil，不使用引用计数器。 unsafe_unretained与weak类似，不会自动nil化，如果所指向的内存区域被释放了，这个指针就是一个野指针。 copy在 MRC 时是这样做的 release 旧对象( 旧对象的引用计数器 -1 ) , copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象 .（新对象是指最终指向的那个对象，不管深拷贝还是浅拷贝），在 ARC 时是这么干的 copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象。 readonly只生成get方法，不想把暴露的属性被人随便替换时 , 可以使用。 readwrite生成get/set方法。 @dynamic告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可) @synthesize如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。 @synchronized线程同步锁 问题：（1）什么情况使用 weak 关键字？相比 assign 有什么不同? 使用 协议声明使用weak IBOutlet 使用weak weak 和 assign 的不同点: weak 策略在属性所指的对象遭到摧毁时,系统会将 weak 修饰的属性对象的指针指向 nil,在 OC 给 nil 发消息是不会有什么问题的;如果使用 assign 策略在属性所指的对象遭到摧毁时,属性对象指针还指向原来的对象,由于对象已经被销毁,这时候就产生了野指针,如果这时候在给此对象发送消息,很容造成程序奔溃assigin 可以用于修饰非 OC 对象,而 weak 必须用于 OC 对象。 （2）使用 atomic 一定是线程安全的吗? 不是,atomic 的本意是指属性的存取方法是线程安全的,并不保证整个对象是线程安全的。 例如： 声明一个 NSMutableArray 的原子属性 stuff,此时 self.stuff 和 self.stuff =othersulf 都是线程安全的。但是,使用[self.stuff objectAtIndex:index]就不是线程安全的,需要用互斥锁来保证线程安全性。 （3）@synthesize 和 @dynamic 分别有什么作用 @property 有两个对应的词,一个是@synthesize,一个是@dynamic。如果@synthesize 和@dynamic 都没写,那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可) 假如一个属性被声明为@dynamic var；然后你没有提供@setter 方法和@getter 方法,编译的时候没问题,但是当程序运行到 instance.var = someVar,由于缺 setter方法会导致程序崩溃;或者当运行到 someVar = instance.var 时,由于缺 getter 方法同样会导致崩溃。 （4）ARC 下,不显式指定任何属性关键字时,默认的关键字都有哪些? 基本数据： atomic,readwrite,assign 普通的 OC 对象: atomic,readwrite,strong （5）用@property 声明的 NSString(或 NSArray,NSDictionary)经常使用 copy 关键字,为什么?如果改用 strong 关键字,可能造成什么问题? 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是 strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. （6）这个写法会出什么问题: @property(copy)NSMutableArray *array; 因为 copy 策略拷贝出来的是一个不可变对象,然而却把它当成可变对象使用,很容易造成程序奔溃这里还有一个问题,该属性使用了同步锁,会在创建时生成一些额外的代码用于帮助编写多线程程序,这会带来性能问题,通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销,在 iOS 开发中应该使用 nonatomic 替代 atomic. （7）如何让自定义类可以用 copy 修饰符?如何重写带 copy 关键字的 setter? 若想令自己所写的对象具有拷贝功能,则需实现 NSCopying 协议。 1234567&#x2F;&#x2F; 实现不可变版本拷贝- (id)copyWithZone:(NSZone *)zone; &#x2F;&#x2F; 实现可变版本拷贝- (id)mutableCopyWithZone:(NSZone *)zone;&#x2F;&#x2F; 重写带 copy 关键字的 setter- (void)setName:(NSString *)name &#123; _name &#x3D; [name copy];&#125; 深拷贝和浅拷贝copy 和 mutableCopy copy拷贝出来的对象类型总是不可变类型(例如, NSString, NSDictionary, NSArray等等) mutableCopy拷贝出来的对象类型总是可变类型(例如, NSMutableString, NSMutableDictionary, NSMutableArray等等) copy 对于可变对象为深拷贝，对于不可变对象为浅拷贝 mutableCopy 始终是深拷贝","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}]},{"title":"iOS自定义控件-身份证键盘","slug":"iOS自定义控件-身份证键盘","date":"2020-01-16T09:10:36.000Z","updated":"2020-01-20T02:18:26.986Z","comments":true,"path":"2020/01/16/iOS自定义控件-身份证键盘/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%BA%AB%E4%BB%BD%E8%AF%81%E9%94%AE%E7%9B%98/","excerpt":"","text":"利用UIInputViewController自定义键盘，初次尝试。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120fileprivate class WDCustomKeybordButton: UIButton &#123; &#x2F;&#x2F; 按钮点击回调 var didInputBlock: ((_ text: String) -&gt; Void)? override var isHighlighted: Bool &#123; didSet &#123; &#x2F;&#x2F; 监听是否是高亮状态，并设置背景颜色 backgroundColor &#x3D; isHighlighted ? UIColor(red:0.66, green:0.69, blue:0.73, alpha:1.00) : .white &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) backgroundColor &#x3D; .white layer.cornerRadius &#x3D; 5 setTitleColor(.black, for: .normal) addTarget(self, action: #selector(buttonTargetAction(sender:)), for: .touchUpInside) &#125; @objc func buttonTargetAction(sender: UIButton) &#123; let text &#x3D; (sender.titleLabel?.text) ?? &quot;&quot; if didInputBlock !&#x3D; nil &#123; didInputBlock!(text) &#125; &#x2F;&#x2F; 添加震动反馈 UIImpactFeedbackGenerator().impactOccurred() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125;@objc protocol WDCustomKeybordDelegate: NSObjectProtocol &#123; func keybord(keybord: WDCustomKeybord, isDelete: Bool, text: String) -&gt; Void&#125;class WDCustomKeybord: UIInputViewController &#123; &#x2F;&#x2F;&#x2F; 键盘点击Block回调，isDelete： 是否是删除按钮 public var didInputBlock: ((_ isDelete: Bool, _ text: String) -&gt; Void)? &#x2F;&#x2F;&#x2F; 代理回调 public weak var delegate: WDCustomKeybordDelegate? &#x2F;&#x2F;&#x2F; 按钮的宽度 private let buttonWidth: CGFloat &#x3D; (UIScreen.main.bounds.width - 4.0 * 5.0) &#x2F; 3.0 &#x2F;&#x2F;&#x2F; 按钮高度 private let buttonHeight: CGFloat &#x3D; 40.0 &#x2F;&#x2F;&#x2F; 间隙 private let margin: CGFloat &#x3D; 5.0 &#x2F;&#x2F;&#x2F; 按钮数组 private let numArray &#x3D; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;X&quot;, &quot;0&quot;, &quot;&quot;] &#x2F;&#x2F;&#x2F; 刘海屏适配 private var isiPhoneX: Bool &#123; var iPhoneX &#x3D; false if UIDevice.current.userInterfaceIdiom !&#x3D; .phone &#123; return iPhoneX &#125; if #available(iOS 11.0, *) &#123; let mainWindow &#x3D; UIApplication.shared.keyWindow if (mainWindow?.safeAreaInsets.bottom)! &gt; CGFloat(0.0) &#123; iPhoneX &#x3D; true &#125; &#125; return iPhoneX &#125; override func viewDidLoad() &#123; let height &#x3D; buttonHeight * 4.0 + margin * 5.0 if isiPhoneX &#123; view.frame &#x3D; CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: height + 34) &#125; else &#123; view.frame &#x3D; CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: height) &#125; setupSubviews() &#125; &#x2F;&#x2F;&#x2F; for循环添加按钮 private func setupSubviews() &#123; for (i, text) in numArray.enumerated() &#123; let button &#x3D; WDCustomKeybordButton() button.setTitle(text, for: .normal) button.tag &#x3D; 1000 + I if i &lt; 3 &#123; button.frame &#x3D; CGRect(x: margin + (margin + buttonWidth) * CGFloat(i), y: margin, width: buttonWidth, height: buttonHeight) &#125; else if i &lt; 6 &#123; button.frame &#x3D; CGRect(x: margin + (margin + buttonWidth) * CGFloat(i - 3), y: margin * 2 + buttonHeight, width: buttonWidth, height: buttonHeight) &#125; else if i &lt; 9 &#123; button.frame &#x3D; CGRect(x: margin + (margin + buttonWidth) * CGFloat(i - 6), y: margin * 3 + buttonHeight * 2, width: buttonWidth, height: buttonHeight) &#125; else &#123; button.frame &#x3D; CGRect(x: margin + (margin + buttonWidth) * CGFloat(i - 9), y: margin * 4 + buttonHeight * 3, width: buttonWidth, height: buttonHeight) &#125; if i &#x3D;&#x3D; 11 &#123; button.imageView?.contentMode &#x3D; .scaleAspectFit &#x2F;&#x2F; 删除按钮&lt;自定义图片&gt; button.setImage(UIImage(named: &quot;delete&quot;), for: .normal) &#125; button.didInputBlock &#x3D; &#123; if self.didInputBlock !&#x3D; nil &#123; if $0.count &#x3D;&#x3D; 0 &#123; self.didInputBlock!(true, $0) &#125; else &#123; self.didInputBlock!(false, $0) &#125; &#125; if (self.delegate?.responds(to: #selector(WDCustomKeybordDelegate.keybord(keybord:isDelete:text:))))! &#123; if $0.count &#x3D;&#x3D; 0 &#123; self.delegate?.keybord(keybord: self, isDelete:true , text: $0) &#125; else &#123; self.delegate?.keybord(keybord: self, isDelete:false , text: $0) &#125; &#125; &#125; view.addSubview(button) &#125; &#125;&#125; 使用方法（一）1234567891011121314151617let inputController &#x3D; WDCustomKeybord()inputController.didInputBlock &#x3D; &#123; if $0 &#123; &#x2F;&#x2F; 删除 var varText &#x3D; &quot;&quot; if let tText &#x3D; self.textField.text &#123; for (i, text) in tText.enumerated() &#123; if i &lt; tText.count - 1 &#123; varText.append(text) &#125; &#125; self.textField.text &#x3D; varText &#125; &#125; else &#123;&#x2F;&#x2F; 输入 self.textField.text?.append($1) &#125;&#125;textField.inputView &#x3D; inputController.inputView 使用方法（二）12345678910111213141516171819202122 let inputController &#x3D; WDCustomKeybord() inputController.delegate &#x3D; self textField.inputView &#x3D; inputController.inputView&#x2F;&#x2F; MARK: WDCustomKeybord Delegate Methodextension ViewController: WDCustomKeybordDelegate &#123; func keybord(keybord: WDCustomKeybord, isDelete: Bool, text: String) &#123; if isDelete &#123; &#x2F;&#x2F; 删除 var varText &#x3D; &quot;&quot; if let tText &#x3D; textField.text &#123; for (i, text) in tText.enumerated() &#123; if i &lt; tText.count - 1 &#123; varText.append(text) &#125; &#125; textField.text &#x3D; varText &#125; &#125; else &#123; &#x2F;&#x2F; 输入 textField.text?.append(text) &#125; &#125;&#125; 效果图","categories":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-搜索历史标签","slug":"iOS自定义控件-搜索历史标签","date":"2020-01-16T09:10:36.000Z","updated":"2020-01-20T02:17:04.567Z","comments":true,"path":"2020/01/16/iOS自定义控件-搜索历史标签/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E6%90%9C%E7%B4%A2%E5%8E%86%E5%8F%B2%E6%A0%87%E7%AD%BE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import UIKit@objc protocol WDTagsViewDelegate: NSObjectProtocol &#123; &#x2F;&#x2F;&#x2F; 单个标签点击回调 func tagsView(view: WDTagsView, didTappedAtIndex index: Int, didTappedAtText text: String) -&gt; Void&#125;class WDTagsView: UIView &#123; &#x2F;&#x2F; MARK: Public public weak var delegate: WDTagsViewDelegate? public var tagHeight: CGFloat &#x3D; 32 &#x2F;&#x2F; 标签高度，默认为32 public var viewHMargin: CGFloat &#x3D; 10 &#x2F;&#x2F; 整体左右间距 默认为10 public var viewVMargin: CGFloat &#x3D; 10 &#x2F;&#x2F; 整体上下间距 默认为10 public var tagInnerSpace: CGFloat &#x3D; 10 &#x2F;&#x2F; 标签内部左右间距 默认为10 public var tagHMargin: CGFloat &#x3D; 10 &#x2F;&#x2F; 标签之间的水平间距 默认为10 public var tagVMargin: CGFloat &#x3D; 5 &#x2F;&#x2F; 标签之间的行间距 默认为5 public var tagFont: UIFont &#x3D; .systemFont(ofSize: 14) &#x2F;&#x2F; 标签字体 默认为5 public var tagTextColor: UIColor &#x3D; .black &#x2F;&#x2F; 标签字体颜色 public var tagBackgroundColor: UIColor &#x3D; UIColor(red: 0.95, green: 0.95, blue: 0.95, alpha: 1) &#x2F;&#x2F; 标签背景颜色 public var itemArray: Array&lt;String&gt; &#x3D; Array() &#123; didSet &#123; setupViews() &#125; &#125; &#x2F;&#x2F; MARK: Private private var tagsArray: Array&lt;UIButton&gt; &#x3D; Array() override init(frame: CGRect) &#123; super.init(frame: frame) &#125; func refreshView() &#123; DispatchQueue.main.async &#123; self.setupViews() &#125; &#125; private func setupViews() &#123; for v in self.subviews &#123; v.removeFromSuperview() &#125; tagsArray.removeAll() for (index, item) in itemArray.enumerated() &#123; let b &#x3D; UIButton() b.setTitle(item, for: .normal) b.setTitleColor(tagTextColor, for: .normal) b.titleLabel?.font &#x3D; tagFont b.backgroundColor &#x3D; tagBackgroundColor b.layer.cornerRadius &#x3D; 10 b.tag &#x3D; index b.addTarget(self, action: #selector(buttonTargetAction(sender:)), for: .touchUpInside) addSubview(b) tagsArray.append(b) &#125; layoutItems() &#125; private func layoutItems() &#123; var tagLineWidth &#x3D; viewHMargin &#x2F;&#x2F; 单行的总宽度 let allWidth &#x3D; UIScreen.main.bounds.width &#x2F;&#x2F; 默认为屏幕宽度 var isChange: Bool &#x3D; false &#x2F;&#x2F; 是否需要换行 var lastItem: UIButton! for index in 0..&lt;tagsArray.count &#123; let button &#x3D; tagsArray[index] let tagTitle: NSString &#x3D; itemArray[index] as NSString var tagWidth &#x3D; tagTitle.boundingRect(with: CGSize(width: CGFloat(MAXFLOAT), height: tagHeight), options: .usesLineFragmentOrigin, attributes: [.font : tagFont], context: nil).size.width + 2 * tagInnerSpace + 0.5 tagLineWidth +&#x3D; (tagWidth + tagHMargin) if tagLineWidth &gt; (allWidth - viewHMargin) &#123; isChange &#x3D; true if (tagWidth + 2 * tagHMargin) &gt; allWidth &#123; tagWidth &#x3D; allWidth - 2 * tagHMargin button.titleEdgeInsets &#x3D; UIEdgeInsets(top: 0, left: tagInnerSpace &#x2F; 2, bottom: 0, right: tagInnerSpace &#x2F; 2) &#125; tagLineWidth &#x3D; viewHMargin + tagWidth + tagHMargin &#125; button.snp.makeConstraints &#123; (make) in make.height.equalTo(tagHeight) make.width.equalTo(tagWidth) if lastItem &#x3D;&#x3D; nil &#123; make.top.equalTo(viewVMargin) make.leading.equalTo(viewHMargin) &#125; else &#123; if isChange &#123; make.leading.equalTo(viewVMargin) make.top.equalTo(lastItem.snp.bottom).offset(tagVMargin) isChange &#x3D; false &#125; else &#123; make.leading.equalTo(lastItem.snp.trailing).offset(tagHMargin) make.top.equalTo(lastItem.snp.top) &#125; &#125; &#125; lastItem &#x3D; button &#125; lastItem.snp.makeConstraints &#123; (make) in make.bottom.equalTo(-viewVMargin).priority(.high) &#125; &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; @objc private func buttonTargetAction(sender: UIButton) &#123; delegate?.tagsView(view: self, didTappedAtIndex: sender.tag, didTappedAtText: itemArray[sender.tag]) &#125;&#125; 1234567891011121314151617181920var tagsView: WDTagsView!&#x2F;**页面添加，简单样式配置**&#x2F;tagsView &#x3D; WDTagsView()tagsView.delegate &#x3D; selftagsView.tagTextColor &#x3D; .blacktagsView.tagFont &#x3D; .systemFont(ofSize: 14)tagsView.backgroundColor &#x3D; UIColor(red: 0.9, green: 0.9, blue: 0.9, alpha: 1)tagsView.tagHeight &#x3D; 30tagsView.itemArray &#x3D; [&quot;手机&quot;, &quot;电脑&quot;, &quot;显卡&quot;, &quot;主机&quot;, &quot;啥啥&quot;, &quot;我擦&quot;, &quot;我是哦发生的活动开始对方擦&quot;, &quot;我屮艸芔茻&quot;,&quot;手机&quot;, &quot;电脑&quot;, &quot;显卡&quot;, &quot;主机&quot;, &quot;啥啥&quot;, &quot;我擦&quot;, &quot;我屮艸芔茻&quot;,&quot;手机&quot;, &quot;电脑&quot;, &quot;显卡&quot;, &quot;主机&quot;, &quot;啥啥&quot;, &quot;我擦&quot;, &quot;我屮艸芔茻&quot;, &quot;啥啥&quot;, &quot;我擦&quot;, &quot;我屮艸芔茻&quot;]view.addSubview(tagsView)&#x2F;**页面布局**&#x2F;tagsView.snp.makeConstraints &#123; (make) in make.leading.top.trailing.equalToSuperview()&#125;&#x2F;**刷新实图**&#x2F;tagsView.itemArray &#x3D; [&quot;手机&quot;, &quot;电脑&quot;, &quot;显卡&quot;, &quot;主机&quot;]tagsView.refreshView()","categories":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-仿京东地址选择器","slug":"iOS自定义控件-仿京东地址选择器","date":"2020-01-16T09:10:36.000Z","updated":"2020-01-20T02:22:13.956Z","comments":true,"path":"2020/01/16/iOS自定义控件-仿京东地址选择器/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E4%BB%BF%E4%BA%AC%E4%B8%9C%E5%9C%B0%E5%9D%80%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"写这个的主要是为了练习Swift的使用。 Plist文件内容下载地址 文件读取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768fileprivate class WDAddressPickerDataManger: NSObject &#123; static let manager &#x3D; WDAddressPickerDataManger() &#x2F;&#x2F; 读取list文件 func readPlistFile() -&gt; Dictionary&lt;String, Any&gt; &#123; let path &#x3D; Bundle.main.path(forResource: &quot;list.plist&quot;, ofType: nil) ?? &quot;&quot; let dict &#x3D; NSDictionary(contentsOfFile: path) if dict !&#x3D; nil &#123; return dict as! Dictionary&lt;String, Any&gt; &#125; return [:] &#125; &#x2F;&#x2F; 读取所有省份 func getProvinceNameArray() -&gt; Array&lt;String&gt; &#123; var array: [String] &#x3D; Array() for item in readPlistFile().keys &#123; array.append(item) &#125; return array &#125; &#x2F;&#x2F; 读取普通省份中的城市 func getNormalCityNameArray(with provinceName: String) -&gt; Array&lt;String&gt; &#123; var array: [String] &#x3D; Array() for item in readPlistFile() &#123; if item.key.contains(provinceName) &#123; let name &#x3D; (item.value as! Dictionary&lt;String, Any&gt;).keys for cityName in name &#123; array.append(cityName) &#125; &#125; &#125; return array &#125; &#x2F;&#x2F; 读取直辖市，特区中的区 func getSpecailCityNameArray(with provinceName: String) -&gt; Array&lt;String&gt; &#123; var array: [String] &#x3D; Array() for item in readPlistFile() &#123; if item.key.contains(provinceName) &#123; let name &#x3D; item.value as! Array&lt;String&gt; for cityName in name &#123; array.append(cityName) &#125; &#125; &#125; return array &#125; &#x2F;&#x2F; 读取普通城市中的区 func getRegionNameArray(with provinceName: String, cityName: String) -&gt; Array&lt;String&gt; &#123; var array: [String] &#x3D; Array() for item in readPlistFile() &#123; if item.key.contains(provinceName) &#123; let provinceDic &#x3D; item.value as! Dictionary&lt;String, Array&lt;String&gt;&gt; for city in provinceDic.keys &#123; if city.contains(cityName) &#123; for last in provinceDic[city]! &#123; array.append(last) &#125; &#125; &#125; &#125; &#125; return array &#125;&#125; HeaderView提示文字，与页面消失按钮 12345678910111213141516171819202122232425262728293031323334353637fileprivate class WDAddressPickerHeaderView: UIView &#123; var textLabel: UILabel! var clearButton: UIButton! override init(frame: CGRect) &#123; super.init(frame: frame) setupSubviews() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupSubviews() &#123; backgroundColor &#x3D; .white layer.cornerRadius &#x3D; 10 textLabel &#x3D; UILabel() textLabel.text &#x3D; &quot;地址选择&quot; textLabel.textColor &#x3D; .black textLabel.font &#x3D; .systemFont(ofSize: 20, weight: .bold) addSubview(textLabel) &#x2F;&#x2F; 自定义按钮图片 clearButton &#x3D; UIButton(type: .custom) clearButton.setImage(UIImage(named: &quot;clear&quot;), for: .normal) addSubview(clearButton) &#125; override func layoutSubviews() &#123; super.layoutSubviews() textLabel.frame &#x3D; CGRect(x: 15, y: 0, width: bounds.width &#x2F; 2.0, height: bounds.height) let cycleWidth &#x3D; (bounds.height - 10.0) &#x2F; 2 clearButton.frame &#x3D; CGRect(x: bounds.width - 15 - cycleWidth, y: (bounds.height - 10.0 - cycleWidth) &#x2F; 2.0, width: cycleWidth, height: cycleWidth) &#125;&#125; TopView页面标题显示与切换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091fileprivate class WDAddressPickerTopView: UIView &#123; &#x2F;&#x2F; 点击回调 var didSelectedIndexBlock: ((_ index: Int) -&gt; Void) &#x3D; &#123;(_) in&#125; &#x2F;&#x2F; 标题底部指示器 var indicatorView: UIView! &#x2F;&#x2F; 标题之间的间距 let margin: CGFloat &#x3D; 15 &#x2F;&#x2F; 底部指示器的布局，用来进行布局修改与动画处理 var indicatorViewConstraints: [NSLayoutConstraint]! override init(frame: CGRect) &#123; super.init(frame: frame) setupSubviews() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupSubviews() &#123; backgroundColor &#x3D; .white indicatorView &#x3D; UIView() indicatorView.backgroundColor &#x3D; .red addSubview(indicatorView) &#125; &#x2F;&#x2F; for循环显示标题 func setup(with items: [String], selectIndex: Int) &#123; var lastButton &#x3D; UIButton() var newItems &#x3D; items if items.isEmpty &#123; newItems.append(&quot;请选择&quot;) &#125; for view in subviews &#123; if view.isKind(of: UIButton.self) &#123; view.removeFromSuperview() &#125; &#125; for (i, title) in newItems.enumerated() &#123; let button &#x3D; UIButton(type: .custom) button.setTitle(title, for: .normal) button.titleLabel?.font &#x3D; .systemFont(ofSize: 15, weight: .bold) button.setTitleColor(.black, for: .normal) button.addTarget(self, action: #selector(buttonTargetAction(sender:)), for: .touchUpInside) button.tag &#x3D; 1000 + I addSubview(button) button.translatesAutoresizingMaskIntoConstraints &#x3D; false if i &#x3D;&#x3D; 0 &#123; addConstraint(NSLayoutConstraint(item: button, attribute: .leading, relatedBy: .equal, toItem: self, attribute: .leading, multiplier: 1, constant: margin)) &#125; else &#123; addConstraint(NSLayoutConstraint(item: button, attribute: .leading, relatedBy: .equal, toItem: lastButton, attribute: .trailing, multiplier: 1, constant: margin)) &#125; addConstraints([ NSLayoutConstraint(item: button, attribute: .centerY, relatedBy: .equal, toItem: self, attribute: .centerY, multiplier: 1, constant: 0) ]) lastButton &#x3D; button if i &#x3D;&#x3D; selectIndex &#123; indicatorView.translatesAutoresizingMaskIntoConstraints &#x3D; false indicatorViewConstraints &#x3D; [ NSLayoutConstraint(item: indicatorView, attribute: .leading, relatedBy: .equal, toItem: button, attribute: .leading, multiplier: 1, constant: 0), NSLayoutConstraint(item: indicatorView, attribute: .trailing, relatedBy: .equal, toItem: button, attribute: .trailing, multiplier: 1, constant: 0), NSLayoutConstraint(item: indicatorView, attribute: .bottom, relatedBy: .equal, toItem: self, attribute: .bottom, multiplier: 1, constant: -3), NSLayoutConstraint(item: indicatorView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: 5), ] addConstraints(indicatorViewConstraints) &#125; &#125; &#125; @objc func buttonTargetAction(sender: UIButton) &#123; &#x2F;&#x2F; 移除先前添加的布局 removeConstraints(indicatorViewConstraints) indicatorViewConstraints &#x3D; [ NSLayoutConstraint(item: indicatorView, attribute: .leading, relatedBy: .equal, toItem: sender, attribute: .leading, multiplier: 1, constant: 0), NSLayoutConstraint(item: indicatorView, attribute: .trailing, relatedBy: .equal, toItem: sender, attribute: .trailing, multiplier: 1, constant: 0), NSLayoutConstraint(item: indicatorView, attribute: .bottom, relatedBy: .equal, toItem: self, attribute: .bottom, multiplier: 1, constant: -3), NSLayoutConstraint(item: indicatorView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: 5), ] &#x2F;&#x2F; 添加点击变化后的布局 addConstraints(indicatorViewConstraints) setNeedsUpdateConstraints() UIView.animate(withDuration: 0.3) &#123; self.layoutIfNeeded() &#125; didSelectedIndexBlock(sender.tag - 1000) &#125;&#125; 列表单元格123456789101112131415161718192021222324252627282930313233343536373839404142fileprivate class WDAddressPickerTableViewCell: UITableViewCell &#123; var titleLabel: UILabel! var checkedImageView: UIImageView! override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) setupSubviews() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupSubviews() &#123; titleLabel &#x3D; UILabel() titleLabel.font &#x3D; .systemFont(ofSize: 15) titleLabel.textColor &#x3D; .black contentView.addSubview(titleLabel) &#x2F;&#x2F; 自定义显示图片 checkedImageView &#x3D; UIImageView() checkedImageView.image &#x3D; UIImage(named: &quot;duihao&quot;) contentView.addSubview(checkedImageView) &#125; private var _cellChecked: Bool &#x3D; false var cellChecked: Bool &#123; set &#123; _cellChecked &#x3D; newValue if !newValue &#123; checkedImageView.frame &#x3D; CGRect(x: 15, y: 15, width: 0, height: 0) titleLabel.frame &#x3D; CGRect(x: 15, y: 0, width: UIScreen.main.bounds.width - 30, height: 45) &#125; else &#123; checkedImageView.frame &#x3D; CGRect(x: 15, y: 15, width: 15, height: 15) titleLabel.frame &#x3D; CGRect(x: checkedImageView.frame.maxX + 15, y: 0, width: UIScreen.main.bounds.width - checkedImageView.frame.maxX - 15 - 15 , height: 45) &#125; &#125; get &#123; return _cellChecked &#125; &#125;&#125; BottomView底部列表视图载体，使用UIScrollView嵌套UITableView来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156fileprivate class WDAddressPickerBottomView: UIView &#123; &#x2F;&#x2F; Action var didSelectedBlock: ((_ page: Int, _ index: Int, _ name: String) -&gt; Void) &#x3D; &#123;(_,_,_) in &#125; &#x2F;&#x2F; UI var scrollView: UIScrollView! var provinceTableView: UITableView! var cityTableView: UITableView! var regionTableView: UITableView! &#x2F;&#x2F; Data var proVinceSelectedIndexRow &#x3D; -1 var citySelectedIndexRow &#x3D; -1 var regionSelectedIndexRow &#x3D; -1 var selectedIndexRow &#x3D; -1 var regionNameArray: [String] &#x3D; Array() var cityNameArray: [String] &#x3D; Array() var cityName: String &#x3D; &quot;&quot; &#123; didSet &#123; regionSelectedIndexRow &#x3D; -1 regionNameArray &#x3D; WDAddressPickerDataManger.manager.getRegionNameArray(with: provinceName, cityName: cityName) regionTableView.reloadData() &#125; &#125; let provinceNameArray: [String] &#x3D; WDAddressPickerDataManger.manager.getProvinceNameArray() var provinceName: String &#x3D; &quot;&quot; &#123; didSet &#123; if provinceName.contains(&quot;北京&quot;) || provinceName.contains(&quot;上海&quot;) || provinceName.contains(&quot;天津&quot;) || provinceName.contains(&quot;香港&quot;) || provinceName.contains(&quot;澳门&quot;) || provinceName.contains(&quot;重庆&quot;) &#123; cityNameArray &#x3D; WDAddressPickerDataManger.manager.getSpecailCityNameArray(with: provinceName) &#125; else &#123; cityNameArray &#x3D; WDAddressPickerDataManger.manager.getNormalCityNameArray(with: provinceName) &#125; citySelectedIndexRow &#x3D; -1 regionSelectedIndexRow &#x3D; -1 cityTableView.reloadData() &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) backgroundColor &#x3D; .white setupSubviews() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; override func layoutSubviews() &#123; super.layoutSubviews() scrollView.frame &#x3D; bounds provinceTableView.frame &#x3D; scrollView.bounds cityTableView.frame &#x3D; CGRect(x: scrollView.bounds.width, y: 0, width: scrollView.bounds.width, height: scrollView.bounds.height) regionTableView.frame &#x3D; CGRect(x: scrollView.bounds.width * 2.0, y: 0, width: scrollView.bounds.width, height: scrollView.bounds.height) &#125;&#125;&#x2F;&#x2F; MARK: Views Set Upprivate extension WDAddressPickerBottomView &#123; func setupSubviews() &#123; scrollView &#x3D; UIScrollView() scrollView.isScrollEnabled &#x3D; false scrollView.isPagingEnabled &#x3D; true scrollView.showsHorizontalScrollIndicator &#x3D; false scrollView.bounces &#x3D; false addSubview(scrollView) provinceTableView &#x3D; UITableView(frame: .zero, style: .plain) provinceTableView.delegate &#x3D; self provinceTableView.dataSource &#x3D; self provinceTableView.rowHeight &#x3D; 45 provinceTableView.register(WDAddressPickerTableViewCell.self, forCellReuseIdentifier: &quot;WDAddressPickerTableViewCell&quot;) scrollView.addSubview(provinceTableView) cityTableView &#x3D; UITableView(frame: .zero, style: .plain) cityTableView.delegate &#x3D; self cityTableView.dataSource &#x3D; self cityTableView.rowHeight &#x3D; 45 cityTableView.register(WDAddressPickerTableViewCell.self, forCellReuseIdentifier: &quot;WDAddressPickerTableViewCell&quot;) scrollView.addSubview(cityTableView) regionTableView &#x3D; UITableView(frame: .zero, style: .plain) regionTableView.delegate &#x3D; self regionTableView.dataSource &#x3D; self regionTableView.rowHeight &#x3D; 45 regionTableView.register(WDAddressPickerTableViewCell.self, forCellReuseIdentifier: &quot;WDAddressPickerTableViewCell&quot;) scrollView.addSubview(regionTableView) scrollView.contentSize &#x3D; CGSize(width: UIScreen.main.bounds.width, height: 0) &#125;&#125;&#x2F;&#x2F; MARK: UITableView DataSource Methodsextension WDAddressPickerBottomView: UITableViewDataSource &#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if tableView &#x3D;&#x3D; provinceTableView &#123; return provinceNameArray.count &#125; else if tableView &#x3D;&#x3D; cityTableView &#123; return cityNameArray.count &#125; else &#123; return regionNameArray.count &#125; &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;WDAddressPickerTableViewCell&quot;, for: indexPath) as! WDAddressPickerTableViewCell if tableView &#x3D;&#x3D; provinceTableView &#123; cell.titleLabel.text &#x3D; (provinceNameArray[indexPath.row] as NSString).substring(from: 6) if indexPath.row &#x3D;&#x3D; proVinceSelectedIndexRow &#123; cell.cellChecked &#x3D; true &#125; else &#123; cell.cellChecked &#x3D; false &#125; &#125; else if tableView &#x3D;&#x3D; cityTableView &#123; cell.titleLabel.text &#x3D; (cityNameArray[indexPath.row] as NSString).substring(from: 6) if indexPath.row &#x3D;&#x3D; citySelectedIndexRow &#123; cell.cellChecked &#x3D; true &#125; else &#123; cell.cellChecked &#x3D; false &#125; &#125; else &#123; cell.titleLabel.text &#x3D; (regionNameArray[indexPath.row] as NSString).substring(from: 6) if indexPath.row &#x3D;&#x3D; regionSelectedIndexRow &#123; cell.cellChecked &#x3D; true &#125; else &#123; cell.cellChecked &#x3D; false &#125; &#125; return cell &#125;&#125;&#x2F;&#x2F; MARK: UITableView Delegate Methodextension WDAddressPickerBottomView: UITableViewDelegate &#123; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; tableView.deselectRow(at: indexPath, animated: true) let cell &#x3D; tableView.cellForRow(at: indexPath) as! WDAddressPickerTableViewCell if tableView &#x3D;&#x3D; provinceTableView &#123; proVinceSelectedIndexRow &#x3D; indexPath.row scrollView.contentSize &#x3D; CGSize(width: UIScreen.main.bounds.width * 2, height: 0) scrollView.setContentOffset(CGPoint(x: UIScreen.main.bounds.width, y: 0), animated: true) &#125; else if tableView &#x3D;&#x3D; cityTableView &#123; citySelectedIndexRow &#x3D; indexPath.row scrollView.contentSize &#x3D; CGSize(width: UIScreen.main.bounds.width * 3, height: 0) scrollView.setContentOffset(CGPoint(x: UIScreen.main.bounds.width * 2, y: 0), animated: true) &#125; else &#123; regionSelectedIndexRow &#x3D; indexPath.row &#125; tableView.reloadData() selectedIndexRow &#x3D; indexPath.row didSelectedBlock(Int(scrollView.contentOffset.x &#x2F; UIScreen.main.bounds.width), indexPath.row, cell.titleLabel.text ?? &quot;&quot;) &#125;&#125; AddressPickerView以上的显示的视图的载体视图 123456789101112131415161718192021222324252627282930313233343536373839fileprivate class WDAddressPickerView: UIView &#123; var headerView: WDAddressPickerHeaderView! var topView: WDAddressPickerTopView! var bottomView: WDAddressPickerBottomView! override init(frame: CGRect) &#123; super.init(frame: frame) setupSubviews() setupSubviewsConstraint() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125;&#x2F;&#x2F; MARK: 页面布局@objc private extension WDAddressPickerView &#123; &#x2F;&#x2F; 页面控件初始化 func setupSubviews() &#123; headerView &#x3D; WDAddressPickerHeaderView() addSubview(headerView) topView &#x3D; WDAddressPickerTopView() topView.setup(with: [], selectIndex: 0) addSubview(topView) bottomView &#x3D; WDAddressPickerBottomView() addSubview(bottomView) &#125; &#x2F;&#x2F; 页面控件布局 func setupSubviewsConstraint() &#123; headerView.frame &#x3D; CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 50) topView.frame &#x3D; CGRect(x: 0, y: headerView.frame.maxY - 10, width: UIScreen.main.bounds.width, height: 45) bottomView.frame &#x3D; CGRect(x: 0, y: topView.frame.maxY, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 100 - topView.frame.maxY) &#125;&#125; 地址选取管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class WDAddressPickerManager: NSObject &#123; static let manager &#x3D; WDAddressPickerManager() private var backView: UIView! private var addressPickerView: WDAddressPickerView! &#x2F;&#x2F;&#x2F; 显示选择器 &#x2F;&#x2F;&#x2F; - Parameter completeBlock: province： 省（直辖市）， city：市（直辖市中的区），region： 区 func showPicker(completeBlock: @escaping ((_ province: String, _ city: String, _ region: String) -&gt; Void)) &#123; backView &#x3D; UIView() backView.backgroundColor &#x3D; UIColor(white: 0, alpha: 0) backView.frame &#x3D; UIScreen.main.bounds backView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(tapGuestureTargetAction(sender:)))) UIApplication.shared.keyWindow?.addSubview(backView) var titleItems: [String] &#x3D; Array() var provinceName &#x3D; &quot;&quot; var cityName &#x3D; &quot;&quot; var reginName &#x3D; &quot;&quot; addressPickerView &#x3D; WDAddressPickerView() addressPickerView.frame &#x3D; CGRect(x: 0, y: UIScreen.main.bounds.height, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 100) addressPickerView.headerView.clearButton.addTarget(self, action: #selector(tapGuestureTargetAction(sender:)), for: .touchUpInside) addressPickerView.bottomView.didSelectedBlock &#x3D; &#123; [weak self] (page, index, name) in if page &#x3D;&#x3D; 0 &#123; provinceName &#x3D; name cityName &#x3D; &quot;&quot; reginName &#x3D; &quot;&quot; titleItems &#x3D; [name, &quot;请选择&quot;] self?.addressPickerView.bottomView.provinceName &#x3D; name self?.addressPickerView.topView.setup(with: titleItems, selectIndex: page + 1) &#125; else if page &#x3D;&#x3D; 1 &#123; cityName &#x3D; name reginName &#x3D; &quot;&quot; if provinceName.contains(&quot;北京&quot;) || provinceName.contains(&quot;上海&quot;) || provinceName.contains(&quot;天津&quot;) || provinceName.contains(&quot;香港&quot;) || provinceName.contains(&quot;澳门&quot;) || provinceName.contains(&quot;重庆&quot;) &#123; self?.hidenView() completeBlock(provinceName, cityName, reginName) return &#125; titleItems &#x3D; [(provinceName), (cityName), &quot;请选择&quot;] self?.addressPickerView.bottomView.cityName &#x3D; name self?.addressPickerView.topView.setup(with: titleItems, selectIndex: page + 1) &#125; else &#123; reginName &#x3D; name titleItems &#x3D; [provinceName, cityName, reginName] self?.addressPickerView.topView.setup(with: titleItems, selectIndex: page) &#125; if page &#x3D;&#x3D; 2 &#123; self?.hidenView() completeBlock(provinceName, cityName, reginName) &#125; &#125; addressPickerView.topView.didSelectedIndexBlock &#x3D; &#123; [weak self] index in self?.addressPickerView.bottomView.scrollView.setContentOffset(CGPoint(x: UIScreen.main.bounds.width * CGFloat(index), y: 0), animated: true) &#125; UIApplication.shared.keyWindow?.addSubview(addressPickerView) UIView.animate(withDuration: 0.5) &#123; self.backView.backgroundColor &#x3D; UIColor(white: 0, alpha: 0.3) self.addressPickerView.frame &#x3D; CGRect(x: 0, y: 100, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 100) &#125; &#125; @objc private func tapGuestureTargetAction(sender: Any) &#123; hidenView() &#125; private func hidenView() &#123; UIView.animate(withDuration: 0.5, animations: &#123; self.backView.backgroundColor &#x3D; UIColor(white: 0, alpha: 0) self.addressPickerView.frame &#x3D; CGRect(x: 0, y: UIScreen.main.bounds.height, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 100) &#125;) &#123; (finished) in self.backView.removeFromSuperview() self.addressPickerView.removeFromSuperview() &#125; &#125;&#125; 效果图","categories":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS单元测试","slug":"iOS单元测试","date":"2020-01-16T08:07:20.651Z","updated":"2020-01-20T02:27:31.333Z","comments":true,"path":"2020/01/16/iOS单元测试/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"单元测试以测试ViewController为例。 ViewController.h文件1234567891011#import &lt;UIKit&#x2F;UIKit.h&gt;@interface ViewController : UIViewController&#x2F;** 逻辑测试 *&#x2F;- (int)getSumWithNum1:(int)a num2:(int)b;&#x2F;** 异步测试 *&#x2F;- (void)loadDataComplete:(void(^)(id info))complete;&#x2F;** 性能测试 *&#x2F;- (void)openCamera;@end ViewController.m文件1234567891011121314151617181920212223- (int)getSumWithNum1:(int)a num2:(int)b &#123; return a + b;&#125;- (void)loadDataComplete:(void (^)(id))complete &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); NSString *data &#x3D; @&quot;😝&quot;; dispatch_async(dispatch_get_main_queue(), ^&#123; complete(data); &#125;); &#125;);&#125;- (void)openCamera &#123; for(int i &#x3D; 0; i &lt; 1000; ++i) &#123; NSLog(@&quot;这是一个字符串%d&quot;, i); &#125;&#125;- (void)viewDidLoad &#123; [super viewDidLoad];&#125; 为了进行单元化测试，所以新建一个ViewControllerTest文件。步骤 导入测试头文件#import &quot;ViewController.h&quot; 声明属性@property (nonatomic, strong) ViewController *vc; 在- (void)setUp;进行初始化代码123- (void)setUp &#123; self.vc &#x3D; [[ViewController alloc] init];&#125; 1、逻辑测试 给出测试数据 进行测试 使用断言进行判定 123456789- (void)testSum &#123; &#x2F;&#x2F; 1. given int a &#x3D; 10; int b &#x3D; 22; &#x2F;&#x2F; 2. when int sum &#x3D; [self.vc getSumWithNum1:a num2:b]; &#x2F;&#x2F; 3. then XCTAssertEqual(sum, 32, @&quot;错误&quot;);&#125; 2、异步测试 创建XCTestExpectation，设置错误提示 调用方法，在异步中调用fulfill 进行判断时间，是否在预期时间内容 12345678XCTestExpectation *exp &#x3D; [self expectationWithDescription:@&quot;超过预期时间&quot;];[self.vc loadDataComplete:^(id info) &#123; XCTAssertNil(info, @&quot;数据为空&quot;); [exp fulfill];&#125;];[self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;, error);&#125;]; 3、性能测试 设置Baseline时间 Max STDDEV 最大样本标准偏差比例 12345- (void)testPerformanceExample &#123; [self measureBlock:^&#123; [self.vc openCamera]; &#125;];&#125; UI测试 1、录制脚本2、编辑脚本3、自动化测试 获取代码覆盖率1、点击Edit Secheme 2、选择Test-&gt;Options-&gt;Code Coverage勾起 3、运行代码查看结果","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}]},{"title":"开发技巧","slug":"开发技巧","date":"2020-01-16T08:07:12.406Z","updated":"2020-01-20T01:55:22.920Z","comments":true,"path":"2020/01/16/开发技巧/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1、PrefixHeader导入位置写法 1$(SRCROOT)&#x2F;$(PROJECT_NAME)&#x2F;&lt;#文件所在文件夹名称#&gt;&#x2F;PrefixHeader.pch 2、隐藏导航栏的两种方式 1234567891011121314151617181920212223242526272829&#x2F;&#x2F;方式一 《推荐》&#x2F;&#x2F;在需要隐藏的viewController中遵循&lt;UINavigationControllerDelegate&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; &#x2F;&#x2F; 设置导航控制器的代理为self self.navigationController.delegate &#x3D; self;&#125;#pragma mark - UINavigationControllerDelegate&#x2F;&#x2F; 将要显示控制器- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; &#x2F;&#x2F; 判断要显示的控制器是否是自己 BOOL isShowHomePage &#x3D; [viewController isKindOfClass:[self class]]; [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];&#125;&#x2F;&#x2F;方式二- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 3、TabBarItem要求只显示图片不显示文字 12&#x2F;&#x2F; self 表示需要设置样式的控制器[self.tabBarItem setImageInsets:UIEdgeInsetsMake(6, 0, -6, 0)]; 4、TableView或CollectionView单选 1234567891011&lt;!--步骤一、 声明一个全局变量--&gt;@property (nonatomic, assign) NSInteger selectedIndex;&lt;!--步骤二、TableView或CollectionView点击事件的方法中保存点击的index，并刷新--&gt;self.selectedIndex &#x3D; indexPath.row;[collectionView reloadData];或[tableView reloadData];&lt;!--步骤三、在cellForItemAtIndexPath或cellForRowAtIndexPath方法中判断是否是所保存的index--&gt;if (self.selectedIndex &#x3D;&#x3D; indexPath.row) &#123; &#x2F;&#x2F; 设置选中样式&#125; else &#123; &#x2F;&#x2F; 设置成默认样式 &#125; 5、怎么区分真机还是模拟器 1234567#if TARGET_IPHONE_SIMULATOR NSLog(@&quot;run on simulator&quot;); #define SIMULATOR_TEST#else &#x2F;&#x2F;不定义SIMULATOR_TEST这个宏 NSLog(@&quot;run on device&quot;); #endif 6、if Debug 12345#ifdef DEBUG &#x2F;&#x2F; do sth#else &#x2F;&#x2F; do sth#endif 7、一键清理所有模拟器安装过的APP 12&#x2F;&#x2F; 先关闭所有模拟器 在终端中输入下面命令即可xcrun simctl erase all 8、SDWebImage清理缓存 1234- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; [[[SDWebImageManager sharedManager] imageCache] clearMemory];&#125; 9、UITableView的HeaderView下拉放大 123456789101112131、View1:作为显示View2、View2:作为tableView的tableHeaderView，并添加View1，View2的大小和View1大小相同.3、在UIScrollViewDelegate方法中进行设计- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat width &#x3D; UIScreen.mainScreen.bounds.size.width; CGFloat viewHeight &#x3D; kScreenWidth * 0.5; &#x2F;&#x2F; View1的初始高度 CGFloat yOffset &#x3D; scrollView.contentOffset.y; if (yOffset &lt; 0) &#123; CGFloat totalOffset &#x3D; viewHeight + ABS(yOffset); CGFloat f &#x3D; totalOffset &#x2F; viewHeight; self.headerView.frame &#x3D; CGRectMake(- (width * f - width) &#x2F; 2, yOffset, width * f, totalOffset); &#125;&#125; 10、Masonry制作就宫格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F;Objective-C ----&gt; Masonry&#x2F;** 多视图布局 @param viewArray 视图数组 @param column 列数 @param tbSpeace 视图上下间距 @param lrSpeace 视图左右间距 @param topSpeace 和父视图上间距 @param lrSuperViewSpeace 父视图左右间距 @param superView 父视图 @param viewHeight 视图高度 *&#x2F;- (void)wd_masLayoutSubViewsWithViewArray:(NSArray&lt;UIView *&gt; *)viewArray columnOfRow:(NSInteger)column topBottomOfItemSpeace:(CGFloat)tbSpeace leftRightItemSpeace:(CGFloat)lrSpeace topOfSuperViewSpeace:(CGFloat)topSpeace leftRightSuperViewSpeace:(CGFloat)lrSuperViewSpeace addToSubperView:(UIView *)superView viewHeight:(CGFloat)viewHeight&#123; CGFloat viewWidth &#x3D; superView.bounds.size.width; CGFloat itemWidth &#x3D; (viewWidth - lrSuperViewSpeace * 2 - (column - 1) * lrSpeace) &#x2F; column * 1.0f; CGFloat itemHeight &#x3D; viewHeight; UIView *last &#x3D; nil; for (int i &#x3D; 0; i &lt; viewArray.count; i++) &#123; UIView *item &#x3D; viewArray[i]; [superView addSubview:item]; [item mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(itemWidth); make.height.mas_equalTo(itemHeight); CGFloat top &#x3D; topSpeace + (i &#x2F; column) * (itemHeight + tbSpeace); make.top.mas_offset(top); if (!last || (i % column) &#x3D;&#x3D; 0) &#123; make.left.mas_offset(lrSuperViewSpeace); &#125;else&#123; make.left.mas_equalTo(last.mas_right).mas_offset(lrSpeace); &#125; &#125;]; last &#x3D; item; &#125;&#125; 11、Snapkit制作九宫格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;&#x2F;Swift ----&gt; SnapKit &#x2F;&#x2F;&#x2F; 多视图布局 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Parameters: &#x2F;&#x2F;&#x2F; - viewArray: 视图数组 &#x2F;&#x2F;&#x2F; - columnOfRow: 列数 &#x2F;&#x2F;&#x2F; - topBottomOfItemSpeace: 视图上下间距 &#x2F;&#x2F;&#x2F; - leftRightItemSpeace: 视图左右间距 &#x2F;&#x2F;&#x2F; - topOfSuperViewSpeace: 和父视图上间距 &#x2F;&#x2F;&#x2F; - leftRightSuperViewSpeace: 父视图左右间距 &#x2F;&#x2F;&#x2F; - addToSubperView: 父视图 &#x2F;&#x2F;&#x2F; - viewHeight: 视图高度 func wd_masLayoutSubViews(viewArray:Array&lt;UIView&gt;, columnOfRow:Int, topBottomOfItemSpeace:CGFloat, leftRightItemSpeace:CGFloat, topOfSuperViewSpeace:CGFloat, leftRightSuperViewSpeace:CGFloat, addToSubperView:UIView, viewHeight:CGFloat) -&gt; Void &#123; let viewWidth &#x3D; addToSubperView.bounds.width let tempW &#x3D; leftRightSuperViewSpeace * 2 + CGFloat(columnOfRow - 1) * leftRightItemSpeace let itemWidth &#x3D; (viewWidth - tempW) &#x2F; CGFloat(columnOfRow) let itemHeight &#x3D; viewHeight print(leftRightSuperViewSpeace,leftRightItemSpeace,itemWidth) var lastView:UIView? for (index) in viewArray.enumerated() &#123; let item &#x3D; viewArray[i] addToSubperView.addSubview(item) item.snp.makeConstraints &#123; (make) in make.width.equalTo(itemWidth) make.height.equalTo(itemHeight) let top &#x3D; topOfSuperViewSpeace + CGFloat(i &#x2F; columnOfRow) * (itemHeight + topBottomOfItemSpeace) make.top.equalTo(top) if !(lastView !&#x3D; nil) || i%columnOfRow &#x3D;&#x3D; 0 &#123; make.left.equalTo(leftRightSuperViewSpeace) &#125; else &#123; make.left.equalTo((lastView?.snp.right)!).offset(leftRightItemSpeace) &#125; lastView &#x3D; item &#125; &#125; &#125; 12、沉浸式TableView(ScrollView、CollectionView) 12345if (@available(iOS 11.0, *)) &#123; self.tableView.contentInsetAdjustmentBehavior &#x3D; UIScrollViewContentInsetAdjustmentNever;&#125; else &#123; self.automaticallyAdjustsScrollViewInsets &#x3D; false;&#125; 13、通过身份证计算年龄 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** 通过身份证计算年龄 *&#x2F;- (NSString *)calculationAgeWithBirthday: (NSString *)birthday &#123; NSCalendar *calendar &#x3D; [NSCalendar currentCalendar]; NSDate *nowDate &#x3D; [NSDate date]; NSString *birth &#x3D; birthday; NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc]init]; [dateFormatter setDateFormat:@&quot;yyyy-MM-dd&quot;]; NSDate *birthDay &#x3D; [dateFormatter dateFromString:birth]; unsigned int unitFlags &#x3D; NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay; NSDateComponents *date &#x3D; [calendar components:unitFlags fromDate:birthDay toDate:nowDate options:0]; if ([date year] &gt; 0) &#123; return [NSString stringWithFormat:@&quot;%ld岁&quot;, (long)[date year]]; &#125; else if([date month] &gt; 0) &#123; return [NSString stringWithFormat:@&quot;%ld月&quot;, (long)[date month]]; &#125; else if([date day] &gt; 0)&#123; return [NSString stringWithFormat:@&quot;%ld天&quot;, (long)[date day]]; &#125; else &#123; return @&quot;0天&quot;; &#125;&#125;- (NSString *)ageStrFromIdentityCard:(NSString *)numberStr &#123; NSString *dateSt; NSMutableString *dateS; if (numberStr.length &gt; 15) &#123; dateSt &#x3D; [numberStr substringWithRange:NSMakeRange(6, 8)]; dateS &#x3D; [NSMutableString stringWithFormat:@&quot;%@&quot;, dateSt]; [dateS insertString:@&quot;-&quot; atIndex:4]; [dateS insertString:@&quot;-&quot; atIndex:7]; &#125; else &#123; &#x2F;&#x2F; 只考虑 19开头的15位的身份证号 dateSt &#x3D; [NSString stringWithFormat:@&quot;19%@&quot;,[numberStr substringWithRange:NSMakeRange(6, 6)]]; dateS &#x3D; [NSMutableString stringWithFormat:@&quot;%@&quot;, dateSt]; [dateS insertString:@&quot;-&quot; atIndex:4]; [dateS insertString:@&quot;-&quot; atIndex:7]; &#125; return [self calculationAgeWithBirthday:dateS];&#125;","categories":[{"name":"iOS开发技巧","slug":"iOS开发技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}]},{"title":"代码块(Snippet)","slug":"代码块(Snippet)","date":"2020-01-16T08:06:56.902Z","updated":"2020-01-20T02:30:16.351Z","comments":true,"path":"2020/01/16/代码块(Snippet)/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/%E4%BB%A3%E7%A0%81%E5%9D%97(Snippet)/","excerpt":"","text":"代码块(Snippet)，方便了代码快速创建。 管理：在新版Xcode中管理页面在编译器的右上角 添加：选中代码鼠标右击 编辑 Title：标题。 Summary：描述文字。 Platform：可以使用的平台（如iOS、Mac OS）。 Language：可以在哪些语言中使用（如 Objective-C、Swift）。 Completion Shortcut：快捷方式，以字母开头（支持少数符号，如@）。 Completion Scopes：作用范围，一般写在正确的位置拖动即可，Xcode会自行选择好。 属性12345@property (nonatomic, strong) &lt;#ClassName#&gt; *&lt;#class#&gt;; &#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt;@property (nonatomic, assign) &lt;#DataType#&gt; &lt;#name#&gt;; &#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt;@property (nonatomic, copy) &lt;#ClassName#&gt; *&lt;#name#&gt;; &#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt;@property (nonatomic, weak) id&lt;&lt;#delegateOrDataSouce#&gt;&gt; &lt;#delegateOrDataSouce#&gt;; &#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt;@property (nonatomic, weak) &lt;#Class#&gt; *&lt;#name#&gt;; &#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt; 常用注释 顶部注释 1&#x2F;** &lt;#属性注释#&gt; *&#x2F; 右侧注释 1&#x2F;&#x2F;&#x2F;&lt; &lt;#注释#&gt; 简述顶部注释 123&#x2F;** &lt;#简要描述#&gt; * &lt;#详细描述#&gt; *&#x2F; Pragma 有分割线1#pragma mark &lt;#mark#&gt; 无分割线1#pragma mark - &lt;#mark&gt; 或 &#x2F;&#x2F; MARK: &lt;#mark#&gt; Warning(警告) 1#warning &lt;#message#&gt; ???(不确定) 1&#x2F;&#x2F; ???: &lt;#???#&gt; !!!(警告) 1&#x2F;&#x2F; !!!: &lt;#???#&gt; FIXME(需要修改的地方) 1&#x2F;&#x2F; FIXME: &lt;#Fix详情#&gt; 常用方法 123456789#pragma mark - 页面控件配置- (void)setupSubViewsProperties &#123; &#125;#pragma mark - 页面控件布局- (void)setupSubViewsConstraint &#123; &#125; 枚举 1234567typedef NS_ENUM(NSInteger, &lt;#TypeName#&gt;) &#123; &#125;;typedef NS_OPTIONS(NSUInteger, &lt;#TypeName#&gt;) &#123; &#125;; IFDEBUG 12345#if DEBUG&lt;#TODO#&gt;#else&lt;#TODO#&gt;#endif 快捷初始化UILabel 123456UILabel *l &#x3D; [[UILabel alloc] init];l.font &#x3D; [UIFont &lt;#font#&gt;];l.text &#x3D; @&quot;&lt;#conent#&gt;&quot;;l.textColor &#x3D; [UIColor &lt;#textColor#&gt;];l.numberOfLines &#x3D; 0;[&lt;#view#&gt; addSubview:l]; 快捷初始化UIButton 12345678UIButton *b &#x3D; [UIButton buttonWithType:UIButtonTypeCustom];b.backgroundColor &#x3D; [UIColor &lt;#backgroundColor#&gt;];b.titleLabel.font &#x3D; [UIFont &lt;#font#&gt;];[b setTitle:&lt;#title#&gt; forState:UIControlStateNormal];[b setTitleColor:[UIColor &lt;#titleColor#&gt;] forState:UIControlStateNormal];[b setImage:[UIImage imageNamed:&lt;#(nonnull NSString *)#&gt;] forState:UIControlStateNormal][b addTarget:self action:@selector(didTapped&lt;#Button Name#&gt;:) forControlEvents:UIControlEventTouchUpInside];[&lt;#view#&gt; addSubview:b]; UIButton 点击事件 1234&#x2F;** &lt;#ButtonName#&gt;点击事件 *&#x2F;- (void)didTapped&lt;#ButtonName#&gt;:(UIButton *)sender &#123; &#125; Notification事件 1234&#x2F;** &lt;#Notification Name#&gt;通知事件 *&#x2F;- (void)didReceive&lt;#Notification Name#&gt;:(NSNotification *)notification &#123; &#125; UIGestureRecognizer触摸事件 1234&#x2F;** &lt;#GestureRecognizer Name#&gt;触摸事件 *&#x2F;- (void)didRecognized&lt;#GestureRecognizer Name#&gt;:(UIGestureRecognizer *)recognizer &#123; &#125; 结束语这也是为了个人意见，其他还有很多可以做成代码块的，例如CGD，TableViewDataSource等等，希望短短的文章可以让你代码可以写的更好。","categories":[{"name":"iOS开发技巧","slug":"iOS开发技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}]},{"title":"JavaScript与原生交互","slug":"JavaScript与原生交互","date":"2020-01-16T08:06:48.781Z","updated":"2020-01-20T02:06:38.242Z","comments":true,"path":"2020/01/16/JavaScript与原生交互/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/JavaScript%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/","excerpt":"","text":"原生页面与HTML页面进行相互调用方式 | 适用对象—|—拦截URL | UIWebView和WKWebViewJavaScriptCore | UIWebViewMessageHandler | WKWebViewWebViewJavascriptBridge| UIWebView和WKWebView 实例HTML代码1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;h2&gt;按钮点击&lt;&#x2F;h2&gt; &lt;button type&#x3D;&quot;submit&quot; onclick&#x3D;&quot;buttonEvent()&quot; id&#x3D;&quot;submitButto&quot;&gt;提交&lt;&#x2F;button&gt; &lt;h2&gt;文件上传&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;file&quot; &#x2F;&gt; &lt;h2&gt;原生注入数据&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;textField&quot;&gt; &lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;getTextEvent()&quot; value&#x3D;&quot;开始注入&quot;&gt; &lt;script&gt; function loadURL(url) &#123; var iFrame; iFrame &#x3D; document.createElement(&quot;iframe&quot;); iFrame.setAttribute(&quot;src&quot;, url); iFrame.setAttribute(&quot;style&quot;, &quot;display:none;&quot;); iFrame.setAttribute(&quot;height&quot;, &quot;0px&quot;); iFrame.setAttribute(&quot;width&quot;, &quot;0px&quot;); iFrame.setAttribute(&quot;frameborder&quot;, &quot;0&quot;); document.body.appendChild(iFrame); iFrame.parentNode.removeChild(iFrame); iFrame &#x3D; null; &#125; function buttonEvent()&#123; loadURL(&quot;&#x2F;buttonEvent&quot;); buttonDidPapped(); &#125; function getTextEvent() &#123; loadURL(&quot;&#x2F;getText&quot;); getTextButtonDidPapped(); &#125; function getText(text)&#123; document.getElementById(&quot;textField&quot;).value &#x3D; text; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 拦截URLUIWebView遵循UIWebViewDelegate调用- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType方法，判断获取的Url地址 123456789101112131415&#x2F;&#x2F; 调用JSif ([request.URL.absoluteString hasSuffix:@&quot;buttonEvent&quot;]) &#123; UIAlertController *vc &#x3D; [UIAlertControlleralertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;点击了提交按钮&quot; preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; return NO;&#125; &#x2F;&#x2F; 注入数据给JSif ([request.URL.absoluteString hasSuffix:@&quot;getText&quot;]) &#123; [webView stringByEvaluatingJavaScriptFromString:@&quot;getText(&#39;哈哈&#39;)&quot;]; return NO;&#125;return YES; WKWebView遵循WKNavigationDelegate调用- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler方法判断获取的地址 1234567891011121314151617NSString *strRequest &#x3D; [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding];&#x2F;&#x2F; 调用JSif ([strRequest hasSuffix:@&quot;buttonEvent&quot;]) &#123; UIAlertController *vc &#x3D; [UIAlertController alertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;点击了提交按钮&quot; preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; decisionHandler(WKNavigationActionPolicyCancel);&#125; else if ([strRequest hasSuffix:@&quot;getText&quot;]) &#123; &#x2F;&#x2F; 注入数据给JS [webView evaluateJavaScript:@&quot;getText(&#39;哈哈&#39;)&quot; completionHandler:^(id _Nullable info, NSError * _Nullable error) &#123; NSLog(@&quot;Error--%@, info--%@&quot;, error, info); &#125;]; decisionHandler(WKNavigationActionPolicyCancel);&#125; else &#123; decisionHandler(WKNavigationActionPolicyAllow);&#125; JavaScriptCore 导入&lt;JavaScriptCore/JavaScriptCore.h&gt; 遵循&lt;UIWebViewDelegate&gt;并实现- (void)webViewDidFinishLoad:(UIWebView *)webView方法。12345678910111213141516171819202122&#x2F;&#x2F; 对JSContext对象进行初始化JSContext *context &#x3D; [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];&#x2F;&#x2F; 验证JSContext对象是否初始化成功context.exceptionHandler &#x3D; ^(JSContext *context, JSValue *exceptionValue)&#123; context.exception &#x3D; exceptionValue;&#125;; &#x2F;&#x2F; 调用JS context[@&quot;buttonDidPapped&quot;] &#x3D; ^&#123; UIAlertController *vc &#x3D; [UIAlertController alertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;点击了提交按钮&quot; preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil];&#125;; &#x2F;&#x2F; 注入数据给JS context[@&quot;getTextButtonDidPapped&quot;] &#x3D; ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.webView stringByEvaluatingJavaScriptFromString:@&quot;getText(&#39;哈哈&#39;)&quot;]; &#125;);&#125;; MessageHandler 修改js中的方法， 通过window.webkit.messageHandlers+操作方法1234567function buttonEvent()&#123; window.webkit.messageHandlers.buttonEvent.postMessage(null);&#125; function getTextEvent() &#123; window.webkit.messageHandlers.getTextEvent.postMessage(null);&#125; 遵循WKScriptMessageHandler 在- (void)viewWillAppear:(BOOL)animated中添加scriptMessageHandler 在- (void)viewWillDisappear:(BOOL)animated中移除scriptMessageHandler 实现WKScriptMessageHandler方法1234567891011121314151617181920212223242526272829303132- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;buttonEvent&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;getTextEvent&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;buttonEvent&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;getTextEvent&quot;];&#125;#pragma mark - WKScriptMessageHandler Method- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; &#x2F;&#x2F; 调用JS if ([message.name isEqualToString:@&quot;buttonEvent&quot;]) &#123; UIAlertController *vc &#x3D; [UIAlertController alertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;点击了提交按钮&quot; preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; return; &#125; &#x2F;&#x2F; 注入数据给JS if ([message.name isEqualToString:@&quot;getTextEvent&quot;]) &#123; [self.webView evaluateJavaScript:@&quot;getText(&#39;哈哈&#39;)&quot; completionHandler:^(id _Nullable info, NSError * _Nullable error) &#123; NSLog(@&quot;Error--%@, info--%@&quot;, error, info); &#125;]; return; &#125;&#125; WebViewJavascriptBridgeHTML代码 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h2&gt;按钮点击&lt;&#x2F;h2&gt; &lt;input id &#x3D; &#39;submitBtn&#39; type&#x3D;&quot;button&quot; value&#x3D;&quot;提交按钮&quot; onclick&#x3D;&quot;submitClick()&quot;&#x2F;&gt; &lt;h2&gt;文件选择&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;image&quot;&gt; &lt;h2&gt;注入数据&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;getTextField&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;开始获取&quot; id &#x3D; &#39;startGet&#39; onclick&#x3D;&quot;getTextClick()&quot;&#x2F;&gt; &lt;script&gt; function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks &#x3D; [callback]; var WVJBIframe &#x3D; document.createElement(&#39;iframe&#39;); WVJBIframe.style.display &#x3D; &#39;none&#39;; WVJBIframe.src &#x3D; &#39;https:&#x2F;&#x2F;__bridge_loaded__&#39;; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; setupWebViewJavascriptBridge(function(bridge) &#123; &#125;) function submitClick() &#123; WebViewJavascriptBridge.callHandler(&#39;submitClick&#39;, null, function(response) &#123; &#125;); &#125; function getTextClick() &#123; WebViewJavascriptBridge.callHandler(&#39;getTextClick&#39;, null, function(response) &#123; document.getElementById(&quot;getTextField&quot;).value &#x3D; response; &#125;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 第三方库：地址 添加WebViewJavascriptBridge库 导入头文件#import &lt;WebViewJavascriptBridge.h&gt; 声明方法@property WebViewJavascriptBridge* bridge; 与WebView关联123_bridge &#x3D; [WebViewJavascriptBridge bridgeForWebView:self.webView];[_bridge setWebViewDelegate:self]; 调用js1234567[_bridge registerHandler:@&quot;submitClick&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; UIAlertController *vc &#x3D; [UIAlertController alertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;点击了提交按钮&quot; preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil];&#125;]; 注入数据123[_bridge registerHandler:@&quot;getTextClick&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; responseCallback(@&quot;哈哈哈&quot;);&#125;];","categories":[],"tags":[]},{"title":"iOS自定义控件-自定义分类下拉","slug":"iOS自定义控件-自定义分类下拉","date":"2020-01-16T08:06:44.955Z","updated":"2020-01-20T02:08:55.469Z","comments":true,"path":"2020/01/16/iOS自定义控件-自定义分类下拉/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%B1%BB%E4%B8%8B%E6%8B%89/","excerpt":"","text":"最近自由时间有点多，就开始撸控件。这个是我们常用的一个下拉分类控件，看了很多别人写的，都是用TableView或者CollectionView整合在一起的感觉自定义性没有那么强，所以就尝试用把TableView和CollectionView替换成UIViewController。其他废话不多说了。 1、 接口文件123456789101112131415161718192021222324252627282930313233343536#import &lt;UIKit&#x2F;UIKit.h&gt;UIKIT_EXTERN NSString *lzDropViewNotification;NS_ASSUME_NONNULL_BEGIN@class LZDropView;@protocol LZDropViewDataSource &lt;NSObject&gt;@required&#x2F;** Height corresponding to controller display *&#x2F;- (NSArray&lt;NSNumber *&gt; *)setupCategoryControllerHeightInDropView:(LZDropView *)dropView;&#x2F;** Title corresponding controller array *&#x2F;- (NSArray&lt;UIViewController *&gt; *)setupCategoryControllerInDropView:(LZDropView *)dropView;&#x2F;** Default display of Title Array *&#x2F;- (NSArray&lt;NSString *&gt; *)setupCategoryTitleNameInDropView:(LZDropView *)dropView;@end@protocol LZDropViewDelegate &lt;NSObject&gt;&#x2F;** Click the column and select the information. *&#x2F;- (void)dropView:(LZDropView *)dropView didSelectAtColumn:(NSInteger)column info:(NSString *)info;@end@interface LZDropView : UIView&#x2F;** Simple page configuration *&#x2F;@property (nonatomic, weak) id &lt;LZDropViewDataSource&gt; dataSorce;&#x2F;** Click proxy event&lt;##&gt; *&#x2F;@property (nonatomic, weak) id &lt;LZDropViewDelegate&gt; delegate;@endNS_ASSUME_NONNULL_END 2、 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#import &quot;LZDropView.h&quot;NSString *lzDropViewNotification &#x3D; @&quot;nitification&quot;;@interface LZDropView ()@property (nonatomic, strong) NSArray&lt;UIViewController *&gt; *controllerArray;@property (nonatomic, strong) NSArray&lt;NSString *&gt; *titleArray;@property (nonatomic, strong) UIButton *containerView;@property (nonatomic, strong) NSArray&lt;NSNumber *&gt; *controllerHeightArray;@property (nonatomic, strong) NSMutableArray&lt;UIButton *&gt; *buttonArray;@end@implementation LZDropView#pragma mark - Release memory- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;#pragma mark - Initialization- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationAction:) name:lzDropViewNotification object:nil]; &#125; return self;&#125;#pragma mark - Draw the page- (void)setupTitleButton:(NSArray&lt;NSString *&gt; *)array &#123; CGFloat width &#x3D; UIScreen.mainScreen.bounds.size.width &#x2F; array.count; self.buttonArray &#x3D; [NSMutableArray array]; for (NSString *name in array) &#123; NSInteger index &#x3D; [array indexOfObject:name]; UIButton *button &#x3D; [UIButton buttonWithType:UIButtonTypeCustom]; button.titleLabel.font &#x3D; [UIFont systemFontOfSize:15]; [button setTitle:[NSString stringWithFormat:@&quot;%@ ▼&quot;, name] forState:UIControlStateNormal]; [button setTitle:[NSString stringWithFormat:@&quot;%@ ▲&quot;, name] forState:UIControlStateSelected]; [button setTitleColor:UIColor.grayColor forState:UIControlStateNormal]; [button setTitleColor:UIColor.orangeColor forState:UIControlStateSelected]; button.frame &#x3D; CGRectMake(width * index, 0, width, 45); button.tag &#x3D; index + 1000; [button addTarget:self action:@selector(buttonTouched:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:button]; [self.buttonArray addObject:button]; &#125;&#125;#pragma mark - Button click event- (void)buttonTouched:(UIButton *)sender &#123; if (sender.selected) &#123; [self closeControllerView]; &#125; else &#123; [self openControllerViewWithButton:sender]; &#125;&#125;- (void)backButtonTouched:(UIButton *)sender &#123; [self closeControllerView];&#125;#pragma mark - Notification event- (void)notificationAction:(NSNotification *)notification &#123; if (![self.controllerArray containsObject:notification.object]) &#123; return; &#125; NSInteger index &#x3D; [self.controllerArray indexOfObject:notification.object]; UIButton *button &#x3D; self.buttonArray[index]; [button setTitle:[NSString stringWithFormat:@&quot;%@ ▼&quot;, notification.userInfo.allValues.firstObject] forState:UIControlStateNormal]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dropView:didSelectAtColumn:info:)]) &#123; [self.delegate dropView:self didSelectAtColumn:index info:notification.userInfo.allValues.firstObject]; &#125; [self closeControllerView];&#125;#pragma mark - Close all controllers.- (void)closeControllerView &#123; [UIView animateWithDuration:0.8 animations:^&#123; self.containerView.alpha &#x3D; 0; self.containerView.frame &#x3D; CGRectMake(0, CGRectGetMaxY(self.frame), UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; [self.containerView removeFromSuperview]; &#125;]; for (UIButton *button in self.buttonArray) &#123; button.selected &#x3D; false; &#125;&#125;#pragma mark - Open the corresponding controller.- (void)openControllerViewWithButton:(UIButton *)sender &#123; for (UIButton *button in self.buttonArray) &#123; button.selected &#x3D; false; &#125; self.containerView.alpha &#x3D; 1; for (UIView *view in self.containerView.subviews) &#123; [view removeFromSuperview]; &#125; UIViewController *vc &#x3D; self.controllerArray[sender.tag - 1000]; double vcHeight &#x3D; [self.controllerHeightArray[sender.tag - 1000] doubleValue]; self.containerView.frame &#x3D; CGRectMake(0, CGRectGetMaxY(self.frame), self.frame.size.width, 0); vc.view.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 0); [self.superview addSubview:self.containerView]; [self.containerView addSubview:vc.view]; [UIView animateWithDuration:0.6 animations:^&#123; self.containerView.frame &#x3D; CGRectMake(0, CGRectGetMaxY(self.frame), self.frame.size.width, UIScreen.mainScreen.bounds.size.height); vc.view.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, vcHeight); &#125; completion:^(BOOL finished) &#123; &#125;]; sender.selected &#x3D; true;&#125;#pragma mark - Getter- (UIView *)containerView &#123; if (!_containerView) &#123; _containerView &#x3D; [[UIButton alloc] init]; _containerView.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0.1]; [_containerView addTarget:self action:@selector(backButtonTouched:) forControlEvents:UIControlEventTouchUpInside]; &#125; return _containerView;&#125;#pragma mark - Setter- (void)setDataSorce:(id&lt;LZDropViewDataSource&gt;)dataSorce &#123; _dataSorce &#x3D; dataSorce; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryControllerInDropView:)])&#123; self.controllerArray &#x3D; [self.dataSorce setupCategoryControllerInDropView:self]; &#125; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryTitleNameInDropView:)])&#123; self.titleArray &#x3D; [self.dataSorce setupCategoryTitleNameInDropView:self]; [self setupTitleButton:self.titleArray]; &#125; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryControllerHeightInDropView:)]) &#123; self.controllerHeightArray &#x3D; [self.dataSorce setupCategoryControllerHeightInDropView:self]; &#125; if (self.controllerArray.count !&#x3D; self.titleArray.count || self.controllerArray.count !&#x3D; self.controllerHeightArray.count) &#123; @throw [NSException exceptionWithName:NSStringFromClass([self class]) reason:@&quot;The number of corresponding arrays is inconsistent.&quot; userInfo:nil]; &#125;&#125;@end 使用方式 1.遵循协议 1&lt;LZDropViewDataSource, LZDropViewDelegate&gt; 2.初始化 123456LZDropView *view &#x3D; [[LZDropView alloc] init]; view.dataSorce &#x3D; self; view.delegate &#x3D; self; view.backgroundColor &#x3D; UIColor.whiteColor; view.frame &#x3D; CGRectMake(0, 100, UIScreen.mainScreen.bounds.size.width, 45); [self.view addSubview:view]; 实现代理和数据源12345678910111213141516171819202122232425262728#pragma mark - LZDropViewDataSource- (NSArray&lt;UIViewController *&gt; *)setupCategoryControllerInDropView:(LZDropView *)dropView &#123; return @[[[TableViewController alloc] init], [[TableViewController alloc] init], [[TableViewController alloc] init], [[TableViewController alloc] init]];&#125;- (NSArray&lt;NSString *&gt; *)setupCategoryTitleNameInDropView:(LZDropView *)dropView &#123; return @[@&quot;全部&quot;, @&quot;附近&quot;, @&quot;只能排序&quot;, @&quot;筛选&quot;];&#125;- (NSArray&lt;NSNumber *&gt; *)setupCategoryControllerHeightInDropView:(LZDropView *)dropView &#123; return @[[NSNumber numberWithFloat:300], [NSNumber numberWithFloat:400], [NSNumber numberWithFloat:410], [NSNumber numberWithFloat:420]];&#125;#pragma mark - LZDropViewDelegate- (void)dropView:(LZDropView *)dropView didSelectAtColumn:(NSInteger)column info:(NSString *)info &#123; NSLog(@&quot;%ld---%@&quot;, column, info);&#125; 点击controller中的数据显示在按钮的标题中，这因为跨界面显示，我暂时没有想到好的办法，所以使用强大的通知传值。 记录选中状态，应该是控制器里面的操作，这里就没有实现1[[NSNotificationCenter defaultCenter] postNotificationName:lzDropViewNotification object:self userInfo:@&#123;@&quot;key&quot;:[NSString stringWithFormat:@&quot;第%ldcell&quot;, indexPath.row]&#125;]; 如果有什么不好如果建议的地方，请批评指正！","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-一个简易的Combobox","slug":"iOS自定义控件-一个简易的Combobox","date":"2020-01-16T08:06:36.855Z","updated":"2020-01-20T02:08:43.532Z","comments":true,"path":"2020/01/16/iOS自定义控件-一个简易的Combobox/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84Combobox/","excerpt":"","text":"代码简单易懂，属于自己练手的代码，还在学习，写的不好，希望勿喷1、头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, WDComboBoxControlDirection) &#123; WDComboBoxControlDirectionTop, WDComboBoxControlDirectionLeading, WDComboBoxControlDirectionTrailing, WDComboBoxControlDirectionBottom,&#125;;@protocol WDComboBoxControlDataSource &lt;NSObject&gt;@optional&#x2F;** &lt; 数据数组 &gt; *&#x2F;- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm;@required&#x2F;** &lt; 标题数组 &gt; *&#x2F;- (NSArray&lt;NSString *&gt; *)titleOfSection;@end@protocol WDComboBoxControlDelegate &lt;NSObject&gt;&#x2F;** 点击事件 @param indexPath indexPath description @param title title description @param sourceView sourceView description *&#x2F;- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView;@end@interface WDComboBoxControl : UIView@property (nonatomic, weak) id &lt;WDComboBoxControlDataSource&gt; dataSource;@property (nonatomic, weak) id &lt;WDComboBoxControlDelegate&gt; delegate;&#x2F;** &lt; 背景按钮，可以定义需要的属性 &gt; *&#x2F;@property (nonatomic, strong) UIButton *backgroundButton;&#x2F;** &lt; 内容TableView，也可以定义一些属性 &gt; *&#x2F;@property (nonatomic, strong) UITableView *tableView;&#x2F;** 初始化方法 @param height 显示内容高度 @param view 参考View @return return value description *&#x2F;- (instancetype)initViewWithMaxHeight:(CGFloat)height fromView:(UIView *)view showDirection:(WDComboBoxControlDirection)direction;&#x2F;** 显示页面 *&#x2F;- (void)showInView;@endNS_ASSUME_NONNULL_END 2、实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#import &quot;WDComboBoxControl.h&quot;@interface WDComboBoxControl () &lt;UITableViewDelegate, UITableViewDataSource&gt;@property (nonatomic, assign) CGFloat viewHeight;@property (nonatomic, strong) NSArray&lt;NSArray&lt;NSString *&gt; *&gt; * dataArray;@property (nonatomic, strong) NSArray&lt;NSString *&gt; * titleArray;@property (nonatomic, strong) UIView *sourceView;@property (nonatomic, assign) WDComboBoxControlDirection direction;@end@implementation WDComboBoxControl#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 初始化页面 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (instancetype)initViewWithMaxHeight:(CGFloat)height fromView:(UIView *)view showDirection:(WDComboBoxControlDirection)direction &#123; self &#x3D; [super init]; if (self) &#123; _viewHeight &#x3D; height; _sourceView &#x3D; view; _direction &#x3D; direction; [self setupSubViewsPropertys]; [self setupSubViewsConstraints]; &#125; return self;&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 显示页面 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)showInView &#123; self.frame &#x3D; UIScreen.mainScreen.bounds; [UIApplication.sharedApplication.delegate.window addSubview:self];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 让页面消失 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)dismisssView &#123; [self removeFromSuperview];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 获取数据源 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)setDataSource:(id&lt;WDComboBoxControlDataSource&gt;)dataSource &#123; _dataSource &#x3D; dataSource; if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(dataSourceOfColunm)]) &#123; self.dataArray &#x3D; [self.dataSource dataSourceOfColunm]; &#125; if (self.dataArray &amp;&amp; [self.dataSource respondsToSelector:@selector(titleOfSection)]) &#123; self.titleArray &#x3D; [self.dataSource titleOfSection]; &#125; [self.tableView reloadData];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Add controls, set properties &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)setupSubViewsPropertys &#123; self.backgroundButton &#x3D; [[UIButton alloc] init]; self.backgroundButton.backgroundColor &#x3D; UIColor.clearColor; [self.backgroundButton addTarget:self action:@selector(dismisssView) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:self.backgroundButton]; self.tableView &#x3D; [[UITableView alloc] init]; self.tableView.delegate &#x3D; self; self.tableView.dataSource &#x3D; self; self.tableView.tableFooterView &#x3D; [[UIView alloc] init]; self.tableView.layer.borderColor &#x3D; UIColor.lightGrayColor.CGColor; self.tableView.layer.borderWidth &#x3D; 0.5; self.tableView.estimatedRowHeight &#x3D; 45; self.tableView.layer.cornerRadius &#x3D; 5; self.tableView.rowHeight &#x3D; UITableViewAutomaticDimension; [self addSubview:self.tableView];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Setting control layout constraints &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)setupSubViewsConstraints &#123; self.backgroundButton.frame &#x3D; UIScreen.mainScreen.bounds; switch (self.direction) &#123; case WDComboBoxControlDirectionBottom:&#123; self.tableView.frame &#x3D; CGRectMake(CGRectGetMinX(self.sourceView.frame), CGRectGetMaxY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionTop:&#123; self.tableView.frame &#x3D; CGRectMake(CGRectGetMinX(self.sourceView.frame), CGRectGetMaxY(self.sourceView.frame) - self.viewHeight - self.sourceView.frame.size.height, self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionLeading:&#123; self.tableView.frame &#x3D; CGRectMake(CGRectGetMinX(self.sourceView.frame) - self.sourceView.frame.size.width, CGRectGetMinY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionTrailing:&#123; self.tableView.frame &#x3D; CGRectMake(CGRectGetMinX(self.sourceView.frame) + self.sourceView.frame.size.width, CGRectGetMinY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; default: break; &#125; &#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; UITableViewDelegate, UITableViewDataSource &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section &#123; return self.titleArray[section];&#125;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return self.dataArray.count;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return [self.dataArray[section] count];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; if (!cell) &#123; cell &#x3D; [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cell&quot;]; &#125; cell.textLabel.text &#x3D; self.dataArray[indexPath.section][indexPath.row]; cell.textLabel.numberOfLines &#x3D; 0; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selectedAtIndexPath:resultTitle: fromSourceView:)]) &#123; [self.delegate selectedAtIndexPath:indexPath resultTitle:self.dataArray[indexPath.section][indexPath.row] fromSourceView:self.sourceView]; [self dismisssView]; &#125;&#125;@end 3、使用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;&#x2F; 1、导入头文件#import &quot;WDComboBoxControl.h&quot;&#x2F;&#x2F; 2、遵循代理和数据源&lt;WDComboBoxControlDataSource, WDComboBoxControlDelegate&gt;&#x2F;&#x2F; 3、实现方法#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WDComBoxControlDataSource &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (NSArray&lt;NSString *&gt; *)titleOfSection;- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WDComBoxControlDelegate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView;&#x2F;&#x2F; 下面是实例：@property (nonatomic, strong) UIButton *button;@property (nonatomic, strong) UIButton *button2;- (void)viewDidLoad &#123; [super viewDidLoad]; &#x2F;&#x2F; Do any additional setup after loading the view. UIButton *button &#x3D; [[UIButton alloc] init]; [button setTitleColor:UIColor.blackColor forState:UIControlStateNormal]; [button addTarget:self action:@selector(buttonShow:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button]; button.layer.borderColor &#x3D; UIColor.lightGrayColor.CGColor; button.layer.borderWidth &#x3D; 0.5; [button setTitle:@&quot;按钮&quot; forState:UIControlStateNormal]; [button mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.mas_equalTo(self.view); make.top.mas_equalTo(self.wdNavigationBar.mas_bottom); make.width.mas_equalTo(300); &#125;]; self.button &#x3D; button; UIButton *button2 &#x3D; [[UIButton alloc] init]; [button2 setTitleColor:UIColor.blackColor forState:UIControlStateNormal]; [button2 addTarget:self action:@selector(buttonShow:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button2]; button2.layer.borderColor &#x3D; UIColor.lightGrayColor.CGColor; button2.layer.borderWidth &#x3D; 0.5; [button2 setTitle:@&quot;按钮2&quot; forState:UIControlStateNormal]; button2.bounds &#x3D; CGRectMake(0, 0, 300, 50); button2.center &#x3D; self.view.center; self.button2 &#x3D; button2;&#125;- (void)buttonShow:(UIButton *)sender &#123; WDComboBoxControl *view &#x3D; [[WDComboBoxControl alloc] initViewWithMaxHeight:400 fromView:sender showDirection:WDComboBoxControlDirectionBottom]; view.dataSource &#x3D; self; view.delegate &#x3D; self; view.backgroundButton.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0.3]; [view showInView];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WDComBoxControlDataSource &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (NSArray&lt;NSString *&gt; *)titleOfSection &#123; return @[@&quot;安徽省&quot;, @&quot;浙江省&quot;, @&quot;江苏省&quot;, @&quot;安徽省&quot;, @&quot;浙江省&quot;, @&quot;江苏省&quot;];&#125;- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm &#123; return @[@[@&quot;合肥&quot;, @&quot;芜湖&quot;, @&quot;安庆&quot;], @[@&quot;南京&quot;, @&quot;苏州&quot;, @&quot;无锡&quot;], @[@&quot;杭州&quot;, @&quot;宁波&quot;, @&quot;温州&quot;], @[@&quot;合肥&quot;, @&quot;芜湖&quot;, @&quot;安庆&quot;], @[@&quot;南京&quot;, @&quot;苏州&quot;, @&quot;无锡&quot;], @[@&quot;杭州&quot;, @&quot;宁波&quot;, @&quot;温州&quot;]];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WDComBoxControlDelegate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView &#123; UIButton *sender &#x3D; (UIButton *)sourceView; [sender setTitle:title forState:UIControlStateNormal];&#125; 4、效果图 5、Demo地址（代码都在这里了，就不弄个Demo了，这个可以自定义的地方还有很多，TableView和背景的Button都可以，随心所欲吧！）","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-图片浏览器","slug":"iOS自定义控件-图片浏览器","date":"2020-01-16T08:06:32.455Z","updated":"2020-01-20T02:15:04.551Z","comments":true,"path":"2020/01/16/iOS自定义控件-图片浏览器/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"一直想写一个自己的图片浏览器，但是自己能力又不是很够，所以一直拖这，最近趁自己时间充裕，自己研究了一下这方面的知识。感觉有以下几个难点： 显示和消失的转场动画 手势拖拽 图片加载 加载方式和转场动画 通过Controller加载：需要使用ViewController实现UIViewControllerAnimatedTransitioning实现转场效果 通过View加载：使用UIView动画试下转场效果 转场动画必要元素 显示时需要fromView的frame 消失时需要toView的frame显示通过修改当前需要显示图片的CollectionViewCell中ImageView的frame，同时修改当期View的背景颜色透明度1234567WDImageCollectionViewCell *cell &#x3D; (WDImageCollectionViewCell *)[self.collectionView cellForItemAtIndexPath:[NSIndexPath indexPathForRow:self.tappedIndex inSection:0]];CGRect fromFrame &#x3D; [self.originView convertRect:self.originView.bounds toView:cell.contentView];cell.imageView.frame &#x3D; fromFrame;[UIView animateWithDuration:0.5 animations:^&#123; self.backgroundColor &#x3D; [[UIColor alloc] initWithWhite:0 alpha:1]; cell.imageView.frame &#x3D; cell.contentView.bounds;&#125;]; 消失原理与显示相同12345678CGRect toRect &#x3D; [self.originView convertRect:self.originView.bounds toView:self.window];[UIView animateWithDuration:0.5 animations:^&#123; cell.imageView.clipsToBounds &#x3D; YES; cell.imageView.frame &#x3D; toRect; self.backgroundColor &#x3D; [[UIColor alloc] initWithWhite:0 alpha:0];&#125; completion:^(BOOL finished) &#123; [self removeFromSuperview];&#125;]; 拖拽的手势将手势添加在CollectionViewCell中ScrollView上，并遵循UIGestureRecognizerDelegate协议，不然会CollectionView无法进行滚动操作。 声明一个全局属性1CGPoint firstTouchPoint; 实现代理123456789101112131415161718#pragma mark - UIGestureRecognizer Delegate Method- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123; firstTouchPoint &#x3D; [touch locationInView:self.window]; return YES;&#125;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; CGPoint touchPoint &#x3D; [gestureRecognizer locationInView:self.window]; CGFloat dirTop &#x3D; firstTouchPoint.y - touchPoint.y; if (dirTop &gt; -10 &amp;&amp; dirTop &lt; 10) &#123; return NO; &#125; CGFloat dirLift &#x3D; firstTouchPoint.x - touchPoint.x; if (dirLift &gt; -10 &amp;&amp; dirLift &lt; 10 &amp;&amp; self.scrollView.frame.size.height &gt; [[UIScreen mainScreen] bounds].size.height) &#123; return NO; &#125; return YES;&#125; 拖动手势操作，同意代理传给View 协议方法123456@class WDImageCollectionViewCell;@protocol WDImageCollectionViewCellDelegate &lt;NSObject&gt;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell singleTapActionWithImageUrl:(NSString *)imageUrl;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell panActionWithPercent:(CGFloat)percent;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell dimssViewWithImageUrl:(NSString *)imageUrl;@end 拖动手势方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#pragma mark - UIGestureRecognizer Target Event&#x2F;** 滑动手势 *&#x2F;- (void)didRecognizedPanGuesture:(UIPanGestureRecognizer *)pan &#123; CGPoint point &#x3D; [pan translationInView:self.window]; CGFloat scale &#x3D; 1.0 - ABS(point.y) &#x2F; [[UIScreen mainScreen] bounds].size.height; switch (pan.state) &#123; case UIGestureRecognizerStateBegan: &#123;&#125; break; case UIGestureRecognizerStateChanged: &#123; scale &#x3D; MAX(scale, 0); CGFloat s &#x3D; MAX(scale, 0.5); CGAffineTransform translation &#x3D; CGAffineTransformMakeTranslation(point.x &#x2F; s, point.y &#x2F; s); CGAffineTransform translationScale &#x3D; CGAffineTransformMakeScale(s, s); self.imageView.transform &#x3D; CGAffineTransformConcat(translation, translationScale); &#x2F;&#x2F; 传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:scale]; &#125; &#125; break; case UIGestureRecognizerStateCancelled | UIGestureRecognizerStateFailed: &#123; self.imageView.transform &#x3D; CGAffineTransformIdentity; &#x2F;&#x2F; 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:1]; &#125; &#125; break; case UIGestureRecognizerStateEnded: &#123; [UIView animateWithDuration:0.5 animations:^&#123; CGAffineTransform transform1 &#x3D; CGAffineTransformMakeTranslation(0,0); self.imageView.transform &#x3D; CGAffineTransformScale(transform1, 1, 1); &#125;]; &#x2F;&#x2F; 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:scale]; &#125; if (scale &lt; 0.7) &#123; &#x2F;&#x2F; 拖动结束，让页面消失 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:dimssViewWithImageUrl:)]) &#123; [self.delegate collectionViewCell:self dimssViewWithImageUrl:self.imageUrl]; &#125; &#125; else &#123; &#x2F;&#x2F; 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:1]; &#125; &#125; &#125; break; default: break; &#125;&#125; 图片加载使用SDWebImage获取图片，通过FLAnimatedImageView加载gif图Github地址项目地址效果图","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-提醒条","slug":"iOS自定义控件-提醒条","date":"2020-01-16T08:06:28.698Z","updated":"2020-01-20T02:16:12.571Z","comments":true,"path":"2020/01/16/iOS自定义控件-提醒条/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E6%8F%90%E9%86%92%E6%9D%A1/","excerpt":"","text":"简单的提醒条，代码比较简单，使用容易，代码中目前提供了三种显示的颜色，默认显示文本内容为一行文字，默认高度为20，可以根据自己需求自定义样式。代码同时支持Objective-C和Swift，使用方式有点点差别，详情看代码。 接口文件123456789101112131415161718192021222324252627282930313233343536#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, RemindBarStyle) &#123; RemindBarStyleInfo, &#x2F;&#x2F; 提醒 ❇️ RemindBarStyleWarn, &#x2F;&#x2F; 警告 ⚠️ RemindBarStyleError &#x2F;&#x2F; 错误 ❌&#125;;typedef NS_ENUM(NSInteger, RemindBarPosition) &#123; RemindBarPositionStatusBar, &#x2F;&#x2F; 状态栏下面 RemindBarPositionNavigationBar, &#x2F;&#x2F; 导航栏下面&#125;;@interface LZRemindBar : UIView&#x2F;** 配置显示样式 @param style 样式 @param position 位置 @param text 内容 @return return value description *&#x2F;+ (LZRemindBar *)configurationWithStyle:(RemindBarStyle)style showPosition:(RemindBarPosition)position contentText:(NSString *)text;&#x2F;** 显示 并设置显示时间 @param interval 显示时间 *&#x2F;- (void)showBarAfterTimeInterval:(NSTimeInterval)interval;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#import &quot;LZRemindBar.h&quot;#define bar_IsPhoneX UIApplication.sharedApplication.statusBarFrame.size.height !&#x3D; 20#define bar_topInterval bar_IsPhoneX ? UIApplication.sharedApplication.statusBarFrame.size.height : 0@interface LZRemindBar ()@property (nonatomic, strong) UILabel *contentLabel; &#x2F;&#x2F;*! 文字Label@property (nonatomic, assign) RemindBarPosition position; &#x2F;&#x2F;*! 显示位置@property (nonatomic, assign) BOOL isShowing; &#x2F;&#x2F;*! 是否正在显示@end@implementation LZRemindBar+ (instancetype)remind &#123; static dispatch_once_t onceToken; static LZRemindBar *remind; dispatch_once(&amp;onceToken, ^&#123; remind &#x3D; [[LZRemindBar alloc] init]; &#125;); return remind;&#125;+ (LZRemindBar *)configurationWithStyle:(RemindBarStyle)style showPosition:(RemindBarPosition)position contentText:(NSString *)text &#123; if ([LZRemindBar remind].isShowing) &#123; return [LZRemindBar remind]; &#125; [LZRemindBar remind].contentLabel &#x3D; (&#123; UILabel *label &#x3D; [[UILabel alloc] init]; label.backgroundColor &#x3D; UIColor.clearColor; label.numberOfLines &#x3D; 1; label.textAlignment &#x3D; NSTextAlignmentCenter; label.font &#x3D; [UIFont systemFontOfSize:13]; label.textColor &#x3D; UIColor.whiteColor; [[LZRemindBar remind] addSubview:label]; label.translatesAutoresizingMaskIntoConstraints &#x3D; false; [[label.leadingAnchor constraintEqualToAnchor:[LZRemindBar remind].leadingAnchor] setActive:true]; [[label.trailingAnchor constraintEqualToAnchor:[LZRemindBar remind].trailingAnchor] setActive:true]; [[label.topAnchor constraintEqualToAnchor:[LZRemindBar remind].topAnchor] setActive:true]; [[label.bottomAnchor constraintEqualToAnchor:[LZRemindBar remind].bottomAnchor] setActive:true]; label.text &#x3D; text; label; &#125;); [LZRemindBar remind].isShowing &#x3D; true; [LZRemindBar remind].position &#x3D; position; switch (style) &#123; case RemindBarStyleInfo: [LZRemindBar remind].backgroundColor &#x3D; [UIColor colorWithRed:0 green:166.0&#x2F;255 blue:124.0&#x2F;255 alpha:1]; break; case RemindBarStyleWarn: [LZRemindBar remind].backgroundColor &#x3D; UIColor.orangeColor; break; case RemindBarStyleError: [LZRemindBar remind].backgroundColor &#x3D; UIColor.redColor; break; default: break; &#125; if (position &#x3D;&#x3D; RemindBarPositionStatusBar) &#123; [[LZRemindBar remind] setupShowStatusBarBottomWithStutus:true]; &#125; else &#123; [[LZRemindBar remind] setupShowNavigationBarBottomWithStutus:true]; &#125; return [LZRemindBar remind];&#125;- (void)setupShowStatusBarBottomWithStutus:(BOOL)show &#123; if (show) &#123; UIApplication.sharedApplication.delegate.window.windowLevel &#x3D; bar_IsPhoneX ? UIWindowLevelNormal : UIWindowLevelAlert; self.frame &#x3D; CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 0); [UIView animateWithDuration:0.5 animations:^&#123; self.frame &#x3D; CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 20); &#125;]; &#125; else &#123; [UIView animateWithDuration:0.5 animations:^&#123; self.frame &#x3D; CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; UIApplication.sharedApplication.delegate.window.windowLevel &#x3D; UIWindowLevelNormal; [self dismissBar]; &#125;]; &#125;&#125;- (void)setupShowNavigationBarBottomWithStutus:(BOOL)show &#123; if (show) &#123; self.frame &#x3D; CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 0); [UIView animateWithDuration:0.5 animations:^&#123; self.frame &#x3D; CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 20); &#125;]; &#125; else &#123; [UIView animateWithDuration:0.5 animations:^&#123; self.frame &#x3D; CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; [self dismissBar]; &#125;]; &#125;&#125;- (void)showBarAfterTimeInterval:(NSTimeInterval)interval &#123; [UIApplication.sharedApplication.delegate.window addSubview:self]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(interval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if (self.position &#x3D;&#x3D; RemindBarPositionStatusBar) &#123; [self setupShowStatusBarBottomWithStutus:false]; &#125; else &#123; [self setupShowNavigationBarBottomWithStutus:false]; &#125; &#125;);&#125;- (void)dismissBar &#123; self.isShowing &#x3D; false; [self.contentLabel removeFromSuperview]; [self removeFromSuperview];&#125;@end 使用方法123456789&#x2F;&#x2F; 参数RemindBarStyle： 显示样式&#x2F;&#x2F; 参数RemindBarPosition: 显示位置 &#x2F;&#x2F; 参数contentText: 显示文字内容 &#x2F;&#x2F; interval：显示时间&#x2F;&#x2F; Objc[[LZRemindBar configurationWithStyle:RemindBarStyleInfo showPosition:RemindBarPositionStatusBar contentText:@&quot;这是一个提示&quot;] showBarAfterTimeInterval:1.2];&#x2F;&#x2F; SwiftLZRemindBar.configuration(with: .info, show: .statusBar, contentText: &quot;提示文字&quot;).show(afterTimeInterval: 1.2) 效果图","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-开屏广告","slug":"iOS自定义控件-开屏广告","date":"2020-01-16T08:06:22.600Z","updated":"2020-01-20T02:20:51.987Z","comments":true,"path":"2020/01/16/iOS自定义控件-开屏广告/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A/","excerpt":"","text":"很久没有去写博客了，最近由于公司需求变化，需要做一个新的开屏广告的页面，所以我就简单的去研究了一下。其中显示分为视频和图片，其中图片相比而言实现起来就简单的多了。 图片加载可以使用第三方的加载和缓存，例如：SDWebImage或者Kingfisher。当然也可以使用系统的URLSession下载到本地再进行读取加载。 视频加载我这边利用的就URLSession的downloadTask进行下载到本地再进行播放的。 视频下载的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import UIKit&#x2F;&#x2F;&#x2F; 保存URL地址进行匹配fileprivate let kURL_DOWNLOAD_PATH &#x3D; &quot;WDDownloadUrlPath&quot;&#x2F;&#x2F;&#x2F; 保存路径fileprivate let kDOCUMENTS_PATH &#x3D; NSHomeDirectory() + &quot;&#x2F;Documents&#x2F;Advertisement.mp4&quot;fileprivate class UserDefaultsTools &#123; &#x2F;&#x2F; 设置地址 static func wd_set(value: String) &#123; UserDefaults.standard.setValue(value, forKey: kURL_DOWNLOAD_PATH) &#125; &#x2F;&#x2F; 读取地址 static func wd_get() -&gt; String &#123; return UserDefaults.standard.object(forKey: kURL_DOWNLOAD_PATH) as? String ?? &quot;&quot; &#125;&#125;fileprivate class FileManagerTools &#123; &#x2F;&#x2F; 是否存在文件 static func isExistFile(atPath: String) -&gt; Bool &#123; return FileManager.default.fileExists(atPath: atPath) &#125; &#x2F;&#x2F; 移动文件 static func moveFile(fromPath: String, toPath: String) &#123; try! FileManager.default.moveItem(atPath: fromPath, toPath: toPath) &#125; &#x2F;&#x2F; 删除文件 static func deleteFile(atPath: String) &#123; try! FileManager.default.removeItem(atPath: atPath) &#125; &#x2F;&#x2F; 文件大小 static func fileSize(atPath: String) -&gt; Float &#123; if self.isExistFile(atPath: kDOCUMENTS_PATH) &#123; let attributes &#x3D; try! FileManager.default.attributesOfItem(atPath: atPath) let size &#x3D; attributes[FileAttributeKey.size] as! Int return Float(size) &#125; return 0 &#125;&#125;class WDLaunchADDownloader: NSObject &#123; &#x2F;&#x2F;&#x2F; 下载视频的路径 private var downloadUrlPath: String &#x3D; &quot;&quot; &#x2F;&#x2F;&#x2F; 下载的Session private var session: URLSession! &#x2F;&#x2F;&#x2F; 下载的任务 private var downloadTask: URLSessionDownloadTask! &#x2F;&#x2F;&#x2F; 记录是否在下载 private var downloading: Bool &#x3D; false &#x2F;&#x2F;&#x2F; 记录已下载的数据 private var downloadData: Data? &#x2F;* 下载视频 *&#x2F; static func downloadVideo(path: String) -&gt; String &#123; let downloader &#x3D; WDLaunchADDownloader() return downloader.setupDownload(with: path) &#125; private func setupDownload(with path: String) -&gt; String &#123; downloadUrlPath &#x3D; path &#x2F;&#x2F; 获取视频播放网络路径 let configuration &#x3D; URLSessionConfiguration.default configuration.isDiscretionary &#x3D; true session &#x3D; URLSession(configuration: configuration, delegate: self, delegateQueue: nil) let request &#x3D; URLRequest.init(url: URL(string: path)!) downloadTask &#x3D; session.downloadTask(with: request) &#x2F;&#x2F; 网址不同，删除原本的，下载最新的 if UserDefaultsTools.wd_get() !&#x3D; path &#123; UserDefaultsTools.wd_set(value: &quot;&quot;) if FileManagerTools.isExistFile(atPath: kDOCUMENTS_PATH) &#123; FileManagerTools.deleteFile(atPath: kDOCUMENTS_PATH) &#125; &#x2F;&#x2F; 开始下载 startDownload() &#125; &#x2F;&#x2F; 如果已存在文件 就加载视频 否则加载图片 if FileManagerTools.isExistFile(atPath: kDOCUMENTS_PATH) &#123; return kDOCUMENTS_PATH &#125; else &#123; return &quot;&quot; &#125; &#125; &#x2F;&#x2F; MARK: - 开始下载 private func startDownload() &#123; downloading &#x3D; true downloadTask.resume() &#125; &#x2F;&#x2F; MARK: - 暂停下载 private func pauseDownload() &#123; downloadTask.cancel &#123; [weak self] (resumeData) in self?.downloadData &#x3D; resumeData &#125; downloading &#x3D; false &#125;&#125;extension WDLaunchADDownloader: URLSessionDownloadDelegate &#123; &#x2F;&#x2F; 下载代理方法，下载结束 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) &#123; let locationPath &#x3D; location.path FileManagerTools.moveFile(fromPath: locationPath, toPath: kDOCUMENTS_PATH) UserDefaultsTools.wd_set(value: downloadUrlPath) &#125; &#x2F;&#x2F; 下载代理方法，监听下载进度 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) &#123; if FileManagerTools.fileSize(atPath: kDOCUMENTS_PATH) &gt;&#x3D; Float(totalBytesExpectedToWrite) &#123; pauseDownload() return &#125; print(String(format: &quot;🍉 Advertising Video Download Progress: %0.2f&quot;, Float(totalBytesWritten) &#x2F; Float(totalBytesExpectedToWrite))) &#125; &#x2F;&#x2F; 如果下载失败了 func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) &#123; if error !&#x3D; nil &#123; UserDefaultsTools.wd_set(value: &quot;&quot;) &#125; &#125;&#125; 视频播放代码其中获取到加载的种类(图片、视频)，页面进行相应的布局 123456789101112131415161718192021222324252627import UIKitimport AVFoundationclass WDLaunchADPlayerManager: NSObject &#123; static let share &#x3D; WDLaunchADPlayerManager() var playerItem: AVPlayerItem! var player: AVPlayer! var playerLayer: CALayer! &#x2F;&#x2F; 开始播放 &lt;播放下载好再本地文件夹里面的视频文件&gt; func playItem(with url: String) &#123; playerItem &#x3D; AVPlayerItem(url: URL(fileURLWithPath: url)) player &#x3D; AVPlayer(playerItem: playerItem) playerLayer &#x3D; AVPlayerLayer(player: player) player.usesExternalPlaybackWhileExternalScreenIsActive &#x3D; true player.play() player.volume &#x3D; 0 &#x2F;&#x2F; 静音播放 &#125; &#x2F;&#x2F; 停止播放 func stopPlay() &#123; player.pause() player &#x3D; nil &#125;&#125; 页面显示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import UIKitimport SDWebImageclass WDLaunchADController: UIViewController &#123; &#x2F;&#x2F;&#x2F; 播放器的layer层 private var playerLayer: CALayer &#x3D; CALayer() &#x2F;&#x2F;&#x2F; 图片加载 private let imageView: UIImageView &#x3D; &#123; let imageV &#x3D; UIImageView() imageV.contentMode &#x3D; .scaleAspectFill imageV.clipsToBounds &#x3D; true return imageV &#125;() deinit &#123; print(&quot;&#x3D;&#x3D;[\\(type(of: self))] deinit&#x3D;&#x3D;&quot;) &#125; override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor &#x3D; .white &#125; &#x2F;&#x2F; 配置页面样式 func setup(with adType: WDLaunchADType, url: String, bottomLogoView: UIView? &#x3D; UIView(), bottomLogoViewHeight: CGFloat &#x3D; 180) &#123; if adType &#x3D;&#x3D; .image &#123; imageView.isUserInteractionEnabled &#x3D; true view.addSubview(imageView) imageView.sd_setImage(with: URL(string: url), completed: nil) &#125; else &#123; WDLaunchADPlayerManager.share.playItem(with: url) if let layer &#x3D; WDLaunchADPlayerManager.share.playerLayer &#123; self.view.layer.addSublayer(layer) playerLayer &#x3D; layer &#125; &#125; if let logoView &#x3D; bottomLogoView &#123; view.addSubview(logoView) logoView.frame &#x3D; CGRect(x: 0, y: view.frame.height - bottomLogoViewHeight, width: view.frame.width, height: bottomLogoViewHeight) if adType &#x3D;&#x3D; .image &#123; imageView.frame &#x3D; CGRect(x: 0, y: 0, width: view.frame.width, height: view.frame.height - bottomLogoViewHeight) &#125; else &#123; playerLayer.frame &#x3D; CGRect(x: 0, y: 0, width: view.frame.width, height: view.frame.height) &#125; &#125; else &#123; if adType &#x3D;&#x3D; .image &#123; imageView.frame &#x3D; view.bounds &#125; else &#123; playerLayer.frame &#x3D; view.bounds &#125; &#125; &#125; override var shouldAutorotate: Bool &#123; return false &#125; override var prefersHomeIndicatorAutoHidden: Bool &#123; return false &#125;&#125; 加载控制代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import UIKitenum WDLaunchADType &#123; case image case video&#125;&#x2F;&#x2F;&#x2F; 是否是刘海屏系列var kIS_IPHONEX: Bool &#123; var iPhoneX &#x3D; false if UIDevice.current.userInterfaceIdiom !&#x3D; .phone &#123; return iPhoneX &#125; if #available(iOS 11.0, *) &#123; if let mainWindow &#x3D; UIApplication.shared.delegate?.window &#123; if (mainWindow?.safeAreaInsets.bottom)! &gt; CGFloat(0.0) &#123; iPhoneX &#x3D; true &#125; &#125; &#125; return iPhoneX&#125;&#x2F;&#x2F;&#x2F; 状态栏高度var kSTATUS_HEIGHT: CGFloat &#123; return kIS_IPHONEX ? UIApplication.shared.statusBarFrame.height : 22&#125;&#x2F;&#x2F; MARK: - Mainclass WDLaunchAD: NSObject &#123; &#x2F;&#x2F; MARK: Public &#x2F;&#x2F;&#x2F; 静态方法 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Parameters: &#x2F;&#x2F;&#x2F; - adType: 广告类型 &#96;图片&#96; &#96;视频&lt;无声音&gt;&#96; &#x2F;&#x2F;&#x2F; - url: 广告地址 &#x2F;&#x2F;&#x2F; - durition: 显示时间 &#x2F;&#x2F;&#x2F; - bottomView: 底部视图 &#x2F;&#x2F;&#x2F; - buttomViewHeight: 底部视图高度 &#x2F;&#x2F;&#x2F; - clickBlock: 广告点击事件回调 static func setup(with adType: WDLaunchADType &#x3D; .image, url: String, durition: Int, bottomView: UIView? &#x3D; UIView(), buttomViewHeight: CGFloat &#x3D; 0, clickBlock: @escaping (() -&gt; Void)) &#123; let manager &#x3D; WDLaunchAD() manager.show(with: adType, url: url, durition: durition, bottomView: bottomView, buttomViewHeight: buttomViewHeight ,clickBlock: clickBlock) &#125; &#x2F;&#x2F; MARK: Private &#x2F;&#x2F;&#x2F; 页面显示的window根控制器，除了倒计时按钮，其他元素在控制器中配置 private let wdLaunchADViewController &#x3D; WDLaunchADController() &#x2F;&#x2F;&#x2F; 显示的时间 private var timerInterval: Int &#x3D; 0 &#x2F;&#x2F;&#x2F; 定时器 private var timer: Timer? &#x2F;&#x2F;&#x2F; 点击事件回调 private var clickBlockHandle: (() -&gt; Void)? &#x2F;&#x2F;&#x2F; 页面显示的window private let window: UIWindow &#x3D; &#123; let window &#x3D; UIWindow.init(frame: UIScreen.main.bounds) window.rootViewController?.view.backgroundColor &#x3D; .black window.rootViewController?.view.isUserInteractionEnabled &#x3D; false window.windowLevel &#x3D; UIWindow.Level.statusBar + 1 window.isHidden &#x3D; false window.alpha &#x3D; 1 return window &#125;() &#x2F;&#x2F;&#x2F; 倒计时按钮 private let timeButton: UIButton &#x3D; &#123; let button &#x3D; UIButton(type: .custom) button.backgroundColor &#x3D; UIColor(white: 0, alpha: 0.5) button.setTitleColor(.white, for: .normal) button.titleLabel?.font &#x3D; UIFont.systemFont(ofSize: 15) return button &#125;()&#125;&#x2F;&#x2F; MARK: - 页面初始化与销毁fileprivate extension WDLaunchAD &#123; &#x2F;&#x2F; 控制器初始化页面 func show(with adType: WDLaunchADType, url: String, durition: Int, bottomView: UIView?, buttomViewHeight: CGFloat, clickBlock: @escaping (() -&gt; Void)) &#123; clickBlockHandle &#x3D; clickBlock timerInterval &#x3D; durition window.rootViewController &#x3D; wdLaunchADViewController wdLaunchADViewController.view.addGestureRecognizer(UITapGestureRecognizer.init(target: self, action: #selector(adGuestureTargetAction))) wdLaunchADViewController.setup(with: adType, url: url, bottomLogoView: bottomView, bottomLogoViewHeight: buttomViewHeight) addTimeButton() &#x2F;&#x2F; 开始倒计时 DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; self.timer &#x3D; Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(self.timerDown(timer:)), userInfo: nil, repeats: true) if let timer &#x3D; self.timer &#123; timer.fire() &#125; &#125; &#125; &#x2F;&#x2F; 移除定时器与视图 func removeWindow() &#123; &#x2F;&#x2F; 停止播放视频 if WDLaunchADPlayerManager.share.player !&#x3D; nil &#123; WDLaunchADPlayerManager.share.stopPlay() &#125; &#x2F;&#x2F; 停止倒计时并移除 if let timer &#x3D; timer &#123; timer.invalidate() &#125; timer &#x3D; nil &#x2F;&#x2F; 移除当前视图 UIView.transition(with: window, duration: 0.8, options: UIView.AnimationOptions.curveEaseOut, animations: &#123; self.window.alpha &#x3D; 0; &#125;) &#123; (finished) in self.window.rootViewController &#x3D; nil self.window.removeFromSuperview() &#125; &#125;&#125;&#x2F;&#x2F; MARK: - 页面控件配置private extension WDLaunchAD &#123; &#x2F;&#x2F; 配置时间按钮 func addTimeButton() &#123; timeButton.setTitle(&quot; 跳过 \\(timerInterval) &quot;, for: .normal) timeButton.addTarget(self, action: #selector(buttonTargetAction(sender:)), for: .touchUpInside) window.addSubview(timeButton) timeButton.translatesAutoresizingMaskIntoConstraints &#x3D; false window.addConstraints([ NSLayoutConstraint(item: timeButton, attribute: .trailing, relatedBy: .equal, toItem: window, attribute: .trailing, multiplier: 1, constant: -15), NSLayoutConstraint(item: timeButton, attribute: .top, relatedBy: .equal, toItem: window, attribute: .top, multiplier: 1, constant: kSTATUS_HEIGHT), ]) timeButton.layoutIfNeeded() timeButton.layer.cornerRadius &#x3D; timeButton.frame.height &#x2F; 2.0 &#125;&#125;&#x2F;&#x2F; MARK: - 倒计时与倒计时点击事件@objc private extension WDLaunchAD &#123; &#x2F;&#x2F; 倒计时 func timerDown(timer: Timer) &#123; timerInterval -&#x3D; 1 timeButton.setTitle(&quot; 跳过 \\(timerInterval) &quot;, for: .normal) if timerInterval &#x3D;&#x3D; 0 &#123; removeWindow() &#125; &#125; &#x2F;&#x2F; 广告页移除 func buttonTargetAction(sender: UIButton) &#123; removeWindow() &#125; &#x2F;&#x2F; 点击手势 func adGuestureTargetAction() &#123; if clickBlockHandle !&#x3D; nil &#123; clickBlockHandle!() &#125; &#125;&#125; 加载方式在AppDelgate中的didFinishLaunchingWithOptions方法中调用方法。我这为了适应变化的需要，提供了相对自由的显示方式 底部的logo视图是可以自定义的，传入对应显示的高度即可。 图片地址 1let imagePath &#x3D; &quot;https:&#x2F;&#x2F;timgsa.baidu.com&#x2F;timg?image&amp;quality&#x3D;80&amp;size&#x3D;b9999_10000&amp;sec&#x3D;1567682065374&amp;di&#x3D;4c2a4d2008a4e951b34b3d130db19d12&amp;imgtype&#x3D;0&amp;src&#x3D;http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201704%2F14%2F20170414155109_Cmz24.jpeg&quot; 仅显示图片 123WDLaunchAD.setup(with: .image, url: imagePath, durition: 5, bottomView: WDLaunchADBottomLogoView(), buttomViewHeight: 180) &#123; print(&quot;✨ 点击了广告&quot;)&#125; 显示图片与底部logo视图底部视图代码 12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; MARK: - 底部logo视图class WDLaunchADBottomLogoView: UIView &#123; &#x2F;&#x2F; logo let logoImageView: UIImageView &#x3D; &#123; let imageV &#x3D; UIImageView() imageV.image &#x3D; UIImage(named: &quot;nav-logo-4c7bbafe27adc892f3046e6978459bac&quot;)?.withRenderingMode(.alwaysTemplate) imageV.tintColor &#x3D; .red return imageV &#125;() override init(frame: CGRect) &#123; super.init(frame: frame) setupSubviews() setupSubviewsLayouts() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125;&#x2F;&#x2F; MARK: 底部logo视图页面配置与布局extension WDLaunchADBottomLogoView &#123; func setupSubviews() &#123; backgroundColor &#x3D; .white addSubview(logoImageView) logoImageView.translatesAutoresizingMaskIntoConstraints &#x3D; false &#125; func setupSubviewsLayouts() &#123; addConstraints([ NSLayoutConstraint(item: logoImageView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1, constant: 0), NSLayoutConstraint(item: logoImageView, attribute: .centerY, relatedBy: .equal, toItem: self, attribute: .centerY, multiplier: 1, constant: 0) ]) &#125;&#125; 加载代码 123WDLaunchAD.setup(with: .image, url: imagePath, durition: 5, bottomView: WDLaunchADBottomLogoView(), buttomViewHeight: 180) &#123; print(&quot;✨ 点击了广告&quot;)&#125; 加载视频首先需要现在有网的环境缓存到本地，我这边的思想是，首次进入App默认加载图片，然后下载广告的视频到本地。再次进入的时候，判断是否是缓存的视频，是则进行播放。是否加载的URL与缓存的不同，则依旧加载图片，并下载最新URL下的视频。 12345678910let path &#x3D; WDLaunchADDownloader.downloadVideo(path: &quot;http:&#x2F;&#x2F;wvideo.spriteapp.cn&#x2F;video&#x2F;2018&#x2F;0514&#x2F;eede6198571f11e8b5ca842b2b4c75ab_wpd.mp4&quot;) if path.count &gt; 0 &#123; WDLaunchAD.setup(with: .video, url: path, durition: 5, bottomView: WDLaunchADBottomLogoView(), buttomViewHeight: 180) &#123; print(&quot;✨ 点击了广告&quot;) &#125; &#125; else &#123; WDLaunchAD.setup(with: .image, url: imagePath, durition: 5, bottomView: WDLaunchADBottomLogoView(), buttomViewHeight: 180) &#123; print(&quot;✨ 点击了广告&quot;) &#125; &#125; 效果图，没有找到合适大小的视频就凑合着用了。 说明: 页面消失的动画，没有做过多的处理 视频没有做循环播放","categories":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-分段选择器","slug":"iOS自定义控件-分段选择器","date":"2020-01-16T08:06:19.135Z","updated":"2020-01-20T02:21:38.326Z","comments":true,"path":"2020/01/16/iOS自定义控件-分段选择器/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E5%88%86%E6%AE%B5%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"废话不多说，直接上代码 1、数据源方法12345678910111213141516171819&#x2F;&#x2F; MARK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SegmentSelectorManagerDataSource &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;@objc protocol SegmentSelectorManagerDataSource:NSObjectProtocol &#123; &#x2F;&#x2F;&#x2F; 主要配置 -&gt; 必须要实现 func nameOfSliderItems(segemntControl:SegmentSelectorManager) -&gt; Array&lt;String&gt; func childViewControllers(segemntControl:SegmentSelectorManager) -&gt; Array&lt;UIViewController&gt; &#x2F;&#x2F;&#x2F; 字体颜色配置 -&gt; 有默认 @objc optional func colorOfSlider(segemntControl:SegmentSelectorManager) -&gt; UIColor @objc optional func colorOfTopView(segemntControl:SegmentSelectorManager) -&gt; UIColor &#x2F;&#x2F;&#x2F; 背景颜色配置 -&gt; 有默认 @objc optional func colorOfSliderItemsTitle(segemntControl:SegmentSelectorManager) -&gt; UIColor @objc optional func colorOfHighlightedSliderItemsTitle(segemntControl:SegmentSelectorManager) -&gt; UIColor &#x2F;&#x2F;&#x2F; 高度配置 -&gt; 有默认 @objc optional func heightOfTopView(segemntControl:SegmentSelectorManager) -&gt; CGFloat @objc optional func heightOfSlider(segemntControl:SegmentSelectorManager) -&gt; CGFloat&#125; 2、代理方法1234&#x2F;&#x2F; MARK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SegmentSelectorManagerDelegate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;protocol SegmentSelectorManagerDelegate &#123; func slideView(sliderView:SegmentSelectorManager, didSelectItemAtIndex:Int) -&gt; Void&#125; 3、页面实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596override init(frame: CGRect) &#123; super.init(frame: frame) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; &#x2F;&#x2F;&#x2F; 数据源 public weak var dataSource:SegmentSelectorManagerDataSource? &#123; didSet &#123; &#x2F;&#x2F; 名称数组 namesOfSlideItems &#x3D; dataSource?.nameOfSliderItems(segemntControl: self) &#x2F;&#x2F; 控制器数组 childControllersArray &#x3D; dataSource?.childViewControllers(segemntControl: self) if let ds &#x3D; dataSource &#123; if (ds.responds(to: #selector(ds.colorOfHighlightedSliderItemsTitle(segemntControl:)))) &#123; &#x2F;&#x2F;按钮字体颜色默认 colorOfSlideItemsTitle &#x3D; ds.colorOfSliderItemsTitle!(segemntControl: self) &#125; if (ds.responds(to: #selector(ds.colorOfHighlightedSliderItemsTitle(segemntControl:)))) &#123; &#x2F;&#x2F; 按钮字体颜色选中 colorOfHighlightedSlideItemsTitle &#x3D; ds.colorOfHighlightedSliderItemsTitle!(segemntControl: self) &#125; if (ds.responds(to: #selector(ds.colorOfSlider(segemntControl:)))) &#123; &#x2F;&#x2F; 指示器颜色 colorOfSlider &#x3D; ds.colorOfSlider!(segemntControl: self) &#125; if ds.responds(to: #selector(ds.heightOfTopView(segemntControl:))) &#123; &#x2F;&#x2F; 顶部视图高度 heightOfTopView &#x3D; (ds.heightOfTopView!(segemntControl: self)) &#125; if ds.responds(to: #selector(ds.heightOfTopView(segemntControl:))) &#123; &#x2F;&#x2F; 指示器高度 heightOfSlider &#x3D; (ds.heightOfSlider!(segemntControl: self)) &#125; &#125; &#125; &#125; &#x2F;&#x2F; 代理 public var delegate:SegmentSelectorManagerDelegate? var namesOfSlideItems: Array&lt;String&gt;? &#x3D; [] &#x2F;&#x2F; 名称数组 var colorOfSlider: UIColor? &#x3D; UIColor.orange &#x2F;&#x2F; 指示器颜色 var colorOfSlideView: UIColor? &#x3D; UIColor.white &#x2F;&#x2F; 顶部视图颜色 var colorOfSlideItemsTitle: UIColor? &#x3D; UIColor.gray &#x2F;&#x2F; 默认字体颜色 var colorOfHighlightedSlideItemsTitle: UIColor? &#x3D; UIColor.orange &#x2F;&#x2F; 选中字体颜色 var heightOfTopView:CGFloat &#x3D; 45 &#x2F;&#x2F; 顶部视图高度 var heightOfSlider:CGFloat &#x3D; 2 &#x2F;&#x2F; 指示器高度 let SliderThanSliderView_WidthRatio:CGFloat &#x3D; 1 &#x2F;&#x2F; 按钮和指示器宽度比 var buttonsArray:Array&lt;UIButton&gt;? &#x3D; [] &#x2F;&#x2F; 所有按钮的数组 var childControllersArray:Array&lt;UIViewController&gt;? &#x3D; [] &#x2F;&#x2F; 控制器数组 let SCREEN_WIDTH &#x3D; UIScreen.main.bounds.size.width let SCREEN_HEIGHT &#x3D; UIScreen.main.bounds.height &#x2F;&#x2F;&#x2F; 顶部View lazy var slideBar:UIView &#x3D; &#123; let view &#x3D; UIView.init() view.backgroundColor &#x3D; colorOfSlideView addSubview(view) view.translatesAutoresizingMaskIntoConstraints &#x3D; false view.leadingAnchor.constraint(equalTo: leadingAnchor).isActive &#x3D; true view.trailingAnchor.constraint(equalTo: trailingAnchor).isActive &#x3D; true view.topAnchor.constraint(equalTo: topAnchor).isActive &#x3D; true view.heightAnchor.constraint(equalToConstant: self.heightOfTopView).isActive &#x3D; true return view &#125;() &#x2F;&#x2F; 底部指示器 var slider:UIView? &#x2F;&#x2F;&#x2F; 控制器ScrollView lazy var contentScrollView:UIScrollView &#x3D; &#123; let sc &#x3D; UIScrollView.init() sc.isDirectionalLockEnabled &#x3D; true sc.backgroundColor &#x3D; UIColor.white sc.isPagingEnabled &#x3D; true sc.showsHorizontalScrollIndicator &#x3D; false sc.delegate &#x3D; self sc.bounces &#x3D; false addSubview(sc) sc.translatesAutoresizingMaskIntoConstraints &#x3D; false sc.leadingAnchor.constraint(equalTo: leadingAnchor).isActive &#x3D; true sc.trailingAnchor.constraint(equalTo: trailingAnchor).isActive &#x3D; true sc.topAnchor.constraint(equalTo: self.slideBar.bottomAnchor).isActive &#x3D; true sc.bottomAnchor.constraint(equalTo: bottomAnchor).isActive &#x3D; true return sc &#125;() #####4、绘制页面UI 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 &#x2F;&#x2F; 获取当前页面的控制器 public func viewController()-&gt;UIViewController? &#123; var nextResponder: UIResponder? &#x3D; self repeat &#123; nextResponder &#x3D; nextResponder?.next if let viewController &#x3D; nextResponder as? UIViewController &#123; return viewController &#125; &#125; while nextResponder !&#x3D; nil return nil &#125;override func layoutSubviews() &#123; super.layoutSubviews() addSlider() addButton() addContentScrollView() &#125;&#x2F;&#x2F;&#x2F; 添加按钮到顶部视图 func addButton() &#123; let numberOfItems:Int &#x3D; (namesOfSlideItems?.count)! let slideItemWidth &#x3D; SCREEN_WIDTH &#x2F; CGFloat(numberOfItems) let sliderWidth &#x3D; slideItemWidth * SliderThanSliderView_WidthRatio let position_x &#x3D; (slideItemWidth - sliderWidth) &#x2F; 2.0 for index in 0..&lt;numberOfItems &#123; let b &#x3D; UIButton.init(type: .custom) b.tag &#x3D; index b.setTitle(namesOfSlideItems![index], for: .normal) b.setTitleColor(colorOfSlideItemsTitle, for: .normal) b.titleLabel?.textAlignment &#x3D; .center b.addTarget(self, action: #selector(buttonTouched(button:)), for: .touchUpInside) buttonsArray?.append(b) b.frame &#x3D; CGRect(x: position_x + slideItemWidth * CGFloat(index), y: 5, width: sliderWidth, height: heightOfTopView-5) slideBar.addSubview(b) if index &#x3D;&#x3D; 0 &#123; b.setTitleColor(colorOfHighlightedSlideItemsTitle!, for: .normal) &#125; &#125; &#125; &#x2F;&#x2F; 添加底部指示器到顶部视图 func addSlider() &#123; let slideItemWidth &#x3D; SCREEN_WIDTH &#x2F; CGFloat((namesOfSlideItems?.count)!) let sliderWidth &#x3D; slideItemWidth * SliderThanSliderView_WidthRatio let position_x &#x3D; (slideItemWidth - sliderWidth) &#x2F; 2.0 slideBar.addSubview(sliderView(frame: CGRect(x: position_x, y: heightOfTopView - heightOfSlider, width: sliderWidth, height: heightOfSlider))) slideBar.backgroundColor &#x3D; colorOfSlideView slider?.backgroundColor &#x3D; colorOfSlider &#125; &#x2F;&#x2F; 添加ScrollView func addContentScrollView() &#123; contentScrollView.contentSize &#x3D; CGSize(width: SCREEN_WIDTH * CGFloat((namesOfSlideItems?.count)!), height: 0) for (index) in (childControllersArray?.enumerated())! &#123; index.element.view.frame &#x3D; CGRect(x: CGFloat(index.offset) * SCREEN_WIDTH, y: 0, width: contentScrollView.frame.width, height: contentScrollView.frame.height) contentScrollView.addSubview(index.element.view) viewController()?.addChild(index.element) index.element.didMove(toParent: viewController()) &#125; &#125; &#x2F;&#x2F; vc滚动动画 func animateSlider(tag:Int) -&gt; Void &#123; contentScrollView.setContentOffset(CGPoint(x: SCREEN_WIDTH * CGFloat(tag), y: 0), animated: true) &#125; &#x2F;&#x2F; 指示器滚动动画 func animateSliderToPosition(offset:CGPoint) -&gt; Void &#123; let slideItemWidth &#x3D; SCREEN_WIDTH &#x2F; CGFloat((namesOfSlideItems?.count)!) let sliderWidth &#x3D; slideItemWidth * SliderThanSliderView_WidthRatio let position_x &#x3D; (slideItemWidth - sliderWidth) &#x2F; 2.0 let newFrame &#x3D; CGRect(x: (offset.x &#x2F; SCREEN_WIDTH) * slideItemWidth + position_x, y: (slider?.frame.origin.y)!, width: (slider?.frame.width)!, height: (slider?.frame.height)!) slider?.frame &#x3D; newFrame for (index) in (buttonsArray?.enumerated())! &#123; index.element.setTitleColor(colorOfSlideItemsTitle, for: .normal) &#125; var buttonTag &#x3D; 0 let ratio &#x3D; offset.x &#x2F; SCREEN_WIDTH let tempRation &#x3D; Int(ratio) let decimal:CGFloat &#x3D; ratio - CGFloat(tempRation) if decimal &gt;&#x3D; 0.5 &#123; buttonTag &#x3D; Int(ratio) + 1 &#125; else &#123; buttonTag &#x3D; Int(ratio) &#125; buttonsArray![buttonTag].setTitleColor(colorOfHighlightedSlideItemsTitle, for: .normal) &#125; &#x2F;&#x2F;&#x2F; 根据frame初始化指示器 func sliderView(frame:CGRect) -&gt; UIView &#123; slider &#x3D; UIView.init(frame: frame) return slider! &#125; &#x2F;&#x2F;&#x2F; 点击事件 @objc func buttonTouched(button:UIButton) &#123; delegate?.slideView(sliderView: self, didSelectItemAtIndex: button.tag) animateSlider(tag: tag) contentScrollView.setContentOffset(CGPoint(x: SCREEN_WIDTH * CGFloat(button.tag), y: 0), animated: true) &#125; 5、使用Extension实现UIScrollViewDidScrollDelegate123456&#x2F;&#x2F; MARK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; UIScrollViewDidScrollDelegate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extension SegmentSelectorManager:UIScrollViewDelegate &#123; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; animateSliderToPosition(offset: scrollView.contentOffset) &#125;&#125; 6、使用方法(实例代码)12345678910111213141516override func setupSubViewsProperties() &#123; segmentView &#x3D; SegmentSelectorManager.init(frame: CGRect.zero) segmentView?.delegate &#x3D; self segmentView?.dataSource &#x3D; self view.addSubview(segmentView!) &#125; override func setupSubViewsConstrains() &#123; if let seg &#x3D; segmentView &#123; seg.translatesAutoresizingMaskIntoConstraints &#x3D; false seg.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive &#x3D; true seg.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive &#x3D; true seg.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -kTabBarHeight).isActive &#x3D; true seg.topAnchor.constraint(equalTo: wd_navgationBar_normal.bottomAnchor).isActive &#x3D; true &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940extension HotPlayController: SegmentSelectorManagerDataSource &#123; func nameOfSliderItems(segemntControl: SegmentSelectorManager) -&gt; Array&lt;String&gt; &#123; return [&quot;正在热映&quot;, &quot;即将上映&quot;] &#125; func childViewControllers(segemntControl: SegmentSelectorManager) -&gt; Array&lt;UIViewController&gt; &#123; return [HotPlayingController(), HotWillPlayViewController()] &#125; func heightOfTopView(segemntControl: SegmentSelectorManager) -&gt; CGFloat &#123; return 45 &#125; func heightOfSlider(segemntControl: SegmentSelectorManager) -&gt; CGFloat &#123; return 3 &#125; func colorOfSlider(segemntControl slider: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.wd_init(r: 73, g: 73, b: 73) &#125; func colorOfTopView(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.white &#125; func colorOfSliderItemsTitle(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.gray &#125; func colorOfHighlightedSliderItemsTitle(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.wd_init(r: 73, g: 73, b: 73) &#125;&#125;extension HotPlayController: SegmentSelectorManagerDelegate &#123; func slideView(sliderView: SegmentSelectorManager, didSelectItemAtIndex: Int) &#123; &#125;&#125; 7、效果图","categories":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-仿QQ侧边菜单","slug":"iOS自定义控件-仿QQ侧边菜单","date":"2020-01-16T08:06:15.186Z","updated":"2020-01-20T02:22:03.730Z","comments":true,"path":"2020/01/16/iOS自定义控件-仿QQ侧边菜单/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E4%BB%BFQQ%E4%BE%A7%E8%BE%B9%E8%8F%9C%E5%8D%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface LZSliderContainerViewController : UIViewController&#x2F;&#x2F; 是否允许侧滑手势@property (nonatomic, assign) BOOL allowOpenSliderView;&#x2F;&#x2F; 单例+ (instancetype)mamager;&#x2F;** 初始化方法 @param mainController 主页面控制器 @param sliderController 菜单页面控制器 @param space 空隙 @return UIViewController *&#x2F;- (UIViewController *)lz_setupMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController space:(CGFloat)space;&#x2F;** 打开侧边菜单 *&#x2F;- (void)lz_openSlderView;&#x2F;** 关闭侧边菜单 *&#x2F;- (void)lz_closeSliderView;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#import &quot;LZSliderContainerViewController.h&quot;@interface UIView (Frame)@property (nonatomic) CGFloat left;@property (nonatomic) CGFloat right;@end@implementation UIView (Frame)- (CGFloat)left &#123; return self.frame.origin.x;&#125;- (void)setLeft:(CGFloat)x &#123; CGRect frame &#x3D; self.frame; frame.origin.x &#x3D; x; self.frame &#x3D; frame;&#125;- (CGFloat)right &#123; return self.frame.origin.x + self.frame.size.width;&#125;- (void)setRight:(CGFloat)right &#123; CGRect frame &#x3D; self.frame; frame.origin.x &#x3D; right - frame.size.width; self.frame &#x3D; frame;&#125;@end@interface LZSliderContainerViewController ()@property (nonatomic, strong) UIViewController *mainController;@property (nonatomic, strong) UIViewController *sliderController;@property (nonatomic, assign) CGFloat spece;@property (nonatomic, assign) CGFloat panStartX;@property (nonatomic, strong) UIView *coverView;@end@implementation LZSliderContainerViewController#pragma mark - 单例方法+ (instancetype)mamager &#123; static dispatch_once_t onceToken; static LZSliderContainerViewController *vc; dispatch_once(&amp;onceToken, ^&#123; vc &#x3D; [[LZSliderContainerViewController alloc] init]; &#125;); return vc;&#125;#pragma mark - 初始化方法- (UIViewController *)lz_setupMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController space:(CGFloat)space &#123; [self lz_addChildControllerWithMainController:mainController sliderController:sliderController]; [self lz_setupCoverView]; _spece &#x3D; space; return self;&#125;#pragma mark - 配置遮罩层- (void)lz_setupCoverView &#123; self.coverView &#x3D; [[UIView alloc] init]; self.coverView.frame &#x3D; UIScreen.mainScreen.bounds; self.coverView.backgroundColor &#x3D; [[UIColor blackColor] colorWithAlphaComponent:0]; self.coverView.hidden &#x3D; true; [self.coverView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(lz_closeSliderView)]]; [self.view addSubview:self.coverView];&#125;#pragma mark - 添加VC- (void)lz_addChildControllerWithMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController &#123; [self addChildViewController:mainController]; [mainController didMoveToParentViewController:self]; mainController.view.frame &#x3D; UIScreen.mainScreen.bounds; [self.view addSubview:mainController.view]; [self addChildViewController:sliderController]; [sliderController didMoveToParentViewController:self]; sliderController.view.frame &#x3D; CGRectMake(-UIScreen.mainScreen.bounds.size.width, 0, UIScreen.mainScreen.bounds.size.width, UIScreen.mainScreen.bounds.size.height); [self.view addSubview:sliderController.view]; self.mainController &#x3D; mainController; self.sliderController &#x3D; sliderController; [self lz_setupGusture];&#125;#pragma mark - 添加平移手势- (void)lz_setupGusture &#123; UIPanGestureRecognizer *panGusture &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(lz_panGestureRecognizer:)]; [self.view addGestureRecognizer:panGusture];&#125;#pragma mark - UIPanGestureRecognizer Action- (void)lz_panGestureRecognizer:(UIPanGestureRecognizer *)sender &#123; UIView *rootView &#x3D; self.mainController.view; UIView *menuView &#x3D; self.sliderController.view; if (sender.state &#x3D;&#x3D; UIGestureRecognizerStateBegan) &#123; CGFloat startPointX &#x3D; [sender translationInView:self.view].x; self.panStartX &#x3D; startPointX; self.coverView.hidden &#x3D; false; &#125; if (self.panStartX &gt;&#x3D; 40 &amp;&amp; rootView.frame.origin.x &#x3D;&#x3D; 0) &#123; return; &#125; CGFloat translationX &#x3D; [sender translationInView:rootView].x; CGFloat rootViewX &#x3D; rootView.frame.origin.x; rootViewX &#x3D; [self lz_minmumWithValueA:(rootViewX + translationX) valueB:(UIScreen.mainScreen.bounds.size.width - self.spece)]; rootViewX &#x3D; [self lz_maxmumWithValueA:rootViewX valueB:0]; rootView.left &#x3D; rootViewX; menuView.right &#x3D; rootView.left; self.coverView.frame &#x3D; rootView.frame; CGFloat aphal &#x3D; 0.5 * rootView.frame.origin.x &#x2F; (UIScreen.mainScreen.bounds.size.width - self.spece); self.coverView.backgroundColor &#x3D; [[UIColor blackColor] colorWithAlphaComponent:aphal]; [sender setTranslation:CGPointZero inView:rootView]; if (sender.state &#x3D;&#x3D; UIGestureRecognizerStateEnded || sender.state &#x3D;&#x3D; UIGestureRecognizerStateCancelled) &#123; if (rootViewX &gt;&#x3D; (UIScreen.mainScreen.bounds.size.width - self.spece)&#x2F;2) &#123; [self lz_openSlderView]; &#125; else&#123; [self lz_closeSliderView]; &#125; &#125;&#125;#pragma mark - 打开侧边菜单- (void)lz_openSlderView &#123; [self lz_setupGusture]; UIView *rootView &#x3D; self.mainController.view; UIView *menuView &#x3D; self.sliderController.view; self.coverView.hidden &#x3D; false; [UIView animateWithDuration:0.4 animations:^&#123; rootView.left &#x3D; UIScreen.mainScreen.bounds.size.width - self.spece; menuView.right &#x3D; rootView.left; self.coverView.frame &#x3D; rootView.frame; self.coverView.backgroundColor &#x3D; [[UIColor blackColor] colorWithAlphaComponent:0.5]; &#125;];&#125;#pragma mark - 关闭侧边菜单- (void)lz_closeSliderView &#123; UIView *rootView &#x3D; self.mainController.view; UIView *menuView &#x3D; self.sliderController.view; [UIView animateWithDuration:0.4 animations:^&#123; self.coverView.backgroundColor &#x3D; [[UIColor blackColor] colorWithAlphaComponent:0]; rootView.left &#x3D; 0; menuView.right &#x3D; rootView.left; self.coverView.frame &#x3D; rootView.frame; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; self.coverView.hidden &#x3D; true; &#125; &#125;];&#125;#pragma mark - 比较大小取最小值- (CGFloat)lz_minmumWithValueA:(CGFloat)a valueB:(CGFloat)b &#123; return a &gt; b ? b : a;&#125;#pragma mark - 比较大小取最大值- (CGFloat)lz_maxmumWithValueA:(CGFloat)a valueB:(CGFloat)b &#123; return a &gt; b ? a : b;&#125;#pragma mark - Setter- (void)setAllowOpenSliderView:(BOOL)allowOpenSliderView &#123; _allowOpenSliderView &#x3D; allowOpenSliderView; if (allowOpenSliderView) &#123; [self lz_setupGusture]; &#125; else &#123; for (UIGestureRecognizer *pan in self.view.gestureRecognizers) &#123; [self.view removeGestureRecognizer:pan]; &#125; &#125;&#125;@end AppDelegate中设置为根控制器 1self.window.rootViewController &#x3D; [[LZSliderContainerViewController mamager] lz_setupMainController:tab sliderController:sldier space:200]; // 单独打开或关闭 1234&#x2F;&#x2F; 打开页面[[LZSliderContainerViewController mamager] lz_openSlderView];&#x2F;&#x2F; 关闭页面[[LZSliderContainerViewController mamager] lz_closeSliderView]; 默认所有页面都是打开的，如果需要关闭 123456789- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [LZSliderContainerViewController mamager].allowOpenSliderView &#x3D; NO;&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; [LZSliderContainerViewController mamager].allowOpenSliderView &#x3D; true;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-TableView、CollectionView空数据占位图","slug":"iOS自定义控件-TableView、CollectionView空数据占位图","date":"2020-01-16T08:06:11.294Z","updated":"2020-01-20T01:44:54.956Z","comments":true,"path":"2020/01/16/iOS自定义控件-TableView、CollectionView空数据占位图/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-TableView%E3%80%81CollectionView%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%8D%A0%E4%BD%8D%E5%9B%BE/","excerpt":"","text":"最近由于业务需求，需要封装这样的一个提示页面。看了网上方法感觉都大同小异，其中DZNEmptyDataSet是很好的一个库，但是对我个人而言有点大财小用了。所以就借鉴一下其方法，自己封装一个。感觉有更高的自定义性吧。（我是初学者，请大佬爱护，勿喷）一、封装代码：利用UIScrollView的分类实现 1234567891011#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface UIScrollView (WD_NoData)&#x2F;&#x2F; 需要显示的占位页面@property (nonatomic, strong) UIView *noDataView;@endNS_ASSUME_NONNULL_END 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import &quot;UIScrollView+WD_NoData.h&quot;#import &lt;objc&#x2F;runtime.h&gt;static char *noDataViewKey &#x3D; &quot;noDataViewKey&quot;;@implementation UIScrollView (WD_NoData)&#x2F;** 交换方法 @param sel1 原方法 @param sel2 自定义方法 @param cls 类 *&#x2F;void exchangeSelector(SEL sel1, SEL sel2, Class cls) &#123; Class class &#x3D; [cls class]; Method originalMethod &#x3D; class_getInstanceMethod(class, sel1); Method swizzledMethod &#x3D; class_getInstanceMethod(class, sel2); BOOL success &#x3D; class_addMethod(class, sel1, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, sel2, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Setter &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)setNoDataView:(UIView *)noDataView &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; exchangeSelector(@selector(reloadData), @selector(wd_reloadData), [self class]); &#125;); objc_setAssociatedObject(self, noDataViewKey, noDataView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Getter &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (UIView *)noDataView &#123; UIView *noDataView &#x3D; objc_getAssociatedObject(self, noDataViewKey); noDataView.frame &#x3D; self.frame; return noDataView;&#125;- (void)wd_reloadData &#123; [self wd_reloadData]; [self wd_checkData];&#125;#pragma mark &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 获取数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;- (void)wd_checkData &#123; NSInteger items &#x3D; 0; if (![self respondsToSelector:@selector(dataSource)]) &#123; return; &#125; &#x2F;&#x2F; UITableView support if ([self isKindOfClass:[UITableView class]]) &#123; UITableView *tableView &#x3D; (UITableView *)self; id &lt;UITableViewDataSource&gt; dataSource &#x3D; tableView.dataSource; NSInteger sections &#x3D; 1; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) &#123; sections &#x3D; [dataSource numberOfSectionsInTableView:tableView]; &#125; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(tableView:numberOfRowsInSection:)]) &#123; for (NSInteger section &#x3D; 0; section &lt; sections; section++) &#123; items +&#x3D; [dataSource tableView:tableView numberOfRowsInSection:section]; &#125; &#125; &#125; &#x2F;&#x2F; UICollectionView support else if ([self isKindOfClass:[UICollectionView class]]) &#123; UICollectionView *collectionView &#x3D; (UICollectionView *)self; id &lt;UICollectionViewDataSource&gt; dataSource &#x3D; collectionView.dataSource; NSInteger sections &#x3D; 1; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(numberOfSectionsInCollectionView:)]) &#123; sections &#x3D; [dataSource numberOfSectionsInCollectionView:collectionView]; &#125; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(collectionView:numberOfItemsInSection:)]) &#123; for (NSInteger section &#x3D; 0; section &lt; sections; section++) &#123; items +&#x3D; [dataSource collectionView:collectionView numberOfItemsInSection:section]; &#125; &#125; &#125; if ( items &#x3D;&#x3D; 0 ) &#123; [self.superview addSubview:self.noDataView]; &#125; else &#123; [self.noDataView removeFromSuperview]; &#125;&#125;@end 二、使用方法 123#import &quot;UIScrollView+WD_NoData.h&quot;&#x2F;&#x2F; 自定义页面#import &quot;WDTestEmptyView.h&quot; 1234&#x2F;&#x2F;示例的视图 WDTestEmptyView *view &#x3D; [NSBundle.mainBundle loadNibNamed:@&quot;WDTestEmptyView&quot; owner:self options:nil].firstObject;&#x2F;&#x2F; 设置视图self.tableView.noDataView &#x3D; view; 三、效果图","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS自定义控件-PopMenu","slug":"iOS自定义控件-PopMenu","date":"2020-01-16T08:06:05.203Z","updated":"2020-01-20T02:06:59.932Z","comments":true,"path":"2020/01/16/iOS自定义控件-PopMenu/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-PopMenu/","excerpt":"","text":"现在很多的应用都有类似的弹窗控件，最出名应该是企鹅和微信了吧。想着为了满足自己的效果就动手写了这个。首先要感谢写出弹窗箭头的代码的人iHandle，这方面的知识我很欠缺，以后找机会恶补一下。先上两张出名的效果图： 样式定义主要以UITableView作为容器显示样式 背景颜色 文字样式：颜色，字体大小，对齐方式 显示类型：仅文字，仅图标，文字 + 图标 是否显示下划线 箭头方向 弹窗宽度 单元格的高度 箭头生成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152typedef NS_ENUM(NSInteger, ArrowDirection) &#123; ArrowDirectionRight &#x3D; 0, ArrowDirectionBottom, ArrowDirectionLeft, ArrowDirectionTop,&#125;;#define CORNER_RADIUS 8 &#x2F;&#x2F; 默认矩形框圆角半径#define ARROW_WIDTH 30 &#x2F;&#x2F; 默认箭头宽带#define ARROW_HEIGHT 12 &#x2F;&#x2F; 默认箭头高度#define ARROW_DIRECTION 1 &#x2F;&#x2F; 默认箭头方向，向下#define ARROW_POSITION 0.5 &#x2F;&#x2F; 默认箭头相对位置，居中#define ARROW_RADIUS 3 &#x2F;&#x2F; 默认箭头指向处的圆角半径@interface WudanLayer : NSObject@property (nonatomic, assign) CGFloat cornerRadius;@property (nonatomic, assign) CGFloat arrowRadius;@property (nonatomic, assign) CGFloat arrowHeight;@property (nonatomic, assign) CGFloat arrowWidth;@property (nonatomic, assign) ArrowDirection arrowDirection;@property (nonatomic, assign) CGFloat arrowPosition;@property (nonatomic, assign) CGSize size;- (instancetype)initWithSize:(CGSize)size;- (CAShapeLayer *)layer;@end@implementation WudanLayer#pragma mark - preparation- (NSMutableArray *)keyPoints &#123; NSMutableArray *points &#x3D; [NSMutableArray array]; CGPoint beginPoint; CGPoint topPoint; CGPoint endPoint; CGFloat validWidthForTopPoint &#x3D; _size.width - 2 * _cornerRadius - _arrowWidth; CGFloat validHeightForTopPoint &#x3D; _size.height - 2 * _cornerRadius - _arrowWidth; CGFloat x &#x3D; 0, y &#x3D; 0; CGFloat width &#x3D; _size.width, height &#x3D; _size.height; switch (_arrowDirection) &#123; case ArrowDirectionRight: &#123; width -&#x3D; _arrowHeight; topPoint &#x3D; CGPointMake(_size.width , _size.height &#x2F; 2 + validHeightForTopPoint*(_arrowPosition - 0.5)); beginPoint &#x3D; CGPointMake(topPoint.x - _arrowHeight, topPoint.y - _arrowWidth&#x2F;2); endPoint &#x3D; CGPointMake(beginPoint.x, beginPoint.y + _arrowWidth); &#125; break; case ArrowDirectionBottom: &#123; height -&#x3D; _arrowHeight; topPoint &#x3D; CGPointMake(_size.width &#x2F; 2 + validWidthForTopPoint*(_arrowPosition - 0.5), _size.height); beginPoint &#x3D; CGPointMake(topPoint.x + _arrowWidth&#x2F;2, topPoint.y - _arrowHeight); endPoint &#x3D; CGPointMake(beginPoint.x - _arrowWidth, beginPoint.y); &#125; break; case ArrowDirectionLeft: &#123; x &#x3D; _arrowHeight; width -&#x3D; _arrowHeight; topPoint &#x3D; CGPointMake(0, _size.height &#x2F; 2 + validHeightForTopPoint*(_arrowPosition - 0.5)); beginPoint &#x3D; CGPointMake(topPoint.x + _arrowHeight, topPoint.y + _arrowWidth&#x2F;2); endPoint &#x3D; CGPointMake(beginPoint.x, beginPoint.y - _arrowWidth); &#125; break; case ArrowDirectionTop: &#123; y &#x3D; _arrowHeight; height -&#x3D; _arrowHeight; topPoint &#x3D; CGPointMake(_size.width &#x2F; 2 + validWidthForTopPoint*(_arrowPosition - 0.5), 0); beginPoint &#x3D; CGPointMake(topPoint.x - _arrowWidth&#x2F;2, topPoint.y + _arrowHeight); endPoint &#x3D; CGPointMake(beginPoint.x + _arrowWidth, beginPoint.y); &#125; break; &#125; points &#x3D; [NSMutableArray arrayWithObjects: [NSValue valueWithCGPoint:beginPoint], [NSValue valueWithCGPoint:topPoint], [NSValue valueWithCGPoint:endPoint], nil]; CGPoint bottomRight &#x3D; CGPointMake(x + width, y + height); CGPoint bottomLeft &#x3D; CGPointMake(x, y + height); CGPoint topLeft &#x3D; CGPointMake(x, y); CGPoint topRight &#x3D; CGPointMake(x + width, y); NSMutableArray *rectPoints &#x3D; [NSMutableArray arrayWithObjects: [NSValue valueWithCGPoint:bottomRight], [NSValue valueWithCGPoint:bottomLeft], [NSValue valueWithCGPoint:topLeft], [NSValue valueWithCGPoint:topRight], nil]; int rectPointIndex &#x3D; (int)_arrowDirection; for(int i &#x3D; 0; i &lt; 4; ++i) &#123; [points addObject:[rectPoints objectAtIndex:rectPointIndex]]; rectPointIndex &#x3D; (rectPointIndex + 1) % 4; &#125; return points;&#125;#pragma mark - Draw bubblePath- (CGPathRef)bubblePath &#123; UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0); CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext(); NSMutableArray *points &#x3D; [self keyPoints]; CGPoint currentPoint &#x3D; [[points objectAtIndex:6] CGPointValue]; CGContextMoveToPoint(ctx, currentPoint.x, currentPoint.y); CGPoint pointA, pointB; CGFloat radius; int i &#x3D; 0; while(1) &#123; if (i &gt; 6) break; radius &#x3D; i &lt; 3 ? _arrowRadius : _cornerRadius; pointA &#x3D; [[points objectAtIndex:i] CGPointValue]; pointB &#x3D; [[points objectAtIndex:(i + 1) % 7] CGPointValue]; CGContextAddArcToPoint(ctx, pointA.x, pointA.y, pointB.x, pointB.y, radius); i &#x3D; i + 1; &#125; CGContextClosePath(ctx); CGPathRef path &#x3D; CGContextCopyPath(ctx); CGContextRelease(ctx); return path;&#125;- (CAShapeLayer *)layer&#123; CAShapeLayer *layer &#x3D; [CAShapeLayer layer]; layer.path &#x3D; [self bubblePath]; return layer;&#125;#pragma mark - Setup- (void)setDefaultProperty &#123; _cornerRadius &#x3D; CORNER_RADIUS; _arrowWidth &#x3D; ARROW_WIDTH; _arrowHeight &#x3D; ARROW_HEIGHT; _arrowDirection &#x3D; ARROW_DIRECTION; _arrowPosition &#x3D; ARROW_POSITION; _arrowRadius &#x3D; ARROW_RADIUS;&#125;#pragma mark - Init- (instancetype)initWithSize:(CGSize)size &#123; if(self &#x3D; [super init]) &#123; [self setDefaultProperty]; _size &#x3D; size; &#125; return self;&#125;@end 单元格默认样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172typedef NS_ENUM(NSInteger, WDPopMenuType) &#123; WDPopMenuTypeNormal, WDPopMenuTypeOnlyTitle, WDPopMenuTypeOnlyIcon,&#125;;@interface WDPopMenuCell : UITableViewCell@property (nonatomic, strong) UIImageView *iconImageView;@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, assign) WDPopMenuType showType;@end@implementation WDPopMenuCell- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self &#x3D; [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; [self setupSubViewsProperties]; &#125; return self;&#125;- (void)setupSubViewsProperties &#123; self.iconImageView &#x3D; [[UIImageView alloc] init]; self.iconImageView.contentMode &#x3D; UIViewContentModeScaleAspectFit; self.iconImageView.translatesAutoresizingMaskIntoConstraints &#x3D; NO; [self.contentView addSubview:self.iconImageView]; self.titleLabel &#x3D; [[UILabel alloc] init]; self.titleLabel.font &#x3D; [UIFont systemFontOfSize:15]; self.titleLabel.textColor &#x3D; [UIColor blackColor]; self.titleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO; [self.contentView addSubview:self.titleLabel];&#125;- (void)setShowType:(WDPopMenuType)showType &#123; _showType &#x3D; showType; [self setupSubViewsConstraint];&#125;- (void)setTitleLabel:(UILabel *)titleLabel &#123; _titleLabel &#x3D; titleLabel; titleLabel.translatesAutoresizingMaskIntoConstraints &#x3D; NO;&#125;- (void)setupSubViewsConstraint &#123; if (self.showType &#x3D;&#x3D; WDPopMenuTypeNormal) &#123; self.titleLabel.textAlignment &#x3D; NSTextAlignmentLeft; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeLeading multiplier:1 constant:15], [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.iconImageView attribute:NSLayoutAttributeTrailing multiplier:1 constant:10], [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125; else if (self.showType &#x3D;&#x3D; WDPopMenuTypeOnlyTitle)&#123; self.titleLabel.textAlignment &#x3D; NSTextAlignmentCenter; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125; else &#123; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125;&#125;@end 接口代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#import &lt;UIKit&#x2F;UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface WDPopMenu : UIView@property (nonatomic, copy, readonly) NSArray&lt;NSString *&gt; *titles;@property (nonatomic, copy, readonly) NSArray&lt;NSString *&gt; *iconImageNames;&#x2F;** 仅显示图标 + 默认样式 @param iconImageNames 图标数组 @param position 初始位置 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 仅显示图标 + 默认样式 @param iconImageNames 图标数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 仅显示标题 + 默认样式 @param titles 标题数组 @param position 初始位置 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 仅显示标题 + 默认样式 @param titles 标题数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 显示文字和图标 + 默认样式 @param iconImageNames 图标数组 @param titles 标题数组 @param position 初始位置 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 显示文字和图标 + 默认样式 @param iconImageNames 图标数组 @param titles 标题数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 可选显示图标、标题 @param iconImageNames 图片数组 可以为空 @param titles 标题数组 可以为空 @param position 初始位置 @param height 单个item高度 默认为45 @param width 显示View的高度 默认为屏幕宽度的一半 @param color 显示View的背景颜色 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;&#x2F;** 可选显示图标、标题 @param iconImageNames 图片数组 可以为空 @param titles 标题数组 可以为空 @param position 初始位置 @param height 单个item高度 默认为45 @param width 显示View的高度 默认为屏幕宽度的一半 @param color 显示View的背景颜色 @param isNeedSeparatorLine 是否显示分割线 @param titleLabel 自定义Item的Label样式 @param complete 点击回调 *&#x2F;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color titleLabelOfItem:(UILabel * _Nullable)titleLabel needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;@endNS_ASSUME_NONNULL_END 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#define WD_SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)#define WD_SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height)@interface WDPopMenu () &lt;UITableViewDataSource, UITableViewDelegate&gt;@property (nonatomic, copy) void (^selectedItemComplete)(NSInteger currentIndex);@property (nonatomic, strong) UIView *backgroundView;@property (nonatomic, strong) UITableView *tableView;@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, assign) CGFloat viewWidth;@property (nonatomic, assign) CGFloat itemHeight;@property (nonatomic, assign) CGPoint beginPosition;@property (nonatomic, strong) UIColor *cellColor;@property (nonatomic, copy, readwrite) NSArray&lt;NSString *&gt; *titles;@property (nonatomic, copy, readwrite) NSArray&lt;NSString *&gt; *iconImageNames;@end@implementation WDPopMenu- (instancetype)init &#123; self &#x3D; [super init]; if (self) &#123; [self addSubview:self.tableView]; UITapGestureRecognizer *tap &#x3D; [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(backgroundTappedTarget:)]; [self.backgroundView addGestureRecognizer:tap]; &#125; return self;&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:nil originPosition:position needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithTitles:titles originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:nil titles:titles originPosition:position needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position heightOfItem:0 widthOfView:0 backgroundColorOfView:[UIColor whiteColor] needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position heightOfItem:height widthOfView:width backgroundColorOfView:color titleLabelOfItem:nil needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color titleLabelOfItem:(UILabel * _Nullable)titleLabel needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; WDPopMenu *v &#x3D; [[WDPopMenu alloc] init]; v.iconImageNames &#x3D; iconImageNames; v.titles &#x3D; titles; v.beginPosition &#x3D; position; v.itemHeight &#x3D; height &#x3D;&#x3D; 0 ? 45 : height; v.viewWidth &#x3D; width &#x3D;&#x3D; 0 ? [[UIScreen mainScreen] bounds].size.width &#x2F; 2 : width; v.tableView.backgroundColor &#x3D; color; v.cellColor &#x3D; color; v.titleLabel &#x3D; titleLabel; v.selectedItemComplete &#x3D; complete; v.tableView.rowHeight &#x3D; v.itemHeight; if (isNeedSeparatorLine) &#123; v.tableView.separatorStyle &#x3D; UITableViewCellSeparatorStyleSingleLine; &#125; else &#123; v.tableView.separatorStyle &#x3D; UITableViewCellSeparatorStyleNone; &#125; [v.tableView reloadData]; [v showView];&#125;- (void)backgroundTappedTarget:(id)sender &#123; [self hidenView];&#125;- (void)showView &#123; [[[UIApplication sharedApplication] keyWindow] addSubview:self.backgroundView]; [[[UIApplication sharedApplication] keyWindow] addSubview:self]; [self setupViewAndArrowShape]; [self showAnimation];&#125;- (void)setupViewAndArrowShape &#123; CGRect toFrame &#x3D; CGRectZero; toFrame.size.width &#x3D; self.viewWidth; if (self.iconImageNames.count &#x3D;&#x3D; 0 || self.iconImageNames &#x3D;&#x3D; nil) &#123; toFrame.size.height &#x3D; self.itemHeight * self.titles.count + 15; &#125; else if (self.titles &#x3D;&#x3D; nil || self.titles.count &#x3D;&#x3D; 0) &#123; toFrame.size.height &#x3D; self.itemHeight * self.iconImageNames.count + 15; &#125; else &#123; toFrame.size.height &#x3D; self.itemHeight * self.titles.count + 15; &#125; WudanLayer *bbLayer &#x3D; [[WudanLayer alloc] initWithSize:toFrame.size]; if (self.beginPosition.x + self.viewWidth &#x2F; 2 &gt; WD_SCREEN_WIDTH) &#123; toFrame.origin.x &#x3D; WD_SCREEN_WIDTH - 10 - self.viewWidth; bbLayer.arrowDirection &#x3D; ArrowDirectionTop; bbLayer.arrowPosition &#x3D; (self.beginPosition.x - toFrame.origin.x + 15) &#x2F; self.viewWidth; self.layer.anchorPoint &#x3D; CGPointMake(bbLayer.arrowPosition, 0); &#125; else if (self.beginPosition.x - self.viewWidth &#x2F; 2 &lt; 0)&#123; toFrame.origin.x &#x3D; 10; bbLayer.arrowDirection &#x3D; ArrowDirectionTop; bbLayer.arrowPosition &#x3D; (self.beginPosition.x - toFrame.origin.x - 15) &#x2F; self.viewWidth; self.layer.anchorPoint &#x3D; CGPointMake(bbLayer.arrowPosition, 0); &#125; else &#123; toFrame.origin.x &#x3D; self.beginPosition.x - self.viewWidth &#x2F; 2; bbLayer.arrowDirection &#x3D; ArrowDirectionTop; bbLayer.arrowPosition &#x3D; (self.beginPosition.x - toFrame.origin.x) &#x2F; self.viewWidth; self.layer.anchorPoint &#x3D; CGPointMake(bbLayer.arrowPosition, 0); &#125; if (self.beginPosition.y + toFrame.size.height &gt; WD_SCREEN_HEIGHT) &#123; toFrame.origin.y &#x3D; self.beginPosition.y - toFrame.size.height - 15; bbLayer.arrowDirection &#x3D; ArrowDirectionBottom; self.layer.anchorPoint &#x3D; CGPointMake(bbLayer.arrowPosition, 1); &#125; else &#123; toFrame.origin.y &#x3D; self.beginPosition.y + 15; &#125; self.tableView.frame &#x3D; CGRectZero; self.frame &#x3D; CGRectMake(self.beginPosition.x, self.beginPosition.y, 0, 0); self.alpha &#x3D; 0; self.frame &#x3D; toFrame; if (self.beginPosition.y + toFrame.size.height &gt; WD_SCREEN_HEIGHT) &#123; self.tableView.contentInset &#x3D; UIEdgeInsetsZero; &#125; else &#123; self.tableView.contentInset &#x3D; UIEdgeInsetsMake(15, 0, 0, 0); &#125; self.tableView.frame &#x3D; CGRectMake(0, 0, toFrame.size.width, toFrame.size.height); bbLayer.cornerRadius &#x3D; 8; bbLayer.arrowHeight &#x3D; 15; bbLayer.arrowWidth &#x3D; 30; bbLayer.arrowRadius &#x3D; 0; [self.layer setMask:[bbLayer layer]];&#125;- (void)showAnimation &#123; self.layer.affineTransform &#x3D; CGAffineTransformMakeScale(0.1, 0.1); [UIView animateWithDuration:0.35 animations:^&#123; self.backgroundView.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0.1]; self.alpha &#x3D; 1; self.layer.affineTransform &#x3D; CGAffineTransformIdentity; &#125;];&#125;- (void)hidenView &#123; [UIView animateWithDuration:0.35 animations:^&#123; self.alpha &#x3D; 0; self.layer.affineTransform &#x3D; CGAffineTransformMakeScale(0.1, 0.1); self.backgroundView.backgroundColor &#x3D; [UIColor colorWithWhite:0 alpha:0]; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; self.layer.affineTransform &#x3D; CGAffineTransformIdentity; [self.backgroundView removeFromSuperview]; &#125;];&#125;#pragma mark - UITableView DataSource Method- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; if (self.titles.count &gt; 0) &#123; return self.titles.count; &#125; if (self.iconImageNames.count &gt; 0)&#123; return self.iconImageNames.count; &#125; return 0;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; WDPopMenuCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;WDPopMenuCell&quot;]; if (!cell) &#123; cell &#x3D; [[WDPopMenuCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;WDPopMenuCell&quot;]; &#125; if (self.iconImageNames.count &#x3D;&#x3D; 0 || self.iconImageNames &#x3D;&#x3D; nil) &#123; cell.showType &#x3D; WDPopMenuTypeOnlyTitle; cell.titleLabel.text &#x3D; self.titles[indexPath.row]; &#125; else if (self.titles &#x3D;&#x3D; nil || self.titles.count &#x3D;&#x3D; 0) &#123; cell.showType &#x3D; WDPopMenuTypeOnlyIcon; cell.iconImageView.image &#x3D; [UIImage imageNamed:self.iconImageNames[indexPath.row]]; &#125; else &#123; cell.showType &#x3D; WDPopMenuTypeNormal; cell.iconImageView.image &#x3D; [UIImage imageNamed:self.iconImageNames[indexPath.row]]; cell.titleLabel.text &#x3D; self.titles[indexPath.row]; &#125; if (self.titleLabel) &#123; cell.titleLabel.textColor &#x3D; self.titleLabel.textColor; cell.titleLabel.textAlignment &#x3D; self.titleLabel.textAlignment; cell.titleLabel.font &#x3D; self.titleLabel.font; &#125; cell.contentView.backgroundColor &#x3D; self.cellColor; if (indexPath.row &#x3D;&#x3D; [tableView numberOfRowsInSection:indexPath.section] - 1) &#123; cell.separatorInset &#x3D; UIEdgeInsetsMake(0, self.bounds.size.width, 0, 0); &#125; else &#123; cell.separatorInset &#x3D; UIEdgeInsetsMake(0, 0, 0, 0); &#125; return cell;&#125;#pragma mark - UITableView Delegate Method- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; [self hidenView]; self.selectedItemComplete(indexPath.row);&#125;#pragma mark - Setter- (UITableView *)tableView &#123; if (!_tableView) &#123; _tableView &#x3D; [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain]; _tableView.tableFooterView &#x3D; [[UIView alloc] init]; _tableView.dataSource &#x3D; self; _tableView.delegate &#x3D; self; _tableView.scrollEnabled &#x3D; NO; &#125; return _tableView;&#125;- (UIView *)backgroundView &#123; if (!_backgroundView) &#123; _backgroundView &#x3D; [[UIView alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; &#125; return _backgroundView;&#125;@end 实现效果图","categories":[],"tags":[]},{"title":"iOS自定义控件-AVPlayer封装","slug":"iOS自定义控件-AVPlayer封装","date":"2020-01-16T08:06:01.551Z","updated":"2020-01-20T02:07:52.977Z","comments":true,"path":"2020/01/16/iOS自定义控件-AVPlayer封装/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-AVPlayer%E5%B0%81%E8%A3%85/","excerpt":"","text":"最近在写关于音视频播放的案例，所以就趁机会研究了一下AVPlayer的内容。我封装的目前只能播放网络音视频。还未添加缓存，以后找机会研究一下再更新。代码中提供了音视频的上一曲、下一曲、暂停、开始、停止、单曲播放、顺序播放、随机播放等功能。代码写的不好，仅供参考~ 代码接口文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#import &lt;Foundation&#x2F;Foundation.h&gt;#import &lt;AVFoundation&#x2F;AVFoundation.h&gt;NS_ASSUME_NONNULL_BEGIN&#x2F;&#x2F; 当前播放器的播放形式typedef NS_ENUM(NSInteger, MediaPlayType) &#123; MediaPlayTypeCycle, &#x2F;&#x2F;&#x2F;&lt; 顺序 MediaPlayTypeSingle, &#x2F;&#x2F;&#x2F;&lt; 单曲循环 MediaPlayTypeRandom &#x2F;&#x2F;&#x2F;&lt; 随机播放&#125;;&#x2F;&#x2F; 当前播放器的播放状态typedef NS_ENUM(NSInteger, MediaPlayStatus) &#123; MediaPlayStatusStop, &#x2F;&#x2F;&#x2F;&lt; 停止播放 MediaPlayStatusPause, &#x2F;&#x2F;&#x2F;&lt; 暂停播放 MediaPlayStatusPlaying &#x2F;&#x2F;&#x2F;&lt; 正在播放&#125;;&#x2F;&#x2F; 媒体加载状态typedef NS_ENUM(NSInteger, MediaLoadStatus) &#123; MediaLoadStatusReadyToPlay, &#x2F;&#x2F;&#x2F;&lt; 准备播放 MediaLoadStatusUnknown, &#x2F;&#x2F;&#x2F;&lt; 未知 MediaPlayStatusFailed &#x2F;&#x2F;&#x2F;&lt; 失败&#125;;@class MediaPlyerManager;@protocol MediaPlyerManagerDelegate &lt;NSObject&gt;@optional&#x2F;&#x2F; 数据加载状态 根据状态进行播放或其他操作- (void)MediaPlayer:(MediaPlyerManager *)playerManager playerItemStatus:(MediaLoadStatus)status;&#x2F;&#x2F; 缓冲进度- (void)MediaPlayer:(MediaPlyerManager *)playerManager netBufferValue:(CGFloat)value;&#x2F;&#x2F; 缓冲是否足够播放- (void)MediaPlayer:(MediaPlyerManager *)playerManager bufferHasEnough:(BOOL)enough;&#x2F;&#x2F; 当前播放的时间- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentPlayTime:(NSString *)time currentPlayTimeValue:(CGFloat)value;&#x2F;&#x2F; 播放总时间- (void)MediaPlayer:(MediaPlyerManager *)playerManager mediaEndTime:(NSString *)time mediaEndTimeValue:(CGFloat)value;&#x2F;&#x2F; 播放结束- (void)MediaPlayerCurrentMediaPlayFinish:(MediaPlyerManager *)playerManager;&#x2F;&#x2F; 播放状态- (void)MediaPlayer:(MediaPlyerManager *)playerManager playeStatus:(MediaPlayStatus)status;&#x2F;&#x2F; 获取数据切换时获取正在播放的URL和当前的index- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentUrl:(NSString *)url currentIndex:(NSInteger)index;&#x2F;&#x2F; 为了配合手机后台播放 实时获取播放的进度，总的时间，当前的index&lt;通过index获取图片等信息&gt;- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentProgressValue:(CGFloat)value totalValue:(CGFloat)totalValue currentIndex:(NSInteger)index;@endtypedef MediaPlyerManager *(^playerCurrentTime)(NSString *time);@interface MediaPlyerManager : NSObject@property (nonatomic, strong, readonly) AVPlayer *mediaPlayer; &#x2F;&#x2F;&#x2F;&lt; 播放器@property (nonatomic, strong, readonly) AVPlayerItem *meidaPlayerItem; &#x2F;&#x2F;&#x2F;&lt; 播放器的CurrentItem@property (nonatomic, strong, readonly) NSMutableArray&lt;NSString*&gt; *dataUrlArray; &#x2F;&#x2F;&#x2F;&lt; 正在播放的列表数据@property (nonatomic, assign, readonly) MediaPlayType playType; &#x2F;&#x2F;&#x2F;&lt; 当前播放类型@property (nonatomic, assign, readonly) MediaPlayStatus playStatus; &#x2F;&#x2F;&#x2F;&lt; 当前播放状态@property (nonatomic, assign, readonly) NSInteger currentIndex; &#x2F;&#x2F;&#x2F;&lt; 当前播放的索引@property (nonatomic, assign, readonly) BOOL isPlaying; &#x2F;&#x2F;&#x2F;&lt; 是否在播放@property (nonatomic, assign, readonly) CGFloat curentPlayTimeValue; &#x2F;&#x2F;&#x2F;&lt; 当前播放时间值@property (nonatomic, copy, readonly) NSString *curentPlayTime; &#x2F;&#x2F;&#x2F;&lt; 当前播放时间@property (nonatomic, assign, readonly) CGFloat endPlayTimeValue; &#x2F;&#x2F;&#x2F;&lt; 当前播放时间值@property (nonatomic, copy, readonly) NSString *endPlayTime; &#x2F;&#x2F;&#x2F;&lt; 当前播放时间+ (instancetype)defaultManager;&#x2F;** 列表播放 ⚠️&lt;默认不自动播放&gt; @param urls 文件路径数组 @param delegate 回调代理 @return MediaPlyerManager *&#x2F;- (MediaPlyerManager *)playerWithUrls:(NSArray&lt;NSString *&gt; *)urls actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate;&#x2F;** 单个音视频播放 ⚠️&lt;默认不自动播放&gt; @param url 文件路径 @param delegate 回调代理 @return MediaPlyerManager *&#x2F;- (MediaPlyerManager *)playerWithUrl:(NSString *)url actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate;&#x2F;** 开始播放 *&#x2F;- (void)play;&#x2F;** 暂停播放 *&#x2F;- (void)pause;&#x2F;** 停止播放 *&#x2F;- (void)stop;&#x2F;** 下一曲 *&#x2F;- (void)next;&#x2F;** 上一曲 *&#x2F;- (void)previous;&#x2F;** 指定进度开始播放 @param progress 进度百分比 *&#x2F;- (void)setupPlayerSeekToProgress:(CGFloat)progress;&#x2F;** 制定播放类型 @param type 类型 *&#x2F;- (void)setupMediaPlayerType:(MediaPlayType)type;&#x2F;** 指定播放的index @param index 索引 *&#x2F;- (void)setupPlayerIndex:(NSInteger)index;&#x2F;** 添加数据 @param files 文件数组 @param index 索引 *&#x2F;- (void)insertMediaFile:(NSArray&lt;NSString *&gt; *)files atIndex:(NSInteger)index;&#x2F;** 移除全部数据 *&#x2F;- (void)removeAllFiles;&#x2F;** 移除索引中的单个数据 @param index 索引 *&#x2F;- (void)removeObjectAtIndex:(NSInteger)index;&#x2F;** 设置锁屏样式 @param coverImage 专辑图片 @param size 显示大小 @param title 标题 @param author 专辑作者 @param album 专辑名称 @param currentTime 当前播放时间 @param duration 播放总时长 *&#x2F;- (void)setupLockScreenPlayInfo:(UIImage *)coverImage imageSize:(CGSize)size title:(NSString *)title ahthor:(NSString *)author album:(NSString *)album currentPlayTime:(CGFloat)currentTime duration:(CGFloat)duration;@endNS_ASSUME_NONNULL_END 代码实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#import &quot;MediaPlyerManager.h&quot;#import &lt;MediaPlayer&#x2F;MediaPlayer.h&gt;@interface MediaPlyerManager ()@property (nonatomic, strong, readwrite) NSMutableArray&lt;NSString *&gt; *dataUrlArray;@property (nonatomic, strong, readwrite) AVPlayer *mediaPlayer;@property (nonatomic, assign, readwrite) BOOL isPlaying;@property (nonatomic, strong, readwrite) AVPlayerItem *meidaPlayerItem;@property (nonatomic, assign, readwrite) MediaPlayType playeType;@property (nonatomic, assign, readwrite) NSInteger currentIndex;@property (nonatomic, assign, readwrite) MediaPlayStatus playStatus;@property (nonatomic, assign, readwrite) CGFloat curentPlayTimeValue;@property (nonatomic, copy, readwrite ) NSString *curentPlayTime;@property (nonatomic, assign, readwrite) CGFloat endPlayTimeValue;@property (nonatomic, copy, readwrite ) NSString *endPlayTime;@property (nonatomic, weak ) id &lt;MediaPlyerManagerDelegate&gt; delegate;@end@implementation MediaPlyerManager+ (instancetype)defaultManager &#123; static dispatch_once_t onceToken; static MediaPlyerManager *manger; dispatch_once(&amp;onceToken, ^&#123; manger &#x3D; [[MediaPlyerManager alloc] init]; &#125;); return manger;&#125;#pragma mark - 初始化- (MediaPlyerManager *)playerWithUrl:(NSString *)url actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate &#123; [self playerWithUrls:@[url] actionWithDelegate:delegate]; return self;&#125;- (MediaPlyerManager *)playerWithUrls:(NSArray&lt;NSString *&gt; *)urls actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate &#123; self.delegate &#x3D; delegate; self.currentIndex &#x3D; 0; self.dataUrlArray &#x3D; [NSMutableArray array]; NSMutableArray *array &#x3D; [NSMutableArray arrayWithCapacity:urls.count]; for (NSString *urlStr in urls) &#123; [array addObject:[self createPlayerItemWithUrl:urlStr]]; [self.dataUrlArray addObject:urlStr]; &#125; self.playeType &#x3D; MediaPlayTypeCycle; self.mediaPlayer &#x3D; [[AVPlayer alloc] initWithPlayerItem:array.firstObject]; self.meidaPlayerItem &#x3D; self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver]; __weak typeof(self) weakself &#x3D; self; [self.mediaPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:NULL usingBlock:^(CMTime time) &#123; NSString *currentString &#x3D; [weakself getStringFromCMTime:time]; weakself.curentPlayTime &#x3D; currentString; weakself.curentPlayTimeValue &#x3D; (CGFloat)time.value&#x2F;time.timescale; #pragma mark - 获取当前播放时间 if (weakself.delegate &amp;&amp; [weakself.delegate respondsToSelector:@selector(MediaPlayer:currentPlayTime:currentPlayTimeValue:)]) &#123; [weakself.delegate MediaPlayer:weakself currentPlayTime:currentString currentPlayTimeValue:(CGFloat)time.value&#x2F;time.timescale]; &#125;#pragma mark - 实时获取播放信息 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:currentProgressValue:totalValue:currentIndex:)]) &#123; [weakself.delegate MediaPlayer:weakself currentProgressValue:weakself.curentPlayTimeValue totalValue:weakself.endPlayTimeValue currentIndex:weakself.currentIndex]; &#125; &#125;]; return self;&#125;#pragma mark - 播放结束- (void)playFinish:(NSNotification *)notification &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayerCurrentMediaPlayFinish:)]) &#123; [self.delegate MediaPlayerCurrentMediaPlayFinish:self]; &#125; if (self.playeType &#x3D;&#x3D; MediaPlayTypeSingle) &#123; [self.mediaPlayer seekToTime:kCMTimeZero]; [self play]; &#125; else &#123; if (self.currentIndex &lt; self.dataUrlArray.count - 1) &#123; self.currentIndex +&#x3D; 1; &#125; else &#123; self.currentIndex &#x3D; 0; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem &#x3D; self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self play]; &#125;&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; AVPlayerItem *playerItem &#x3D; object; if ([keyPath isEqualToString:@&quot;status&quot;]) &#123; MediaLoadStatus status &#x3D; [change[@&quot;new&quot;] integerValue];#pragma mark - 获取媒体加载状态 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:playerItemStatus:)]) &#123; [self.delegate MediaPlayer:self playerItemStatus:status]; &#125; &#125; else if ([keyPath isEqualToString:@&quot;loadedTimeRanges&quot;]) &#123; NSArray * timeRanges &#x3D; playerItem.loadedTimeRanges; CMTimeRange timeRange &#x3D; [timeRanges.firstObject CMTimeRangeValue]; NSTimeInterval totalLoadTime &#x3D; CMTimeGetSeconds(timeRange.start) \\ + CMTimeGetSeconds(timeRange.duration); NSTimeInterval duration &#x3D; CMTimeGetSeconds(playerItem.duration); NSTimeInterval scale &#x3D; totalLoadTime&#x2F;duration; #pragma mark - 获取媒体总时间 if ((CGFloat)duration&#x2F;scale &gt;&#x3D; 0) &#123; self.endPlayTime &#x3D; [self getStringFromCMTime:playerItem.duration]; self.endPlayTimeValue &#x3D; (CGFloat)duration&#x2F;scale; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:mediaEndTime:mediaEndTimeValue:)]) &#123; [self.delegate MediaPlayer:self mediaEndTime:[self getStringFromCMTime:playerItem.duration] mediaEndTimeValue:(CGFloat)duration&#x2F;scale]; &#125; &#125; #pragma mark - 缓冲百分比 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:netBufferValue:)]) &#123; [self.delegate MediaPlayer:self netBufferValue:scale]; &#125; &#125; else if ([keyPath isEqualToString:@&quot;playbackBufferEmpty&quot;]) &#123; #pragma mark - 缓冲不足够播放 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:bufferHasEnough:)]) &#123; [self.delegate MediaPlayer:self bufferHasEnough:false]; &#125; &#125; else if ([keyPath isEqualToString:@&quot;playbackLikelyToKeepUp&quot;]) &#123; #pragma mark - 缓冲足够播放 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:bufferHasEnough:)]) &#123; [self.delegate MediaPlayer:self bufferHasEnough:true]; &#125; &#125;&#125;#pragma mark - 开始播放- (void)play &#123; [self.mediaPlayer play]; [self getPlayStatus:MediaPlayStatusPlaying];&#125;#pragma mark - 暂停播放- (void)pause &#123; [self.mediaPlayer pause]; [self getPlayStatus:MediaPlayStatusPause];&#125;#pragma mark - 停止播放- (void)stop &#123; [self.mediaPlayer replaceCurrentItemWithPlayerItem:nil]; [self getPlayStatus:MediaPlayStatusStop]; [self removeObserver];&#125;#pragma mark - 下一个- (void)next &#123; if (self.playeType &#x3D;&#x3D; MediaPlayTypeRandom) &#123; self.currentIndex &#x3D; (NSInteger)arc4random_uniform((int32_t)(self.dataUrlArray.count - 1)); &#125; else &#123; if (self.currentIndex &#x3D;&#x3D; self.dataUrlArray.count - 1) &#123; self.currentIndex &#x3D; 0; &#125; else &#123; self.currentIndex +&#x3D; 1; &#125; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem &#x3D; self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver];&#125;#pragma mark - 上一个- (void)previous &#123; if (self.playeType &#x3D;&#x3D; MediaPlayTypeRandom) &#123; self.currentIndex &#x3D; (NSInteger)arc4random_uniform((int32_t)(self.dataUrlArray.count - 1)); &#125; else &#123; if (self.currentIndex &#x3D;&#x3D; 0) &#123; self.currentIndex &#x3D; self.dataUrlArray.count - 1; &#125; else &#123; self.currentIndex -&#x3D; 1; &#125; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem &#x3D; self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver];&#125;#pragma mark - 播放状态- (void)getPlayStatus:(MediaPlayStatus)status &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:playeStatus:)]) &#123; [self.delegate MediaPlayer:self playeStatus:status]; &#125; self.playStatus &#x3D; status; if (status &#x3D;&#x3D; MediaPlayStatusPlaying) &#123; self.isPlaying &#x3D; true; &#125; else &#123; self.isPlaying &#x3D; false; &#125;&#125;#pragma mark - 根据index进行回调- (void)getCurrentIndex:(NSInteger)index &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:currentUrl:currentIndex:)]) &#123; [self.delegate MediaPlayer:self currentUrl:self.dataUrlArray[index] currentIndex:index]; &#125;&#125;#pragma mark - 设置播放进度百分比- (void)setupPlayerSeekToProgress:(CGFloat)progress &#123; float timeValue &#x3D; progress * CMTimeGetSeconds(self.mediaPlayer.currentItem.duration); [self.mediaPlayer seekToTime:CMTimeMake(timeValue, 1)];&#125;#pragma mark - 设置播放形式- (void)setupMediaPlayerType:(MediaPlayType)type &#123; self.playeType &#x3D; type;&#125;#pragma mark - 播放指定index的媒体- (void)setupPlayerIndex:(NSInteger)index &#123; if (index &gt; (self.dataUrlArray.count - 1)) &#123; @throw [NSException exceptionWithName:@&quot;越界错误&quot; reason:@&quot;index 不能超出URL数组的长度&quot; userInfo:nil]; return; &#125; self.currentIndex &#x3D; index; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem &#x3D; self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex];&#125;#pragma mark - 插入数据- (void)insertMediaFile:(NSArray&lt;NSString *&gt; *)files atIndex:(NSInteger)index &#123; for (NSString *urlStr in files) &#123; NSInteger i &#x3D; [files indexOfObject:urlStr]; [self.dataUrlArray insertObject:urlStr atIndex:index + i]; &#125; if (index &lt; self.currentIndex) &#123; self.currentIndex +&#x3D; 1; &#125;&#125;#pragma mark - 删除数据- (void)removeAllFiles &#123; [self stop]; [self.dataUrlArray removeAllObjects]; self.dataUrlArray &#x3D; [NSMutableArray array]; self.currentIndex &#x3D; 0;&#125;- (void)removeObjectAtIndex:(NSInteger)index &#123; if (self.dataUrlArray.count &#x3D;&#x3D; 1) &#123; [self removeAllFiles]; &#125; else &#123; [self.dataUrlArray removeObjectAtIndex:index]; if (index &#x3D;&#x3D; self.currentIndex) &#123; if (index &#x3D;&#x3D; 0) &#123; self.currentIndex &#x3D; 0; [self next]; &#125; else &#123; self.currentIndex -&#x3D; 1; &#125; &#125; else &#123; if (self.currentIndex &gt; index) &#123; self.currentIndex -&#x3D; 1; &#125; &#125; &#125;&#125;#pragma mark - Utils- (NSString *)getStringFromCMTime:(CMTime)time &#123; float currentTimeValue &#x3D; (CGFloat)time.value&#x2F;time.timescale; NSDate * currentDate &#x3D; [NSDate dateWithTimeIntervalSince1970:currentTimeValue]; NSCalendar *calendar &#x3D; [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSInteger unitFlags &#x3D; NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; NSDateComponents *components &#x3D; [calendar components:unitFlags fromDate:currentDate]; if (currentTimeValue &gt;&#x3D; 3600 ) &#123; return [NSString stringWithFormat:@&quot;%02ld:%02ld:%02ld&quot;, (long)components.hour, (long)components.minute, (long)components.second]; &#125; else &#123; return [NSString stringWithFormat:@&quot;%02ld:%02ld&quot;, (long)components.minute, (long)components.second]; &#125;&#125;- (void)addObserver &#123; &#x2F;&#x2F; 监控状态属性 [self.meidaPlayerItem addObserver:self forKeyPath:@&quot;status&quot; options:(NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew) context:nil]; &#x2F;&#x2F; 监控缓冲加载情况属性 [self.meidaPlayerItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:(NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew) context:nil]; &#x2F;&#x2F; 监听缓冲不足够播放 [self.meidaPlayerItem addObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot; options:NSKeyValueObservingOptionNew context:nil]; &#x2F;&#x2F; 监听缓冲足够播放 [self.meidaPlayerItem addObserver:self forKeyPath:@&quot;playbackLikelyToKeepUp&quot; options:NSKeyValueObservingOptionNew context:nil]; &#x2F;&#x2F; 获取是否播放结束 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playFinish:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.meidaPlayerItem];&#125;- (void)removeObserver &#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; @try &#123; [self.meidaPlayerItem removeObserver:self forKeyPath:@&quot;loadedTimeRanges&quot;]; [self.meidaPlayerItem removeObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot;]; [self.meidaPlayerItem removeObserver:self forKeyPath:@&quot;playbackLikelyToKeepUp&quot;]; [self.meidaPlayerItem removeObserver:self forKeyPath:@&quot;status&quot;]; &#125; @catch(NSException *exception) &#123; NSLog(@&quot;%@&quot;, exception); &#125; &#125;#pragma mark - 设置锁屏样式- (void)setupLockScreenPlayInfo:(UIImage *)coverImage imageSize:(CGSize)size title:(NSString *)title ahthor:(NSString *)author album:(NSString *)album currentPlayTime:(CGFloat)currentTime duration:(CGFloat)duration &#123; Class playingInfoCenter &#x3D; NSClassFromString(@&quot;MPNowPlayingInfoCenter&quot;); if (playingInfoCenter) &#123; NSMutableDictionary *songInfo &#x3D; [[NSMutableDictionary alloc] init]; MPMediaItemArtwork *albumArt &#x3D; [[MPMediaItemArtwork alloc] initWithBoundsSize:size requestHandler:^UIImage * _Nonnull(CGSize size) &#123; return coverImage; &#125;]; [songInfo setObject:title forKey:MPMediaItemPropertyTitle]; [songInfo setObject:author forKey:MPMediaItemPropertyArtist]; [songInfo setObject:album forKey:MPMediaItemPropertyAlbumTitle]; [songInfo setObject:albumArt forKey:MPMediaItemPropertyArtwork]; [songInfo setObject:[NSNumber numberWithDouble:currentTime] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; [songInfo setObject:[NSNumber numberWithDouble:duration] forKey:MPMediaItemPropertyPlaybackDuration]; [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:songInfo]; &#125;&#125;- (AVPlayerItem *)createPlayerItemWithUrl:(NSString *)url &#123; return [AVPlayerItem playerItemWithURL:[NSURL URLWithString:url]];&#125;@end 提问本来相同使用AVQueuePlayer来进行列表播放的，但是当做单曲循环的时候遇到问题：通过通知监听播放完成，在通知的方法里进行具体操作，但是设置无效，直接播放的还是下一个文件。如果有人知道如何解决，帮忙回复一下。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}]},{"title":"iOS面试题-007","slug":"iOS面试题-007","date":"2020-01-16T08:05:48.432Z","updated":"2020-01-20T01:42:43.602Z","comments":true,"path":"2020/01/16/iOS面试题-007/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-007/","excerpt":"","text":"线程死锁的必要条件 互斥条件 : 一个资源每次只能被一个进程使用。 请求与保持条件 : 一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。 多图下载，最后合并成一个图片的方式 dispatch_group 信号量 NSOperationQueue 线程与进程的关系 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 线程与Runloop的关系 RunLoop 的作用就是来管理线程的，当线程的 RunLoop开启后，线程就会在执行完任务后，处于休眠状态，随时等待接受新的任务，而不是退出。 只有主线程的RunLoop是默认开启的，所以程序在开启后，会一直运行，不会退出。其他线程的RunLoop如果需要开启，就手动开启。","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-006","slug":"iOS面试题-006","date":"2020-01-16T08:05:44.945Z","updated":"2020-01-20T01:42:53.393Z","comments":true,"path":"2020/01/16/iOS面试题-006/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-006/","excerpt":"","text":"基础 如何是自己写的对象具有拷贝功能 需实现 NSCopying 协议。 说说你如何理解weak属性 Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 UIView和CALayer的关系 每个UIView都对应着一个CALayer,当我们创建了一个UIView之后也会创建对应的CALayer。UIView之所以能够显示内容，其实还是靠CALayer来绘制的。UIView本身就像是CALayer的管理者，访问UIView的坐标，例如：frame，center等，其实是访问内部layer的frame、position等相关属性。 @synthesize和@dynamic分别什么作用? 1、@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;2、@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。3、@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 动态绑定 Category(类别)、Extension(扩展)和继承的区别 1、Category：分类就是对一个类的功能进行扩展,,让这个类能够适应不不同情况的需求.在一般的实际开发中,我们都会对系统的一些常用类进行扩展,比如,NSString,Button,Label等等,简单来说类别是一种为现有的类添加新方法的方式。2、Extension：是Category的一个特例作用:为一个类增加私有方法,属性或成员变量,也就是说只能这些只能在本文件中被使用其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制)3、继承：多个类具有相同的实例变量和方法时，考虑用继承。即子类可以继承父类的相同特性。如animal具有年龄和体重两个属性，dog也具有年龄和体重两 个属性，dog可以继承animal的这两个属性，即为继承。 为什么代理要用weak？delegate和DataSource有什么区别？Block和代理的区别？ id和NSObject *的区别 1、NSObject包含了一些其他的方法，需要实现NSObject协议，可以用NSObject来表示id，但是不能用id来表示NSObject。2、id关键字在编译的时候不会被检查，而NSObject在编译的时候被被检查是否含有一些错误的方法3、id可以是任何对象，包括不是NSObject的对象4、定义id的时候不需要*，而定义NSOject的时候需要。 针对系统提供的Block API，是否也要考虑循环引用的问题？ 系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑。以下这些使用方式不会引起循环引用的问题 1234567891011[UIView animateWithDuration:1.2 animations:^&#123; [self.view layoutIfNeeded]; &#125;]; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; &#x2F;&#x2F; Do Some Thing &#125;]; [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; &#x2F;&#x2F; Do Some Thing &#125;]; 但如果方法中的一些参数是 成员变量，那么可以造成循环引用，如 GCD 、NSNotificationCenter调用就要小心一点，比如 GCD 内部如果引用了 self，而且 GCD 的参数是 成员变量，则要考虑到循环引用，举例如下：GCD-&gt;分析：self–&gt;_operationsQueue–&gt;block–&gt;self形成闭环，就造成了循环引用 123&gt;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; &#x2F;&#x2F; Do Some Thing&gt;&#125;); NSNotificationCenter-&gt;分析:self–&gt;_observer–&gt;block–&gt;self形成闭环，就造成了循环引用 123&gt;_observer &#x3D; [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note)&#123;&#x2F;&#x2F; Do Some Thing&gt;&#125;]; 在@property中为什么 NSString （或NSArray，NSDictionary）使用copy关键字？改成Strong有可能会造成什么问题？ 1、因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.2、如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. 关键字const/static/extern、UIKIT_EXTERN区别和用法 1、const（1）const用来修饰右边的基本变量或指针变量（2）被修饰的变量只读，不能被修改 2、static（1）修饰局部变量（2）修饰全局变量（3）修饰函数3、extern（1）声明外部全局变量。这里需要特别注意extern只能声明，不能用于实现，而且定义和分配内存都在原来类中。4、UIKIT_EXTERN（1）将函数修饰为兼容以往C编译方式的、具有extern属性(文件外可见性)、public修饰的方法或变量库外仍可见的属性 底层 main()之前有哪些过程？ KVO的原理 当观察某对象时，KVO动态创建该对象的子类，并重写子类被观察属性setter方法，随后通知观察者该属性的变化状况。 Swift如何使用KVO？ Swift有哪些匹配模式？ Objc向一个对象发送消息，发生了什么？ Runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 静态库的原理是什么？你有没有写过哪些静态库? 遇到哪些问题？ Runloop是用来做什么的？runloop和线程的关系？主线程默认开始runloop了吗？ 子线程呢？ 不手动指定autoreleasepool的前提下，autoreleasepool在什么什么时刻释放？（比如在vc的viewDidLoad中创建） 手动干预释放时机 - 指定autoreleasepool就是所谓的：当前作用域大括号结束时释放。 系统自动去释放 - 不手动指定autoreleasepoolAutorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 OC中的消息转发机制+代码实现 以 + scheduledTimerWithTimeInterval…的方式触发的NSTimer，在滑动的列表时，timer会暂时回调，为什么？如何解决？ 如何手动触发一个value的KVO？ 自动触发： 自动触发是指类似的这种场景：在注册KVO之前设置一个初始值，注册之后设置一个不一样的值，就可以触发了。 手动触发： 键值观察通知依赖于NSObject的两个方法：willChangeValueForKey：和didChangeValueForKey：。在一个被观察属性发生改变之前，willChangeValueForKey：一定会被调用，这就会记录旧的值。而当改变发生后，didChangeValueForKey：会被调用，继而objectServeValueForKey：ofObject：change：content：也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。 如何定位和分析项目中影响性能的地方？以及如何进行性能优化？ 串行并行，异步同步的区别 串行并行 指的是能否开启新的线程。同步不能开启新的线程，异步可以。 异步同步 指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。 线程是什么？进程是什么？二者有什么区别和联系？ 线程是CPU独立运行和独立调度的基本单位 进程是资源分配的基本单位； 两者的联系：进程和线程都是操作系统所运行的程序运行的基本单元。 区别： 进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。 线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-004","slug":"iOS面试题-004","date":"2020-01-16T08:05:40.782Z","updated":"2020-01-20T01:45:07.814Z","comments":true,"path":"2020/01/16/iOS面试题-004/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-004/","excerpt":"","text":"1、swift和oc的区别 2、编译链接 3、synthesize &amp; denamic 4、在项目开发中常用的开发工具有哪些？ 5、UITableView &amp; UICollection 6、NSProxy &amp; NSObject 7、Object &amp; Swift 8、传值通知 &amp; 推送通知（本地&amp;远程） 9、第三方库 &amp; 第三方平台 10、NSCache &amp; NSDcitionary 11、 UIView的setNeedsDisplay和setNeedsLayout方法 12、UILayer &amp; UIView 13、layoutSubViews &amp; drawRects 14、UDID &amp; UUID 15、CPU &amp; GPU 16、点（pt）&amp; 像素（px） 17、属性与成员变量 18、int和NSInteger的区别 （1）import和include （2）@class （3）全局 &amp; 静态变量 19、类和对象 （1）分类拓展协议中哪些可以声明属性? （2）继承和类别的区别 （3）分类的作用 （4）分类的局限性 20、category &amp; extension 21、Foundation （1）字符串 （2）字符串截取 （3）格式 22、NSArray和NSDictionary （1）iOS遍历数组/字典的方法 （2）NSValue NSNumber （3）其它 （4）如何避免循环引用 23、CFSocket使用有哪几个步骤 24、Core Foundation中提供了哪几种操作Socket的方法？ 25、解析XML文件有哪几种方式？ 26、什么是沙盒模型？哪些操作是属于私有api范畴? 27、在一个对象的方法里面：self.name= “object”；和 name =”object” 有什么不同吗? 28、请简要说明viewDidLoad和viewDidUnload何时调用 29、创建控制器、视图的方式 30、简述内存分区情况 31、队列和栈有什么区别 32、iOS的系统架构 33、控件主要响应3种事件 34、xib文件的构成分为哪3个图标？都具有什么功能 35、简述视图控件器的生命周期 36、app 项目的生命周期 （1）应用的生命周期 （2）简要说明一下APP的启动过程，main文件说起，main函数中有什么函数？作用是什么？ （3）UIApplicationMain函数作用 （4）main函数作用 37、 动画有基本类型有哪几种；表视图有哪几种基本样式。 38、实现简单的表格显示需要设置UITableView的什么属性、实现什么协议？ 39、Cocoa Touch提供了哪几种Core Animation过渡类型？ 40、UIView与CLayer有什么区别？ 41、Quatrz 2D的绘图功能的三个核心概念是什么并简述其作用 42、iPhone OS主要提供了几种播放音频的方法？ 43、使用AVAudioPlayer类调用哪个框架、使用步骤？ 44、有哪几种手势通知方法、写清楚方法名？ 45、ViewController的didReceiveMemoryWarning怎么被调用 46、什么时候用delegate,什么时候用Notification? 47、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题） 48、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。 49、关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用 50、关键字volatile有什么含意?并给出三个不同的例子 51、一个参数既可以是const还可以是volatile吗？ 一个指针可以是volatile 吗？解释为什么。 52、static 关键字的作用 53、列举几种进程的同步机制，并比较其优缺点。 54、进程之间通信的途径 55、进程死锁的原因 56、死锁的4个必要条件 57、死锁的处理 58、cocoa touch框架 59、自动释放池是什么,如何工作 60、sprintf,strcpy,memcpy使用上有什么要注意的地方 61、你了解svn,cvs等版本控制工具么？ 62、什么是push 63、静态链接库 64、OC三大特性 （1）封装_点语法 （2）继承 （3）多态 65、OC中如何实现多态 66、Objective-C的优缺点 67、对于OC,你认为最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以话，有没有考虑或者实现过重新实现OC的功能，如果有，具体怎么做？ 68、oc中可修改和不可以修改类型 69、我们说的oc是动态运行时语言是什么意思? 70、通知和协议的不同之处? 71、什么是推送消息? 72、关于多态性 73、什么是谓词? 74、做过的项目是否涉及网络访问功能，使用什么对象完成网络功能? 75、简单介绍下NSURLConnection类及+sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别? 76、谈谈Object-C的内存管理方式及过程？ 77、Object-C有私有方法吗？私有变量呢？ 78、说说响应链 79、时间传递 &amp; 响应者链 80、frame和bounds有什么不同? 81、方法和选择器有何不同? 82、OC的垃圾回收机制? 83、什么是延迟加载? 84、是否在一个视图控制器中嵌入两个tableview控制器? 85、一个tableView是否可以关联两个不同的数据源?你会怎么处理? 86、什么时候使用NSMutableArray，什么时候使用NSArray? 87、给出委托方法的实例，并且说出UITableVIew的Data Source方法 88、在应用中可以创建多少autorelease对象，是否有限制? 89、如果我们不创建内存池，是否有内存池提供给我们? 90、什么时候需要在程序中创建内存池? 91、类NSObject的那些方法经常被使用? 92、什么是简便构造方法? 93、如何使用Xcode设计通用应用? 94、 UIView的动画效果有那些? 95、Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类 96、内存管理 Autorelease、retain、copy、assign的set方法和含义？ 97、C和obj-c 如何混用 98、类别的作用?继承和类别在实现中有何区别? 99、类别和类扩展的区别。 100、oc中的协议和java中的接口概念有何不同? 101、深拷贝与前拷贝区别 （1）什么是深拷贝浅拷贝 （2）字符串什么时候使用copy,strong （3）字符串所在内存区域 （4）mutablecopy和copy @property(copy) NSMutableArray *arr;这样写有什么问题 （5）如何让自定义类可以使用copy修饰符 102、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象？ 103、#import 跟#include 又什么区别，@class呢, ＃import&lt;&gt; 跟 #import””又什么区别？ 104、Objective-C的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方法用继承好还是分类好?为什么? 105、 #import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别? 106、写一个setter方法用于完成@property (nonatomic,retain)NSString name,写一个setter方法用于完成@property(nonatomic，copy)NSString name 107、常见的Objective-C的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int 108、id 声明的对象有什么特性? 109、Objective-C如何对内存管理的,说说你的看法和解决方法? 110、原子(atomic)跟非原子(non-atomic)属性有什么区别? 111、看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么? 112、内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露? 113、如何对iOS设备进行性能测试? 114、设计模式 （1）mvc模式 （2）单例模式 （3）mvvm模式 （4）观察者模式 （5）工厂模式 （6）代理模式 （7）策略模式 （8）适配器模式 （9）模版模式 （10）外观模式 （11）创建模式 （12）MVP模式 115、MVVM模式原理分析 116、说说常用的几种传值方式 117、什么时候用delegate，什么时候用Notification 118、对于单例的理解 119、从设计模式角度分析代理，通知和KVO区别？ios SDK 提供 的framework使用了哪些设计模式，为什么使用？有哪些好处和坏处? 120、KVO，NSNotification，delegate及block区别 121、运行时（runTime） 122、runtime/消息转发机制 （1）runtime 1.1、什么是runtime 1.2、runtime干什么用，使用场景 （2）消息机制 2.1、消息转发的原理 2.2、SEL isa super cmd 是什么 （3）动态绑定 123、使用bugly进行崩溃分析 124、jenkens 持续打包 125、KVO &amp; KVC （1）底层实现 （2）KVO概述 （3）KVC概述 126、什么是KVO和KVC? KVO和KVC （1）如何调用私有变量，如何修改系统的只读属性，KVC的查找顺序 （2）什么是键-值,键路径是什么 （3）kvo的实现机制 （4）KVO计算属性，设置依赖键 （5）KVO集合属性 （6）kvo使用场景 127、SDWebImage(SDWebImage的实现机制） （1）主要功能 （2）缓存 （3）内存缓存与磁盘缓存 128、框架 SDWebimage的缓存机制 129、网络安全 密码的安全原则 130、多线程 （1）多线程概念 （2）多线程的作用 （3）使用场景 131、NSOperationQueue和GCD的区别是什么 132、GCD与NSThread的区别 133、进程和线程的区别与联系是什么? 134、别异步执行两个耗时操作，等两次耗时操作都执行完毕后,再回到主线程执行操作. 使用队列组(dispatch_group_t)快速,高效的实现上述需求 135、在项目什么时候选择使用GCD，什么时候选择NSOperation? 136、对比iOS中的多线程技术 137、多线程优缺点 138、iOS中的延迟操作 139、串行队列同步执行和异步主队列 140、资源抢夺解决方案 141、dispatch_barrier_async的作用是什么？ 142、在多线程Core Data中，NSC,MOC,NSObjectModel哪些需要在线程中创建或者传递？你是用什么策越来实现的？ 143、+(void)load与 +(void)initialize区别load 和 initialize方法的区别 144、http的post与区别与联系，实践中如何选择它们？ 145、说说关于UDP/TCP的区别？ 146、http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? 147、HTTP请求常用的几种方式 148、block （1）使用block时什么情况会发生引用循环，如何解决？ （2）在block内如何修改block外部变量？ （3）Block &amp; MRC-Block （4）什么是block （5）block 实现原理 （6）关于block （7）使用block和使用delegate完成委托模式有什么优点 （8）多线程与block （9）谈谈对Block 的理解?并写出一个使用Block执行UIVew动画? （10）写出上面代码的Block的定义（接上题） 149、Weak、strong、copy、assign 使用 （1）什么情况使用 weak 关键字，相比 assign 有什么不同？ （2）怎么用 copy 关键字？ （3）weak &amp; strong （4）这个写法会出什么问题： @property (copy) NSMutableArray *array （5） 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ （6） @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 （7）ivar、getter、setter 是如何生成并添加到这个类中的? （8）用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ （9）@protocol 和 category 中如何使用 @property （10）runtime如何通过selector找到对应的IMP地址？ （11）retain和copy区别 （12）copy和strong的使用？ （13）NSString和NSMutableString，前者线程安全，后者线程不安全。 （14）readwrite，readonly，assign，retain，copy，weak ,strong,nonatomic 属性的作用 150、OC与JS的交互（iOS与H5混编） TableView性能优化 UITableView核心思想 UITableView的优化主要从三个方面入手： 151、TableView为什么会卡？ 152、UITableView （1）UITableView最核心的思想 （2）定义高度 （3）自定义高度原理 （4）老生常谈之UITableView的性能优化 （5）cell高度的计算 （5.1）定高的cell和动态高度的cell （6）TableView渲染 （7）减少视图的数目 （8）减少多余的绘制操作 （9）不要给cell动态添加subView （10）异步化UI，不要阻塞主线程 （11）滑动时按需加载对应的内容 （12）离屏渲染的问题 （13）离屏渲染优化方案 153、环信SDK使用 154、蓝牙 155、在iPhone应用中如何保存数据? 156、什么是coredata? 157、 什么是NSManagedObject模型? 158、什么是NSManagedobjectContext? 159、 iOS平台怎么做数据的持久化?coredata 和sqlite有无必然联系？coredata是一个关系型数据库吗？ 160、CoreData &amp; SQLite3 161、数据存储 （1）数据存储技术 （1.1）数据存储的几种方式 （1.2）各自特点（面试考点） （1.3）偏好设置（面试考点） （1.4）归档（面试考点） （2）数据库技术（SQLite&amp;CoreData） 162、Objective-C堆和栈的区别？ 163、内存泄露 &amp; 内存溢出 164、堆 &amp; 栈 （1）堆栈空间分配区别 （2）堆栈缓存方式区别 （3）堆栈数据结构区别 165、内存管理 （1）内存区域 （1.1）堆和栈的区别 （1.2）iOS内存区域 （2）字符串的内存管理 （3）你是如何优化内存管理 （4）循环引用 （5）autorelease的使用 （5.1）工厂方法为什么不释放对象 （5.2）ARC下autorelease的使用场景 （5.3）自动释放池如何工作 （5.4）避免内存峰值 （5.5）ARC和MRC的混用 （5.6）NSTimer的内存管理 （5.7）ARC的实现原理 166、Runloop 167、fmmpeg框架 168、fmdb框架 169、320框架 170、UIKit和CoreAnimation和CoreGraphics的关系是什么？在开发中是否使用过CoreAnimation和CoreGraphics? 171、trasform 172、点讲动画和layer ,view的区别 173、图层与视图 174、平行的层级关系 175、图层的能力 176、使用图层 177、核心绘图 （1）View和layer的区别 （2）new和alloc init的区别 178、动画 179、UICollectionView （1）何实现瀑布流,流水布局 （2）和UITableView的使用区别 180、UIImage 181、webview 182、描述九宫格算法 183、实现图片轮播图 184、iOS网络框架 185、网络 （1）网络基础 （2）网络传输 （3）AFN 186、AFNetworking &amp; ASIHttpRequest &amp; MKNetWorking （1）底层实现 （2）对服务器返回的数据处理 （3）监听请求过程 （4）在文件下载和文件上传的使用难易度 （5）网络监控 （6）ASI提供的其他实用功能 （7）MKNetworkKit 187、性能优化 188、算法","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-003","slug":"iOS面试题-003","date":"2020-01-16T08:05:35.573Z","updated":"2020-01-20T01:45:21.179Z","comments":true,"path":"2020/01/16/iOS面试题-003/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-003/","excerpt":"","text":"一、UI视图括事件传递视图响应UI布局UI绘制UITableview重用机制的理解等基本技术点离屏渲染流式页面的性能优化异步绘制UI渲染机制Objective-C语言KVOKVC分类扩展关联对象NSNotification属性关键字三、Runtime对象类对象原类对象消息传递机制消息转发流程Method-SwizzlingISA-swizzling动态方法解析动态添加方法四、内存管理weak自动置nilARCMRC自动释放池的实现原理循环引用引用计数管理五、Block截获变量特性__Block关键字Block的本质Block的内存管理循环引用六、多线程NSOperation&amp;NSOperationQueue ### NSThreadGCDNSLock递归锁自旋锁条件锁七、RunLoopRunLoop为什么会有事做事没事休息，系统是怎样实现的怎样实现一个常驻线程RunLoop和线程的关系是怎样八、网络HTTP相关的中间人攻击HTTPS的连接建立流程对称加密非对称加密DNS劫持TCP的滑动窗口协议可靠传输是怎样保证的TCP的慢启动特点Session/Cookie的区别九、设计模式软件设计原则责任链适配器桥接命令单例策略模式十、架构/框架怎样设计图片缓存框架网络框架客户端的整体架构怎样实现常见的解耦方式有哪些","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-002","slug":"iOS面试题-002","date":"2020-01-16T08:05:31.117Z","updated":"2020-01-20T01:45:29.234Z","comments":true,"path":"2020/01/16/iOS面试题-002/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-002/","excerpt":"","text":"架构模式,编程思想,设计模式1、架构模式 MVC: MVC即Model-VIew-Controller。MVC模式致力于关注点的切分，这意味着model和controller的逻辑是不与用户界面（View）挂钩的。Model层代表了描述业务逻辑和数据的一系列类的集合。它也定义了数据修改和操作的业务规则。View代表了UI组件，像UIView，UIButton，UITableView等。他只负责展示从controller接收到的数据。因此，维护和测试程序变得更加简单容易。然而在Cocoa的MVC模式中Controller经常被混杂在View的生命周期中，因此很难说View和ViewController是分离的，这也往往驱使人们写出臃肿的视图控制器，尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了。View的最大的任务就是向Controller传递用户动作事件。ViewController不再承担一切代理和数据源的职责，通常只负责一些分发和取消网络请求以及一些其他的任务。当在进行单元测试的时候你会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难。Cocoa MVC看来并不是我们定义中理想的架构模式。 MVVM: 即Model-View-View Model。这个模式提供对View和View Model的双向数据绑定。这使得View Model的状态改变可以自动传递给View。典型的情况是，View Model通过使用obsever模式（观察者模式）来将View Model的变化通知给model。View Model负责暴漏方法，命令，其他属性来操作VIew的状态，组装model作为View动作的结果，并且触发View自己的事件。它和MVP模式看起来非常像:MVVM将ViewController视作View,View和Model之间没有紧密的联系。在使用MVVM模式时，自然而然会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM模式的特点。但是使用这个框架有个难以忽略的事实：当你刚开始使用ReactiveCoca的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，当你试图查看函数调用栈时你可能会喊：“天哪，好深的函数调用栈“！调试出这个bug可能会花费大量的时间。MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强——符合我们理想中好架构模式的定义。 MVP: 这个模式把Presenter换成Controller就和MVC非常相像了。这个设计模式把应用程序分成了3个主要方面：Model、View和Presenter,其中的Model和View与MVC模中的角色相同。Presenter负责处理View背后所有的UI事件。它通过View接收用户输入，之后利用Model来处理用户的数据，最后把结果返回给View。与View和Controller不同，View和Presenter之间是完全解耦的，他们通过接口来交互。另外，presenter不像controller处理进入的请求。这不是正解决了Cocoa MVC中ViewController和View的耦合问题吗？就MVP模式而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定。但是这也意味着我们将最主要的任务划分到Presenter和Model，而View的功能较少——各个实体任务量分配不均衡。 Viper架构模式: 由视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 组成。视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。交互器：包含由用例指定的业务逻辑。展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。实体：包含交互器要使用的基本模型对象。路由：包含用来描述屏幕显示和显示顺序的导航逻辑。Viper将应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互。Viper的不同层提供了明确的程序逻辑以及导航控制代码来避免视图控制器太过于臃肿的问题，利用 Viper ，视图控制器可以简洁高效，意义明确地控制视图。视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。毫无疑问，Viper在划分责任的粒度上比以上几种模式都要优秀，自然而然就有更好的可测试性，当然你必须为很小功能的类写出大量的接口。如果是在大型项目中使用Viper，Viper架构模式符合我们理想中好架构模式的定义。 2、编程思想面向对象编程思想 封装在面向对象的语言中，对象、类、方法都是一种封装，对象是封装的最基本单位。类的封装体现在每个类都有.h和.m两个文件，将定义与实现分开，.h声明（用户可见的外部接口），.m实现（用户不可见的内部实现）。方法的封装，是最常见的，每个方法中封装了一个小的功能，这是单一职责的很好体现，第三方框架和代码也是一种封装。封装使程序的结构更加清晰，将实现的信息封装隐藏，用的时候直接调用封装好的方法或类，提高效率。此外，可以减少程序间的相互依赖。 继承子类自动共享父类非私有数据结构和方法的机制，是类之间的一种关系。继承是面向对象语言特有的，面向过程的语言不具有继承特性，OC是单继承。继承提供了类的规范等级结构，使公共的特性能够共享，提高的软件的重用性。类的继承性使所建的软件具有开发性、可扩充性，简化了对象、类的创建工作量，提高了代码的重用性。 多态用父类指针指向子类的对象。通过不同的对象调用相同的名称的方法，却产生不同的结果。通过父类指针得到的几个对象，都调用了父类中某个方法，但实际上在运行的时候，是执行的自己真实类中的方法。多态增强了软件的灵活性和重用性。 链式编程思想 将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值代表：Masonry框架 响应式编程思想 不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。 代表：KVO运用。 函数式编程思想 是把操作尽量写成一系列嵌套的函数或者方法调用。函数式编程本质:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理函数式编程特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）代表：ReactiveCocoa。 底层进阶,深层理解三方框架要知其然,而知其所以然1、AFNetworkingAFNetworking有5个模块： NSURLSession 网络请求模块 AFHTTPSessionManager继承自AFURLSessionManagerGETPOSTDELETEPUTPATCH文件上传AFURLSessionManager管理所有的请求，设置了NSURLSessionTaskDelegate, NSRULSessionDataDelegate,NSURLSessionDownloadDelegate实现证书合法性校验，数据传输进度检测，数据请求成功/失败的回调。使用Runtime用af_suspend替换 suspend, 用af_resume替换了resume 当调用者两个方法时往上层发送通知 AFNetworkingTaskDidSuspendNotification AFNetworkingTaskDidResumeNotification请求服务器数据上传数据多线程下载数据 Reachability 监测网络状态模块 AFNetworkReachabilityManager Security 安全策略模块 AFSecurityPolicy:iOS项目将服务器端的证书保存导入到项目中，AFN根据项目中的服务器证书来进行验证，验证服务器，保证访问服务器的安全性。验证证书的模式有三种：AFSSLPinningModeNone 不验证AFSSLPinningModePublicKey 只验证公钥AFSSLPinningModeCertificate 验证证书的所有内容 Serialization 序列化 AFURLRequestSerializationAFURLResponseSerialization UIKit UI相关的一些类目原理概述 AFNetworking 是对NSURLSessionTask的封装。AFHTTPSessionManager继承AFURLSessionManager对网络请求进行管理，使用AFURLRequestSerialization对网络请求进行封装，使用AFURLResponseSerialization对响应体进行处理，使用AFSecurityPolicy对服务器证书进行校验。支持HTTPS协议，支持本地证书和服务器证书进行对比验证。AFN数据传递主要使用block和notifacation方式。 请求过程 GET/POST等方法调用抽象的请求方法，指明请求参数，调用全能数据请求方法，指明数据请求方式和参数。对请求进行序列化，如果序列化失败，就执行failure block。为每一个NSURLSessionDataTask的dataTask增加代理。对每一个NSURLSessionDataTask的dataTask增加代理的具体实现，对dataTask设置请求之后的回调delegate和处理block。 2、SDWebImage缓存机制SDImageCache在SDImageCache，图片采用了二级缓存策略。图片缓存时，在内存有缓存，在磁盘中也有缓存。其中，内存缓存是通过NSCache实现的。 缓存步骤 将图片缓存在内存中 判断图片的格式是png或是jpeg，将图片转化为NSData数据 如果是在mac_os系统中，直接将图片转化为NSBitmapImageRep数据 获取图片的存储路径，其中图片的文件名是通过传入的key经过md5加密后获得的。 将图片存储磁盘中 获取图片步骤 先在内存缓存中寻找 如果内存中找不到图片，则在默认的磁盘根目录中寻找，如果还是找不到，再从自定义的只读目录路径中寻找 获取图片数据后，将图片数据从NSData转化为UIImage,转化是要根据图片的类型进行转化。 默认对图片进行解压缩，生成位图图片。 将位图图片返回。 图片解压缩步骤 判断图片是否是动态图片，如果是，则不能解压缩 判断图片是否是透明的，如果是，则不能解压缩 判断图片的颜色空间模型是不是RGB，如果不是，不能解压缩 根据图片的大小创建一个上下文 将图片绘制在上下文中。 从上下文中读取一个不透明的位图图像，该图像就是解压缩后的图像 将位图图像返回 对图片进行缩放步骤 如果是普通图像，则直接进行缩放 如果是动态图像，则要对图像中的每一张图像都进行缩放磁盘缓存清理步骤 获取磁盘中图片的最后修改日期。(为了减少磁盘和内存数据交换，读取是并不将整个文件读入内存，仅仅将文件的一些属性读入内存中，包括最后修改日期，该文件是否为文件夹，文件的大小和对应文件的文件路径) 根据最后修改日期将图片进行分类，将那些已经存放超过最长存放时间的文件存储在删除数组，其他的文件信息存储在另一个字典中。并计算除去要删除的文件之外的所有文件大小 根据删除数组中的文件路径，将对应的文件删除。 判断剩下的文件大小是否超过用户现在的磁盘最大容量。 如果超过，则将剩余的文件进行安修改时间进行升序排列，然后删除修改时间最早的文件，直到甚剩余文件大小小于最大磁盘容量的一半。 图片缓存清理时机 当系统发出内存不足通知时，会将内存中的所有图片缓存都删除掉。 当程序进入后台时，会对磁盘的文件数据进行清理。 当收到程序关闭通知时，会对磁盘中的文件数据进行清理。 多线程与网络内存管理,性能优化1、内存管理2、性能优化逻辑优化 代码封装优化 代码执行效率优化界面优化 离屏渲染优化 shouldRasterize（光栅化） mask（遮罩层） shadows（阴影） EdgeAnntialiasing（抗锯齿） GroupOpacity（不透明） 复杂形状比如圆角等 渐变 界面加载优化 数据结构和算法音视频方向逆向方向","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-001","slug":"iOS面试题-001","date":"2020-01-16T08:05:26.851Z","updated":"2020-01-20T01:45:34.466Z","comments":true,"path":"2020/01/16/iOS面试题-001/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-001/","excerpt":"","text":"基础1. 属性修饰词nonatomic非原子性访问，多线程并发访问会提高性能。 atomic:原子性访问。 strongARC时中使用，相当于retain。 weak相当于assign，可以把对应的指针变量置为nil。 assgin不会使引用计数加1，也就是直接赋值。 copy建立一个索引计数为1的对象，在赋值时使用传入值的一份拷贝。 retain会使引用计数加1。 readonly此标记说明属性会被当成读写的，这也是默认属性。 readwrite此标记说明属性只可以读，也就是不能设置，可以获取。 问题：（1）什么情况使用 weak 关键字？相比 assign 有什么不同? 使用 协议声明使用weak IBOutlet 使用weak weak 和 assign 的不同点: weak 策略在属性所指的对象遭到摧毁时,系统会将 weak 修饰的属性对象的指针指向 nil,在 OC 给 nil 发消息是不会有什么问题的;如果使用 assign 策略在属性所指的对象遭到摧毁时,属性对象指针还指向原来的对象,由于对象已经被销毁,这时候就产生了野指针,如果这时候在给此对象发送消息,很容造成程序奔溃assigin 可以用于修饰非 OC 对象,而 weak 必须用于 OC 对象。 （2）使用 atomic 一定是线程安全的吗? 不是,atomic 的本意是指属性的存取方法是线程安全的,并不保证整个对象是线程安全的。 例如： 声明一个 NSMutableArray 的原子属性 stuff,此时 self.stuff 和 self.stuff =othersulf 都是线程安全的。但是,使用[self.stuff objectAtIndex:index]就不是线程安全的,需要用互斥锁来保证线程安全性。 （3）@synthesize 和 @dynamic 分别有什么作用 @property 有两个对应的词,一个是@synthesize,一个是@dynamic。如果@synthesize 和@dynamic 都没写,那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可) 假如一个属性被声明为@dynamic var；然后你没有提供@setter 方法和@getter 方法,编译的时候没问题,但是当程序运行到 instance.var = someVar,由于缺 setter方法会导致程序崩溃;或者当运行到 someVar = instance.var 时,由于缺 getter 方法同样会导致崩溃。 （4）ARC 下,不显式指定任何属性关键字时,默认的关键字都有哪些? 基本数据： atomic,readwrite,assign 普通的 OC 对象: atomic,readwrite,strong （5）用@property 声明的 NSString(或 NSArray,NSDictionary)经常使用 copy 关键字,为什么?如果改用 strong 关键字,可能造成什么问题? 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是 strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. （6）这个写法会出什么问题: @property(copy)NSMutableArray *array; 因为 copy 策略拷贝出来的是一个不可变对象,然而却把它当成可变对象使用,很容易造成程序奔溃这里还有一个问题,该属性使用了同步锁,会在创建时生成一些额外的代码用于帮助编写多线程程序,这会带来性能问题,通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销,在 iOS 开发中应该使用 nonatomic 替代 atomic. （7）如何让自定义类可以用 copy 修饰符?如何重写带 copy 关键字的 setter? 若想令自己所写的对象具有拷贝功能,则需实现 NSCopying 协议。 1234567&#x2F;&#x2F; 实现不可变版本拷贝- (id)copyWithZone:(NSZone *)zone; &#x2F;&#x2F; 实现可变版本拷贝- (id)mutableCopyWithZone:(NSZone *)zone;&#x2F;&#x2F; 重写带 copy 关键字的 setter- (void)setName:(NSString *)name &#123; _name &#x3D; [name copy];&#125; 2. 我们说的Objective-C是动态运行时语言是什么意思？ 动态类型。 如id类型。实际上静态类型因为其固定性和可预知性而使用得更加广泛。静态类型是强类型，而动态类型属于弱类型。运行时决定接收者。 动态绑定。让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。 动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。 3. 讲一下MVC和MVVM，MVP？ MVC: MVC即Model-VIew-Controller。MVC模式致力于关注点的切分，这意味着model和controller的逻辑是不与用户界面（View）挂钩的。Model层代表了描述业务逻辑和数据的一系列类的集合。它也定义了数据修改和操作的业务规则。View代表了UI组件，像UIView，UIButton，UITableView等。他只负责展示从controller接收到的数据。因此，维护和测试程序变得更加简单容易。然而在Cocoa的MVC模式中Controller经常被混杂在View的生命周期中，因此很难说View和ViewController是分离的，这也往往驱使人们写出臃肿的视图控制器，尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了。View的最大的任务就是向Controller传递用户动作事件。ViewController不再承担一切代理和数据源的职责，通常只负责一些分发和取消网络请求以及一些其他的任务。当在进行单元测试的时候你会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难。Cocoa MVC看来并不是我们定义中理想的架构模式。 MVVM: 即Model-View-View Model。这个模式提供对View和View Model的双向数据绑定。这使得View Model的状态改变可以自动传递给View。典型的情况是，View Model通过使用obsever模式（观察者模式）来将View Model的变化通知给model。View Model负责暴漏方法，命令，其他属性来操作VIew的状态，组装model作为View动作的结果，并且触发View自己的事件。它和MVP模式看起来非常像:MVVM将ViewController视作View,View和Model之间没有紧密的联系。在使用MVVM模式时，自然而然会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM模式的特点。但是使用这个框架有个难以忽略的事实：当你刚开始使用ReactiveCoca的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，当你试图查看函数调用栈时你可能会喊：“天哪，好深的函数调用栈“！调试出这个bug可能会花费大量的时间。MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强——符合我们理想中好架构模式的定义。 MVP: 这个模式把Presenter换成Controller就和MVC非常相像了。这个设计模式把应用程序分成了3个主要方面：Model、View和Presenter,其中的Model和View与MVC模中的角色相同。Presenter负责处理View背后所有的UI事件。它通过View接收用户输入，之后利用Model来处理用户的数据，最后把结果返回给View。与View和Controller不同，View和Presenter之间是完全解耦的，他们通过接口来交互。另外，presenter不像controller处理进入的请求。这不是正解决了Cocoa MVC中ViewController和View的耦合问题吗？就MVP模式而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定。但是这也意味着我们将最主要的任务划分到Presenter和Model，而View的功能较少——各个实体任务量分配不均衡。 4. 为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别? 为什么代理要用weak? 防止循环引用。例如View有一个协议，需要一个代理实现回调。一个Controller添加这个View，并且遵守协议，成为View的代理。如果不用week，用strong，Controller -&gt;View -&gt; delegate -&gt; Controller，就循环引用了。 代理的delegate和dataSource有什么区别？ delegate偏重于与用户交互的回调，有那些方法可以供我使用，例如UITableviewDelegate；dataSource偏重于数据的回调，view里面有什么东西，属性都是什么，例如UITableviewDatasource； block和代理的区别? 代理和block的共同特性是回调机制，不同的是，代理的方法比较多，比较分散。使用block的代码比较集中统一。 5. 属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？ @property = ivar + getter + setter; (实例变量+get方法+ set方法，也就是说使用@property系统会自动生成setter和getter方法;) @synthesize propertyName = _propertyName; (这行代码会创造一个带下划线前缀的实例变量名，同时使用这个属性生成getter 和 setter 方法。) 禁止@synthesize:如果某属性已经在某处实现了自己的 setter/getter ,可以使用 @dynamic 来阻止 @synthesize 自动生成新的 setter/getter 覆盖。 6. 属性的默认关键字是什么？ 基本类型 @property (atomic, assign) 对象类型 @property (atomic, strong) 7. NSString为什么要用copy关键字，如果用strong会有什么问题？（注意：这里没有说用strong就一定不行。使用copy和strong是看情况而定的） 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. 8. 如何令自己所写的对象具有拷贝功能? 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议。该协议只有一个方法: - (id)copyWithZone:(NSZone *)zone; 9. 简述kvo、kvc、Delegate他们之间的区别？ KVO（Key-Value- Observing）：一对多, 观察者模式, 是键值监听,键值观察机制, KVO的本质是当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以 isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。 KVC(Key-Value-Coding)内部的实现：是键值编码, 一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环 境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。 Delegate: 通常发送者和接收者的关系是直接的一对一的关系。代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。 Notification: 观察者模式, 通常发送者和接收者的关系是间接的多对多关系。 消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。 (1) 效率肯定是delegate比NSNotification高。 (2) delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个notification后就什么都不管了也不会等待接受者的反应。 10. include与#import的区别？#import与@class的区别？ #import指令是Object-C针对@include的改进版本，能确保引用的文件只会被引用一次，不会陷入递归包含的问题中； @import与@class的区别： #import会链入该头文件的全部信息，包括实体变量和方法等；二@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类如何定义的，暂时不用考虑。在头文件中，一般只需要知道被引用的类的名称就可以了，不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称；而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import类包含这个被引用类的头文件。@class还可以解决循环包含的问题 #import&lt;&gt;跟#import””的区别： #import&lt;&gt;用来包含系统自带的文件，#import””用来包含自定义的文件 11. nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？ nonatomic和atomic的区别 nonatomic和atomic用来决定编译器生成的getter和setter操作是否为原子操作。 atomic是绝对的线程安全么？ atomic不是绝对的线程安全。atomic的本意是指属性的存取方法是线程安全的，并不保证整个对象是线程安全的。如：声明一个NSMutableArray的原子属性stuff，此时self.stuff 和 self.stuff = otherstuff都是线程安全的。但是使用[self.stuff objectAtIndex:index]就不是线程安全的。需要用互斥锁来保证线程安全性。 如何实现线程安全 使用线程锁 12. UICollectionView自定义layout如何实现？ -(void)prepareLayout; 方法重写，并设置初始样式 - (CGRect)collectionViewContentSize; 方法重写， 并使用它来返回CollectionView视图内容的宽高， 四个方法来确定布局信息 - (NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; - (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath; - (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath; - (UICollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString*)elementKind atIndexPath:(NSIndexPath *)indexPath; - (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;如果返回YES，那么collectionView显示的范围发生改变时，就会重新刷新布局 13. 进程和线程的区别？同步异步的区别？并行和并发的区别？ 进程和线程的区别 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 同步和异步的区别 同步(synchronous)：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。 异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 并行和并发的区别 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这个几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。 互斥：进程间相互排斥的使用临界资源的现象 同步：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步说明就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。 并行(parallelism)：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。 14. 线程间通信？ NSThread - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait; CGD dispatch_async(dispatch_get_global_queue(0, 0), ^{…}); 15. GCD的一些常用的函数？（group，barrier，信号量，线程同步）16. 如何访问并修改一个类的私有属性？ KVO + KVC runtime (class_copyIvarList, object_setIvar) 17. 数据持久化的几个方案（fmdb用没用过） CoreData Sqlite 3 FMDB （Sqlite 3封装） 钥匙串 NSUserDefualt NSKeyedArchiver NSCache 沙盒 18. 说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566671.当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电- (void)applicationWillResignActive:(UIApplication *)application &#123; NSLog(@&quot;应用程序将要进入非活动状态，即将进入后台&quot;);&#125;2.应用程序已经进入后台运行- (void)applicationDidEnterBackground:(UIApplication *)application &#123; NSLog(@&quot;如果应用程序支持后台运行，则应用程序已经进入后台运行&quot;); &#x2F;&#x2F;如果需要退出后台,则在这里加上:exit(0);&#125;3.应用程序将要进入活动状态执行- (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@&quot;应用程序将要进入活动状态，即将进入前台运行&quot;);&#125;4.应用程序已经进入活动状态- (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@&quot;应用程序已进入前台，处于活动状态&quot;);&#125;5.应用程序将要退出，通常用于保存数据和一些退出前的清理工作- (void)applicationWillTerminate:(UIApplication *)application &#123; NSLog(@&quot;应用程序将要退出，通常用于保存数据和一些退出前的清理工作&quot;);&#125;6.当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作，防止程序被终止- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123; NSLog(@&quot;系统内存不足，需要进行清理工作&quot;);&#125;7.当系统时间发生改变时执行- (void)applicationSignificantTimeChange:(UIApplication *)application &#123; NSLog(@&quot;当系统时间发生改变时执行&quot;);&#125;8.推送消息时，获取设备的tokenid- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123; NSLog(@&quot;%@&quot;,deviceToken);&#125;9.tokenid获取失败时,做相应处理- (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123; NSLog(@&quot;fail to register for remoteNotifications: %@&quot;, [err description]);&#125;10.接收到推送消息处理- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123; &#x2F;&#x2F;设置icon上的标记数字设置为0； &#x2F;&#x2F;application.applicationIconBadgeNumber &#x3D; 0; NSLog(@&quot;%@&quot;,userInfo);&#125;11.当程序载入后执行- (void)applicationDidFinishLaunching:(UIApplication *)application &#123; NSLog(@&quot;当程序载入后执行&quot;);&#125; 19. NSCache优于NSDictionary的几点？ NSCache 是一个容器类，类似于NSDIctionary,通过key-value 形式存储和查询值，用于临时存储对象。 注意一点它和NSDictionary区别就是，NSCache 中的key不必实现copy，NSDictionary中的key必须实现copy NSCache中存储的对象也不必实现NSCoding协议，因为毕竟是临时存储，类似于内存缓存，程序退出后就被释放了。 20. 知不知道Designated Initializer？使用它的时候有什么需要注意的问题？21. 实现description方法能取到什么效果？ 可以输出对象内部的一些成变量的值 22. objc使用什么机制管理对象内存？ ARC (automatic reference counting)MRC (manual retain-release) Block block的实质是什么？一共有几种block？都是什么情况下生成的？ 使用系统的某些block api，是否考虑引用循环问题？ 谈谈block的理解？并写出一个使用block执行UIVew动画？ Runtime runtime如何实现weak属性？ runtime如何通过selector找到对应的IMP地址？ 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ runtime如何实现weak变量的自动置nil？ 在开发中如何使用runtime？什么应用场景？ 类结构 isa指针？（对象的isa，类对象的isa，元类的isa都要说） 类方法和实例方法有什么区别？ 介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？ 运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？ objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体） 高级 UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染） 有没有用过运行时，用它都能做什么？（交换方法，创建类，给新创建的类增加方法，改变isa指针） 看过哪些第三方框架的源码？都是如何实现的？（如果没有，问一下多图下载的设计） SDWebImage的缓存策略？ AFN为什么添加一条常驻线程？ KVO的使用？实现原理？（为什么要创建子类来实现） KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar） iOS的沙盒目录结构 AppName.app Documents Library –&gt; 3.1 Preferences 3.2 Caches tmp","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS面试题-005","slug":"iOS面试题-005","date":"2020-01-16T08:05:23.295Z","updated":"2020-01-20T01:43:05.285Z","comments":true,"path":"2020/01/16/iOS面试题-005/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-005/","excerpt":"","text":"基础面试题一、两种拷贝的差别 浅拷贝：指针（地址）拷贝，不会产生新对象 深拷贝：内容拷贝，会产生新对象 二、Category和Extension的差别 分类是有名称的，类扩展没有名称 分类只能扩充方法、不能扩充成员变量（需要利用RunTime重写set、get方法）；类扩展可以扩充方法和成员变量 类扩展一般就写在.m文件中，用来扩充私有的方法和成员变量（属性） 三、KVO和KVC的差别 KVC是键值编码，可以通过一个字符串的key（属性名）修改对象的属性值 KVO是键值监听，可以监听一个对象属性值的改变 四、property属性介绍 copy是创建一个新对象，两个对象内容相同，旧对象没有变化。新的对象retain为1，与旧有对象的引用计数不变。旧对象发生改变不影响新对象，copy减少对象对上下文的依赖。NSString、Block等类型 retain属性表示两个对象地址相同（建立一个指针，指针拷贝），内容相同，这个对象的retain值+1。两个对象要改变就一起改变。 weak其实类似于assign，叫弱引用，也是不增加引用计数。一般只有在防止循环引用时使用，比如父类引用了子类，子类又去引用父类。IBOutlet、Delegate一般用的就是weak，这是因为它们会在类外部被调用，防止循环引用。 assign：非OC对象类型， 基本数据类型（两个对象相互引用的时候，一端用retain， 一端用assign） strong就类似与retain了，叫强引用，会增加引用计数，类内部使用的属性一般都是strong修饰的，现在ARC已经基本替代了MRC，所以我们最常见的就是strong了。retain：OC对象类型 nonatomic 在修饰属性时，我们往往还会加一个nonatomic，这又是什么呢？它的名字叫非原子访问。对应的有atomic，是原子性的访问。我们知道，在使用多线程时为了避免在写操作时同时进行写导致问题，经常会对要写的对象进行加锁，也就是同一时刻只允许一个线程去操作它。如果一个属性是由atomic修饰的，那么系统就会进行线程保护，防止多个写操作同时进行。这有好处，但也有坏处，那就是消耗系统资源，所以对于iPhone这种小型设备，如果不是进行多线程的写操作，就可以使用nonatomic，取消线程保护，提高性能。 五、代理，通知，和block的区别 通知：NotificationCenter 通知中心：“一对多”，在APP中，很多控制器都需要知道一个事件，应该用通知； 代理：一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理；代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败 block：delegate一样，一般都是“一对一”之间通信交互，相比代理block有以下特点： 1、写法更简练，不需要写protocol、函数等等 2、block注重结果的传输：比如对于一个事件，只想知道成功或者失败，并不需要知道进行了多少或者额外的一些信息 3、block需要注意防止循环引用 六、网络 HTTP（HyperText Transfer Protocol、超文本传输协议)是OSI七层中应用层的协议。HTTP 是基于 TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 TCP（Transmission Control Protocol，传输控制协议）是OSI七层中传输层的协议。TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求 UDP (User Datagram Protocol,用户数据报协议)是OSI参考模型中无连接的传输层协议.UDP用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 socket是对TCP或者UDP协议的封装和实现，socket并不是协议，差不多每一种语言都实现了对TCP和UDP封装和实现的Socket代码库，方便开发程序员使用，socket是对TCP或者UDP协议的封装和实现，这样我就可以基于你所使用语言的Socket来实现更多的功能，有基于Socket TCP的HTTP请求，有基于Socket TCP长连接的消息推送，也可以基于Socket TCP/UDP自定义一套自己的通信协议。（5）关系—&gt; HTTP基于TCP，HTTP请求需要使用Socket TCP来完成。 七、多线程 进程：进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。 pthread：C语言编程，手动管理线程周期，使用难度大，不常用。 NSThread：OC语言编程，手动管理线程周期，面向对象，偶尔使用 GCD：C语言编程，支持多核，自动管理线程周期，常用 NSOperation：OC语言编程，基于GCD，比GCD新增新功能，常用 线程锁：线程死锁有“互等”，然后卡住的意思,也由于和同/异步处理顺序，线程的等待导致队列加入的顺序与队列的FIFO原则(先进先出）冲突引起。 并行：并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。 串行：表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。 并发：并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。 队列：不管是串行队列（SerialQueue）还是并行队列（ConcurrencyQueue），都是FIFO队列。也就意味着，任务一定是一个一个地，按照先进先出的顺序来调度。 同步：就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。 异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果。","categories":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS多线程-NSOperation","slug":"iOS多线程-NSOperation","date":"2020-01-16T08:05:14.617Z","updated":"2020-01-20T01:45:50.766Z","comments":true,"path":"2020/01/16/iOS多线程-NSOperation/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-NSOperation/","excerpt":"","text":"1.NSOperation、NSOperationQueue 简介NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。 为什么要使用 NSOperation、NSOperationQueue？ 可添加完成的代码块，在操作完成后执行。 添加操作之间的依赖关系，方便的控制执行顺序。 设定操作执行的优先级。 可以很方便的取消一个操作的执行。 使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 2. NSOperation、NSOperationQueue 操作和操作队列既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。 操作（Operation）： 执行操作的意思，换句话说就是你在线程中执行的那段代码。 在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。操作队列（Operation Queues）： 这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 3. NSOperation、NSOperationQueue 使用步骤NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。NSOperation 实现多线程的使用步骤分为三步： 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。创建队列：创建 NSOperationQueue 对象。将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。下面我们来学习下 NSOperation 和 NSOperationQueue 的基本使用。 4. NSOperation 和 NSOperationQueue 基本使用4.1 创建操作NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。 使用子类 NSInvocationOperation使用子类 NSBlockOperation自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。 4.1.1 使用子类 NSInvocationOperation123456789101112131415161718192021&#x2F;** * 使用子类 NSInvocationOperation *&#x2F;- (void)useInvocationOperation &#123; &#x2F;&#x2F; 1.创建 NSInvocationOperation 对象 NSInvocationOperation *op &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; &#x2F;&#x2F; 2.调用 start 方法开始执行操作 [op start];&#125;&#x2F;** * 任务1 *&#x2F;- (void)task1 &#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125;&#125; 输出结果： 可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。如果在其他线程中执行操作，则打印结果为其他线程。12&#x2F;&#x2F; 在其他线程使用子类 NSInvocationOperation[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil]; 输出结果： 可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。 下边再来看看 NSBlockOperation。 4.1.2 使用子类 NSBlockOperation12345678910111213141516&#x2F;** * 使用子类 NSBlockOperation *&#x2F;- (void)useBlockOperation &#123; &#x2F;&#x2F; 1.创建 NSBlockOperation 对象 NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 2.调用 start 方法开始执行操作 [op start];&#125; 输出结果： 可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。 但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;** * 使用子类 NSBlockOperation * 调用方法 AddExecutionBlock: *&#x2F;- (void)useBlockOperationAddExecutionBlock &#123; &#x2F;&#x2F; 1.创建 NSBlockOperation 对象 NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 2.添加额外的操作 [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 3.调用 start 方法开始执行操作 [op start];&#125; 输出结果： 可以看出：使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。 一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 4.1.3 使用自定义继承自 NSOperation 的子类如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。 先定义一个继承自 NSOperation 的子类，重写main方法。 12345678910111213141516171819202122&#x2F;&#x2F; YSCOperation.h 文件#import &lt;Foundation&#x2F;Foundation.h&gt;@interface YSCOperation : NSOperation@end&#x2F;&#x2F; YSCOperation.m 文件#import &quot;YSCOperation.h&quot;@implementation YSCOperation- (void)main &#123; if (!self.isCancelled) &#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#125; &#125;&#125;@end 然后使用的时候导入头文件YSCOperation.h。 123456789&#x2F;** * 使用自定义继承自 NSOperation 的子类 *&#x2F;- (void)useCustomOperation &#123; &#x2F;&#x2F; 1.创建 YSCOperation 对象 YSCOperation *op &#x3D; [[YSCOperation alloc] init]; &#x2F;&#x2F; 2.调用 start 方法开始执行操作 [op start];&#125; 输出结果： 可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。 下边我们来讲讲 NSOperationQueue 的创建。 4.2 创建队列NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列 凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）。12 &#x2F;&#x2F; 主队列获取方法NSOperationQueue *queue &#x3D; [NSOperationQueue mainQueue]; 自定义队列（非主队列） 添加到这种队列中的操作，就会自动放到子线程中执行。 同时包含了：串行、并发功能。12&#x2F;&#x2F; 自定义队列创建方法NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; 4.3 将操作加入到队列中上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。 那么我们需要将创建好的操作加入到队列中去。总共有两种方法： 1.- (void)addOperation:(NSOperation *)op; 需要先创建操作，再将创建好的操作加入到创建好的队列中去。12345678910111213141516171819202122232425262728293031323334&#x2F;** * 使用 addOperation: 将操作加入到操作队列中 *&#x2F;- (void)addOperationToQueue &#123; &#x2F;&#x2F; 1.创建队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 2.创建操作 &#x2F;&#x2F; 使用 NSInvocationOperation 创建操作1 NSInvocationOperation *op1 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; &#x2F;&#x2F; 使用 NSInvocationOperation 创建操作2 NSInvocationOperation *op2 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; &#x2F;&#x2F; 使用 NSBlockOperation 创建操作3 NSBlockOperation *op3 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; &#x2F;&#x2F; [op1 start] [queue addOperation:op2]; &#x2F;&#x2F; [op2 start] [queue addOperation:op3]; &#x2F;&#x2F; [op3 start]&#125; 输出结果： 可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行. 2.- (void)addOperationWithBlock:(void (^)(void))block; - 无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。 12345678910111213141516171819202122232425262728&#x2F;** * 使用 addOperationWithBlock: 将操作加入到操作队列中 *&#x2F;- (void)addOperationWithBlockToQueue &#123; &#x2F;&#x2F; 1.创建队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;];&#125; 输出结果： 可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。 5. NSOperationQueue 控制串行执行、并发执行之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？ 这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 最大并发操作数：maxConcurrentOperationCount maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。 maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;** * 设置 MaxConcurrentOperationCount（最大并发操作数） *&#x2F;- (void)setMaxConcurrentOperationCount &#123; &#x2F;&#x2F; 1.创建队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 2.设置最大并发操作数 queue.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 串行队列&#x2F;&#x2F; queue.maxConcurrentOperationCount &#x3D; 2; &#x2F;&#x2F; 并发队列&#x2F;&#x2F; queue.maxConcurrentOperationCount &#x3D; 8; &#x2F;&#x2F; 并发队列 &#x2F;&#x2F; 3.添加操作 [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;];&#125; 最大并发操作数为1 输出结果： 最大并发操作数为2 输出结果： 可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。 这样看来，是不是比 GCD 还要简单了许多？ 6. NSOperation 操作依赖NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。 (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。 如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下： 123456789101112131415161718192021222324252627282930&#x2F;** * 操作依赖 * 使用方法：addDependency: *&#x2F;- (void)addDependency &#123; &#x2F;&#x2F; 1.创建队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 2.创建操作 NSBlockOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 3.添加依赖 [op2 addDependency:op1]; &#x2F;&#x2F; 让op2 依赖于 op1，则先执行op1，在执行op2 &#x2F;&#x2F; 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125; 输出结果： 可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。 7. NSOperation 优先级NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。 12345678&#x2F;&#x2F; 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow &#x3D; -8L, NSOperationQueuePriorityLow &#x3D; -4L, NSOperationQueuePriorityNormal &#x3D; 0, NSOperationQueuePriorityHigh &#x3D; 4, NSOperationQueuePriorityVeryHigh &#x3D; 8&#125;; 上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 那么，什么样的操作才是进入就绪状态的操作呢？ 当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。 举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。 因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。 而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。 理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。 queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。 如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。 如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。 8. NSOperation、NSOperationQueue 线程间的通信在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。 1234567891011121314151617181920212223242526&#x2F;** * 线程间通信 *&#x2F;- (void)communication &#123; &#x2F;&#x2F; 1.创建队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc]init]; &#x2F;&#x2F; 2.添加操作 [queue addOperationWithBlock:^&#123; &#x2F;&#x2F; 异步进行耗时操作 for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#x2F;&#x2F; 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; &#x2F;&#x2F; 进行一些 UI 刷新等操作 for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#125;];&#125; 输出结果： 可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。 9. NSOperation、NSOperationQueue 线程同步和线程安全线程安全如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。 9.1 NSOperation、NSOperationQueue 非线程安全先来看看不考虑线程安全的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;** * 非线程安全：不使用 NSLock * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票 *&#x2F;- (void)initTicketStatusNotSave &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 self.ticketSurplusCount &#x3D; 50; &#x2F;&#x2F; 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue *queue1 &#x3D; [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 &#x3D; [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 3.创建卖票操作 op1 NSBlockOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketNotSafe]; &#125;]; &#x2F;&#x2F; 4.创建卖票操作 op2 NSBlockOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketNotSafe]; &#125;]; &#x2F;&#x2F; 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;&#x2F;** * 售卖火车票(非线程安全) *&#x2F;- (void)saleTicketNotSafe &#123; while (1) &#123; if (self.ticketSurplusCount &gt; 0) &#123; &#x2F;&#x2F;如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; &#125;&#125; 输出结果： 省略一部分结果图。。。 可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。 9.2 NSOperation、NSOperationQueue 线程安全线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。考虑线程安全的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#x2F;** * 线程安全：使用 NSLock 加锁 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票 *&#x2F;- (void)initTicketStatusSave &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 self.ticketSurplusCount &#x3D; 50; self.lock &#x3D; [[NSLock alloc] init]; &#x2F;&#x2F; 初始化 NSLock 对象 &#x2F;&#x2F; 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue *queue1 &#x3D; [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 &#x3D; [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 3.创建卖票操作 op1 NSBlockOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketSafe]; &#125;]; &#x2F;&#x2F; 4.创建卖票操作 op2 NSBlockOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketSafe]; &#125;]; &#x2F;&#x2F; 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;&#x2F;** * 售卖火车票(线程安全) *&#x2F;- (void)saleTicketSafe &#123; while (1) &#123; &#x2F;&#x2F; 加锁 [self.lock lock]; if (self.ticketSurplusCount &gt; 0) &#123; &#x2F;&#x2F;如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; &#x2F;&#x2F; 解锁 [self.lock unlock]; if (self.ticketSurplusCount &lt;&#x3D; 0) &#123; NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; &#125;&#125; 输出结果： 省略一部分结果图。。。 可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。 10. NSOperation、NSOperationQueue 常用属性和方法归纳10.1 NSOperation 常用属性和方法1、取消操作方法 -(void)cancel; 可取消操作，实质是标记 isCancelled 状态。 2、判断操作状态方法 -(BOOL)isFinished; 判断操作是否已经结束。 -(BOOL)isCancelled; 判断操作是否已经标记为取消。 -(BOOL)isExecuting; 判断操作是否正在在运行。 -(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。 3、操作同步 -(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。 -(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。 -(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 -(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 10.2 NSOperationQueue 常用属性和方法1、取消/暂停/恢复操作 -(void)cancelAllOperations; 可以取消队列的所有操作。 -(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。 -(void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。 2、操作同步 -(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。 3、添加/获取操作 -(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。 -(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 -(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。 -(NSUInteger)operationCount; 当前队列中的操作数。 4、获取队列 +(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。 -(id)mainQueue; 获取主队列。 注意： 这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}]},{"title":"iOS多线程-9种锁.md","slug":"iOS多线程-9种锁.md","date":"2020-01-16T08:05:04.041Z","updated":"2020-01-20T01:46:17.485Z","comments":true,"path":"2020/01/16/iOS多线程-9种锁.md/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-9%E7%A7%8D%E9%94%81.md/","excerpt":"","text":"1、dispatch_semaphore 自旋锁2、@synchronized 互斥锁3、NSLock 线程锁4、NSRecursiveLock 递归锁5、NSConditionLock 条件锁6、NSCondition 断言7、OSSpinLock 自旋锁8、pthread_mutex 互斥锁9、pthread_mutex(recursive) 互斥锁","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}]},{"title":"iOS动画-Transition转场动画","slug":"iOS动画-Transition转场动画","date":"2020-01-16T08:04:59.452Z","updated":"2020-01-20T01:46:50.400Z","comments":true,"path":"2020/01/16/iOS动画-Transition转场动画/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-Transition%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/","excerpt":"","text":"12345678910111213141516171819202122&#x2F;** * UIViewAnimationOptionTransitionNone &#x2F;&#x2F;没有效果 * UIViewAnimationOptionTransitionFlipFromLeft &#x2F;&#x2F;从左水平翻转 * UIViewAnimationOptionTransitionFlipFromRight &#x2F;&#x2F;从右水平翻转 * UIViewAnimationOptionTransitionCurlUp &#x2F;&#x2F;翻书上掀 * UIViewAnimationOptionTransitionCurlDown &#x2F;&#x2F;翻书下盖 * UIViewAnimationOptionTransitionCrossDissolve &#x2F;&#x2F;融合 * UIViewAnimationOptionTransitionFlipFromTop &#x2F;&#x2F;从上垂直翻转 * UIViewAnimationOptionTransitionFlipFromBottom &#x2F;&#x2F;从下垂直翻转 * *&#x2F;[UIView transitionWithView:UIApplication.sharedApplication.keyWindow duration:0.5 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^&#123; &#x2F;&#x2F; TODO: 页面跳转 &#125; completion:^(BOOL finished) &#123; &#125;];","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS动画-CATransition移动动画","slug":"iOS动画-CATransition移动动画","date":"2020-01-16T08:04:54.929Z","updated":"2020-01-20T01:46:59.109Z","comments":true,"path":"2020/01/16/iOS动画-CATransition移动动画/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-CATransition%E7%A7%BB%E5%8A%A8%E5%8A%A8%E7%94%BB/","excerpt":"","text":"12345678910111213141516171819&#x2F;** * UIViewAnimationTransitionNone &#x2F;&#x2F;没有效果 * UIViewAnimationTransitionFlipFromLeft &#x2F;&#x2F;从左水平翻转 * UIViewAnimationTransitionFlipFromRight &#x2F;&#x2F;从右水平翻转 * UIViewAnimationTransitionCurlUp &#x2F;&#x2F;翻书上掀 * UIViewAnimationTransitionCurlDown &#x2F;&#x2F;翻书下盖 * UIViewAnimationTransitionCrossDissolve &#x2F;&#x2F;融合 * UIViewAnimationTransitionFlipFromTop &#x2F;&#x2F;从上垂直翻转 * UIViewAnimationTransitionFlipFromBottom &#x2F;&#x2F;从下垂直翻转 * *&#x2F;[UIView beginAnimations:@&quot;animation&quot; context:nil];[UIView setAnimationDuration:1.0f];[UIView setAnimationTransition:UIViewAnimationTransitionNone forView:containerView cache:YES];[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];&#x2F;&#x2F; 交换层级关系[containerView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];[UIView commitAnimations];","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS动画-CATransition属性动画","slug":"iOS动画-CATransition属性动画","date":"2020-01-16T08:04:50.474Z","updated":"2020-01-20T01:47:06.262Z","comments":true,"path":"2020/01/16/iOS动画-CATransition属性动画/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-CATransition%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","excerpt":"","text":"私有方法 123456789101112131415161718192021222324252627&#x2F;* Common transition types. *&#x2F;&#x2F;** * cube &#x2F;&#x2F; 立方体旋转 * suckEffect &#x2F;&#x2F; 收缩动画 * oglFlip &#x2F;&#x2F; 翻转 * pageCurl &#x2F;&#x2F; 页面揭开 * pageUnCurl &#x2F;&#x2F; 放下页面 * cemeraIrisHollowOpen &#x2F;&#x2F; 镜头打开 * cameraIrisHollowClose &#x2F;&#x2F; 镜头关闭 *&#x2F;&#x2F;* Common transition subtypes. *&#x2F;&#x2F;** * kCATransitionFromRight * kCATransitionFromLeft * kCATransitionFromTop * kCATransitionFromBottom *&#x2F;CATransition *transition &#x3D; [CATransition animation];transition.duration &#x3D; 3;transition.type &#x3D; @&quot;oglFlip&quot;;transition.subtype &#x3D; kCATransitionFromTop;[containerView.layer addAnimation:transition forKey:nil];[containerView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS动画-CATransition反转动画","slug":"iOS动画-CATransition反转动画","date":"2020-01-16T08:04:46.019Z","updated":"2020-01-20T01:47:11.314Z","comments":true,"path":"2020/01/16/iOS动画-CATransition反转动画/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-CATransition%E5%8F%8D%E8%BD%AC%E5%8A%A8%E7%94%BB/","excerpt":"","text":"移动动画 123456789101112131415161718192021222324&#x2F;* Common transition types. *&#x2F;&#x2F;** * kCATransitionFade &#x2F;&#x2F; 渐变 * kCATransitionMoveIn &#x2F;&#x2F; 覆盖 * kCATransitionPush &#x2F;&#x2F; 推出 * kCATransitionReveal &#x2F;&#x2F; 揭开 *&#x2F;&#x2F;* Common transition subtypes. *&#x2F;&#x2F;** * kCATransitionFromRight * kCATransitionFromLeft * kCATransitionFromTop * kCATransitionFromBottom *&#x2F;CATransition *transition &#x3D; [CATransition animation];transition.duration &#x3D; 0.25;transition.type &#x3D; kCATransitionPush;transition.subtype &#x3D; kCATransitionFromRight;[containerView.layer addAnimation:transition forKey:nil];[containerView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS动画-CALayer的属性和使用(未完结)","slug":"iOS动画-CALayer的属性和使用(未完结)","date":"2020-01-16T08:04:40.787Z","updated":"2020-01-20T01:47:23.253Z","comments":true,"path":"2020/01/16/iOS动画-CALayer的属性和使用(未完结)/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-CALayer%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8(%E6%9C%AA%E5%AE%8C%E7%BB%93)/","excerpt":"","text":"一、CALayer的常用属性 @propertyCGPoint position;图层中心点的位置，类似与UIView的center；用来设置CALayer在父层中的位置；以父层的左上角为原点（0，0） @property CGPoint anchorPoint;称『定位点』、『锚点』，该描述是相对于x、y位置比例而言的默认在图像中心点（0.5、0.5）的位置；决定着CALayer身上的哪个点会再position属性所指的位置，以自己的左上角为原点（0，0）；它的x、y取值范围都是0~1 @property(nullable) CGColorRef backgroundColor图层背景颜色 @property(nullable) CGColorRef borderColor图层边框颜色 @property CGFloat borderWidth图层边框宽度 @property CGRect bounds图层大小 @property(nullable, strong) id contents图层显示内容，例如可以将图片作为图层内容显示 @property CGRect contentsRect图层显示内容的大小和位置 @property CGFloat cornerRadius圆角半径 @property(getter=isDoubleSided) BOOL doubleSided图层背景是否显示，默认是YES @property CGRect frame图层大小和位置，不支持隐式动画，所以CALyaer中很少使用frame，通常使用bound和position代替 @property(getter=isHidden) BOOL hidden是否隐藏 @property(nullable, strong) CALayer *mask图层蒙版 @property BOOL masksToBounds子图层是否剪切图层边界，默认是NO @property float opacit;图层透明度，类似与UIView的alpha @property(nullable) CGColorRef shadowColor阴影颜色 @property CGSize shadowOffset阴影偏移量 @property float shadowOpacity阴影透明度，注意默认为0，如果设置阴影必须设置此属性 @property(nullable) CGPathRef shadowPath阴影形状 @property CGFloat shadowRadius阴影模糊半径 @property(nullable, copy) NSArray 二、CALayer不常用属性 @property CGFloat zPosition图层中心点在z轴中的位置 @property CGFloat anchorPointZ图层在z轴中的锚点； 方法 - (CGAffineTransform)affineTransform 方法 - (void)setAffineTransform:(CGAffineTransform)m以上属性为图层形变；该属性值指定一个CGAffineTransform对象，该对象代表对CALayer执行X、Y两个维度（也就是平面）上的旋转、缩放、位移、斜切、镜像等变换矩阵 @property(nullable, readonly) CALayer *superlayer图层的父图层 三、CALayer图层操作 方法 - (void)addSublayer:(CALayer *)layer添加子图层 方法 - (void)removeFromSuperlayer将自己从父图层中移除 方法 - (void)insertSublayer:(CALayer *)layer atIndex:(unsigned)idx在自己子图层数组中的第idx位置添加图层 方法 - (void)insertSublayer:(CALayer )layer below:(nullable CALayer )sibling将图层layer添加在子图层sibling的下面 方法 - (void)insertSublayer:(CALayer )layer above:(nullable CALayer )sibling将图层layer添加在子图层sibling的上面 方法 - (void)replaceSublayer:(CALayer )layer with:(CALayer )layer2将图层layer替换layer2； 四、CALayer动画操作 方法 - (void)addAnimation:(CAAnimation )anim forKey:(nullable NSString )key图层添加某一属性的动画 方法 - (nullable NSArray&lt; NSString &gt; )animationKeys获取所有动画的属性 方法 - (nullable CAAnimation )animationForKey:(NSString )key获取某一属性的动画 方法 - (void)removeAnimationForKey:(NSString *)key移除某一属性动画 方法 - (void)removeAllAnimations移除所有动画 五、CALayer子类其他说明 子类名称 用途 CAEmitterLayer 发射器层，用来控制粒子效果 CAGradientLayer 梯度层，颜色渐变 CAEAGLayer 用OpenGL ES绘制的层 CAReplicationLayer 用来自动复制sublayer CAShapeLayer 绘制立体的贝塞尔曲线 CAScrollLayer 用来管理可滑动的区域 CATextLayer 可以绘制AttributeString CATiledLayer 用来管理一副可以被分割的大图 CATransformLayer 用来渲染3D layer的层次结构 1. CAShapeLayerCAShapeLayer属于QuartzCore框架，继承自CALayer。CAShapeLayer是在坐标系内绘制贝塞尔曲线的，通过绘制贝塞尔曲线，设置shape(形状)的path(路径)，从而绘制各种各样的图形以及不规则图形。因此，使用CAShapeLayer需要与UIBezierPath一起使用。UIBezierPath类允许你在自定义的 View 中绘制和渲染由直线和曲线组成的路径.。你可以在初始化的时候直接为你的UIBezierPath指定一个几何图形。通俗点就是UIBezierPath用来指定绘制图形路径，而CAShapeLayer就是根据路径来绘图的。 属性 1、@property(nullable) CGPathRef path; 呈现的形状的路径 2、@property(nullable) CGColorRef fillColor;填充路径的颜色 3、@property(copy) CAShapeLayerFillRule fillRule; 当在填充颜色的时候则就需要这种填充规则，值有两种，非零和奇偶数，但默认是非零值。 4、@property(nullable) CGColorRef strokeColor;设置描边色，默认无色。 5、@property CGFloat strokeStart; 绘制边线轮廓路径的子区域。该值必须在[0,1]范围，0代表路径的开始，1代表路径的结束。 默认为0 6、@property CGFloat strokeEnd; 默认为1 7、@property CGFloat lineWidth; 线的宽度 默认为1 8、@property CGFloat miterLimit;最大斜接长度。斜接长度指的是在两条线交汇处和外交之间的距离。只有lineJoin属性为kCALineJoinMiter时miterLimit才有效。边角的角度越小，斜接长度就会越大。为了避免斜接长度过长，我们可以使用miterLimit属性。如果斜接长度超过miterLimit的值，边角会以lineJoin的“bevel”即kCALineJoinBevel类型来显示。 9、@property(copy) CAShapeLayerLineCap lineCap; 线端点类型，值有三个类型，分别为kCALineCapButt 、kCALineCapRound 、kCALineCapSquare，默认值为Butt； 10、@property(copy) CAShapeLayerLineJoin lineJoin;lineJoin为线连接类型，其值也有三个类型，分别为kCALineJoinMiter、kCALineJoinRound、kCALineJoinBevel，默认值是Miter。 11、@property CGFloat lineDashPhase;为线型模版的起始位置；lineDashPattern为线性模版，这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度。注：fillColor与strokeColor都是在有UIBezierPath参数配置的情况下才能发生作用 12、@property(nullable, copy) NSArray&lt;NSNumber *&gt; *lineDashPattern; 2.CAReplicationLayer属性 1、@property NSInteger instanceCount; 复制subLayer个数，默认为1 2、@property BOOL preservesDepth; 是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层 3、@property CFTimeInterval instanceDelay; 设置复制子层的延迟动画时长 4、@property CATransform3D instanceTransform; 设置复制子层的相对位置 5、@property(nullable) CGColorRef instanceColor; 子层颜色，会和原生子层背景色冲突，因此二者选其一设置 6、@property float instanceRedOffset;设置每个复制图层相对上一个复制图层的红色偏移量 7、@property float instanceRedOffset;设置每个复制图层相对上一个复制图层的绿色偏移量 8、@property float instanceBlueOffset;设置每个复制图层相对上一个复制图层的蓝色偏移量 9、@property float instanceAlphaOffset;设置每个复制图层相对上一个复制图层的透明度偏移量","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS动画-CAAniamtion的属性和使用","slug":"iOS动画-CAAniamtion的属性和使用","date":"2020-01-16T08:04:36.468Z","updated":"2020-01-20T01:47:28.698Z","comments":true,"path":"2020/01/16/iOS动画-CAAniamtion的属性和使用/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%8A%A8%E7%94%BB-CAAniamtion%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"CAAnimationCAAnimation是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类。 属性 duration：动画的持续时间 repeatCount：动画的重复次数 repeatDuration：动画的重复时间 removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards fillMode：决定当前对象在非active时间段的行为。比如动画开始之前,动画结束之后 beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间 timingFunction：速度控制函数，控制动画运行的节奏 delegate：动画代理 子类1.CAPropertyAnimation是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation。 keyPath 通过指定CALayer的一个属性名称为keyPath(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。 2.CABasicAnimation fromValue：keyPath相应属性的初始值。 toValue：keyPath相应属性的结束值。 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。 3.CAKeyframeAnimationCApropertyAnimation的子类，跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值。 values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧。 path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略。 keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的。 CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation。 4.CAAnimationGroupCAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。 animations：用来保存一组动画对象的NSArray。 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。 5.CATransitionCAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果。 type：动画过渡类型。 subtype：动画过渡方向。 startProgress：动画起点(在整体动画的百分比)。 endProgress：动画终点(在整体动画的百分比)。","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"iOS第三方库-YYCache","slug":"iOS第三方库-YYCache","date":"2020-01-16T08:04:32.541Z","updated":"2020-01-20T02:36:22.701Z","comments":true,"path":"2020/01/16/iOS第三方库-YYCache/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-YYCache/","excerpt":"","text":"简介一个高性能 iOS 缓存框架。 主要由YYDiskCache与YYMemoryCache组成。其中YYDiskCache是作为持久化储存，通过sqlite的形式储存在沙盒中Library/Caches/&lt;缓存地址名称&gt;。缓存的对象需要遵循NSCoding协议，并实现协议方法，可以通过YYModel一键归档。 12345678- (void)encodeWithCoder:(NSCoder*)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder];&#125;- (id)initWithCoder:(NSCoder*)aDecoder &#123; self &#x3D; [super init]; return [self yy_modelInitWithCoder:aDecoder];&#125; 接口说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@interface YYCache : NSObject&#x2F;** 缓存的名称 *&#x2F;@property (copy, readonly) NSString *name;&#x2F;** 内存缓存 *&#x2F;@property (strong, readonly) YYMemoryCache *memoryCache;&#x2F;** 磁盘缓存 *&#x2F;@property (strong, readonly) YYDiskCache *diskCache;&#x2F;** 初始化方式一，设置缓存名称 *&#x2F;- (nullable instancetype)initWithName:(NSString *)name;&#x2F;** 初始化方式二，设置缓存路径 *&#x2F;- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;&#x2F;** 便利构造初始化，设置缓存名称 *&#x2F;+ (nullable instancetype)cacheWithName:(NSString *)name;&#x2F;** 便利构造初始化，设置缓存路径 *&#x2F;+ (nullable instancetype)cacheWithPath:(NSString *)path;&#x2F;** 方法失效 *&#x2F;- (instancetype)init UNAVAILABLE_ATTRIBUTE;&#x2F;** 方法失效 *&#x2F;+ (instancetype)new UNAVAILABLE_ATTRIBUTE;#pragma mark - Access Methods&#x2F;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F;&#x2F; @name Access Methods&#x2F;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;** 判断缓存中是否存在相同key值的数据 *&#x2F;- (BOOL)containsObjectForKey:(NSString *)key;&#x2F;** 异步 判断缓存中是否存在相同key值的数据 *&#x2F;- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;&#x2F;** 通过key值获取缓存数据 *&#x2F;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;&#x2F;** 异步通过key值获取缓存数据 *&#x2F;- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;&#x2F;** 通过key值，设置缓存数据 *&#x2F;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;&#x2F;** 异步通过key值，设置缓存数据 *&#x2F;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;&#x2F;** 通过key值，清除缓存数据 *&#x2F;- (void)removeObjectForKey:(NSString *)key;&#x2F;** 异步通过key值，清除缓存数据 *&#x2F;- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;&#x2F;** 清除所有缓存数据 *&#x2F;- (void)removeAllObjects;&#x2F;** 异步清除所有缓存数据 *&#x2F;- (void)removeAllObjectsWithBlock:(void(^)(void))block;&#x2F;** 异步清除所有缓存数据，并获取清除进程和是否清除失败 *&#x2F;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end; 使用实例Model 12345678910111213141516171819202122232425262728#import &lt;Foundation&#x2F;Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface TestModel : NSObject &lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) bool sex;@endNS_ASSUME_NONNULL_END&#x2F;&#x2F;--------------------分界线--------------------&#x2F;&#x2F;#import &quot;TestModel.h&quot;#import &lt;YYModel.h&gt;@implementation TestModel- (void)encodeWithCoder:(NSCoder*)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder];&#125;- (id)initWithCoder:(NSCoder*)aDecoder &#123; self &#x3D; [super init]; return [self yy_modelInitWithCoder:aDecoder];&#125;@end 添加到缓存中 12345678910111213141516171819202122232425YYCache *cache &#x3D; [YYCache cacheWithName:@&quot;CacheName&quot;];TestModel *model &#x3D; [[TestModel alloc] init];model.name &#x3D; @&quot;test&quot;;model.age &#x3D; 11;model.sex &#x3D; NO;TestModel *model1 &#x3D; [[TestModel alloc] init];model1.name &#x3D; @&quot;tes2&quot;;model1.age &#x3D; 22;model1.sex &#x3D; YES;TestModel *model2 &#x3D; [[TestModel alloc] init];model2.name &#x3D; @&quot;tes3&quot;;model2.age &#x3D; 33;model2.sex &#x3D; NO;NSArray&lt;TestModel *&gt; *array &#x3D; @[model, model1, model2];[cache setObject:array forKey:@&quot;Test&quot;];NSArray&lt;TestModel *&gt; *tArray &#x3D; [cache objectForKey:@&quot;Test&quot;];for (TestModel *m in tArray) &#123; NSLog(@&quot;name:%@----age:%ld---sex:%d&quot;, m.name, m.age, m.sex);&#125; 获取缓存中的数据 1232019-05-16 11:59:12.918221+0800 YYKitDemo[8347:173145] name:test----age:11---sex:02019-05-16 11:59:12.918342+0800 YYKitDemo[8347:173145] name:tes2----age:22---sex:12019-05-16 11:59:12.918412+0800 YYKitDemo[8347:173145] name:tes3----age:33---sex:0","categories":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"第三方库","slug":"第三方库","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}]},{"title":"iOS第三方库-RxSwift学习日常（基础介绍）","slug":"iOS第三方库-RxSwift学习日常（基础介绍）","date":"2020-01-16T08:04:28.943Z","updated":"2020-01-20T02:35:51.402Z","comments":true,"path":"2020/01/16/iOS第三方库-RxSwift学习日常（基础介绍）/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-RxSwift%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%EF%BC%89/","excerpt":"","text":"Observable 介绍Observable Observable 这个类就是 Rx 框架的基础，我们可以称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable 对象会随着时间推移不定期地发出 event(element : T) 这样一个东西。 而且这些 Event 还可以携带数据，它的泛型 就是用来指定这个 Event 携带的数据的类型。 有了可观察序列，我们还需要有一个 Observer（订阅者）来订阅它，这样这个订阅者才能收到 Observable 不时发出的 Event。Event查看 RxSwift 源码可以发现，事件 Event 的定义如下： 12345678910public enum Event&lt;Element&gt; &#123; &#x2F;&#x2F;&#x2F; Next element is produced. case next(Element) &#x2F;&#x2F;&#x2F; Sequence terminated with an error. case error(Swift.Error) &#x2F;&#x2F;&#x2F; Sequence completed successfully. case completed&#125; 可以看到 Event 就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件： next：next 事件就是那个可以携带数据 的事件，可以说它就是一个“最正常”的事件。 error：error 事件表示一个错误，它可以携带具体的错误内容，一旦 Observable 发出了 error event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了。 completed：completed 事件表示 Observable 发出的事件正常地结束了，跟 error 一样，一旦 Observable 发出了 completed event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了Observable 与 Sequence比较(1)、为更好地理解，我们可以把每一个 Observable 的实例想象成于一个 Swift 中的 Sequence： 即一个 Observable（ObservableType）相当于一个序列 Sequence（SequenceType）。 ObservableType.subscribe(_:) 方法其实就相当于 SequenceType.generate()。 (2)、但它们之间还是有许多区别的： Swift 中的 SequenceType 是同步的循环，而 Observable 是异步的。 Observable 对象会在有任何 Event 时候，自动将 Event 作为一个参数通过 ObservableType.subscribe(_:) 发出，并不需要使用 next 方法。创建 Observable 序列just() 方法（1）该方法通过传入一个默认值来初始化。（2）下面样例我们显式地标注出了 observable 的类型为 Observable，即指定了这个 Observable 所发出的事件携带的数据类型必须是 Int 类型的。 1let observable &#x3D; Observable&lt;Int&gt;.just(5) of() 方法（1）该方法可以接受可变数量的参数（必需要是同类型的）（2）下面样例中我没有显式地声明出 Observable 的泛型类型，Swift 也会自动推断类型。 1let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) from() 方法（1）该方法需要一个数组参数。（2）下面样例中数据里的元素就会被当做这个 Observable 所发出 event 携带的数据内容，最终效果同上面饿 of() 样例是一样的。 1let observable &#x3D; Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) empty() 方法该方法创建一个空内容的 Observable 序列。 1let observable &#x3D; Observable&lt;Int&gt;.empty() never() 方法该方法创建一个永远不会发出 Event（也不会终止）的 Observable 序列。 1let observable &#x3D; Observable&lt;Int&gt;.never() error() 方法该方法创建一个不做任何操作，而是直接发送一个错误的 Observable 序列。 123456enum MyError: Error &#123; case A case B&#125; let observable &#x3D; Observable&lt;Int&gt;.error(MyError.A) range() 方法（1）该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的 Observable 序列。（2）下面样例中，两种方法创建的 Observable 序列都是一样的。 12345&#x2F;&#x2F;使用range()let observable &#x3D; Observable.range(start: 1, count: 5) &#x2F;&#x2F;使用of()let observable &#x3D; Observable.of(1, 2, 3 ,4 ,5) repeatElement() 方法该方法创建一个可以无限发出给定元素的 Event 的 Observable 序列（永不终止）。 1let observable &#x3D; Observable.repeatElement(1) generate() 方法（1）该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的 Observable 序列。（2）下面样例中，两种方法创建的 Observable 序列都是一样的。 123456789&#x2F;&#x2F;使用generate()方法let observable &#x3D; Observable.generate( initialState: 0, condition: &#123; $0 &lt;&#x3D; 10 &#125;, iterate: &#123; $0 + 2 &#125;) &#x2F;&#x2F;使用of()方法let observable &#x3D; Observable.of(0 , 2 ,4 ,6 ,8 ,10) create() 方法（1）该方法接受一个 block 形式的参数，任务是对每一个过来的订阅进行处理。（2）下面是一个简单的样例。为方便演示，这里增加了订阅相关代码（关于订阅我之后会详细介绍的）。 123456789101112131415&#x2F;&#x2F;这个block有一个回调参数observer就是订阅这个Observable对象的订阅者&#x2F;&#x2F;当一个订阅者订阅这个Observable对象的时候，就会将订阅者作为参数传入这个block来执行一些内容let observable &#x3D; Observable&lt;String&gt;.create&#123;observer in &#x2F;&#x2F;对订阅者发出了.next事件，且携带了一个数据&quot;hangge.com&quot; observer.onNext(&quot;hangge.com&quot;) &#x2F;&#x2F;对订阅者发出了.completed事件 observer.onCompleted() &#x2F;&#x2F;因为一个订阅行为会有一个Disposable类型的返回值，所以在结尾一定要returen一个Disposable return Disposables.create()&#125; &#x2F;&#x2F;订阅测试observable.subscribe &#123; print($0)&#125; deferred() 方法该个方法相当于是创建一个 Observable 工厂，通过传入一个 block 来执行延迟 Observable 序列创建的行为，而这个 block 里就是真正的实例化序列对象的地方。 1234567891011121314151617181920212223242526&#x2F;&#x2F;用于标记是奇数、还是偶数var isOdd &#x3D; true &#x2F;&#x2F;使用deferred()方法延迟Observable序列的初始化，通过传入的block来实现Observable序列的初始化并且返回。let factory : Observable&lt;Int&gt; &#x3D; Observable.deferred &#123; &#x2F;&#x2F;让每次执行这个block时候都会让奇、偶数进行交替 isOdd &#x3D; !isOdd &#x2F;&#x2F;根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable if isOdd &#123; return Observable.of(1, 3, 5 ,7) &#125;else &#123; return Observable.of(2, 4, 6, 8) &#125;&#125; &#x2F;&#x2F;第1次订阅测试factory.subscribe &#123; event in print(&quot;\\(isOdd)&quot;, event)&#125; &#x2F;&#x2F;第2次订阅测试factory.subscribe &#123; event in print(&quot;\\(isOdd)&quot;, event)&#125; interval() 方法（1）这个方法创建的 Observable 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去。（2）下面方法让其每 1 秒发送一次，并且是在主线程（MainScheduler）发送。 1234let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; timer() 方法（1）这个方法有两种用法，一种是创建的 Observable 序列在经过设定的一段时间后，产生唯一的一个元素。 12345&#x2F;&#x2F;5秒种后发出唯一的一个元素0let observable &#x3D; Observable&lt;Int&gt;.timer(5, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; （2）另一种是创建的 Observable 序列在经过设定的一段时间后，每隔一段时间产生一个元素。 12345&#x2F;&#x2F;延时5秒种后，每隔1秒钟发出一个元素let observable &#x3D; Observable&lt;Int&gt;.timer(5, period: 1, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; 订阅 Observable第一种用法：（1）我们使用 subscribe() 订阅了一个 Observable 对象，该方法的 block 的回调参数就是被发出的 event 事件，我们将其直接打印出来。 12345let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable.subscribe &#123; event in print(event)&#125; 输入结果可以看出 初始化 Observable 序列时设置的默认值都按顺序通过 .next 事件发送出来。 当 Observable 序列的初始数据都发送完毕，它还会自动发一个 .completed 事件出来。 （2）如果想要获取到这个事件里的数据，可以通过 event.element 得到。 12345let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable.subscribe &#123; event in print(event.element)&#125; 第二种用法：（1）RxSwift 还提供了另一个 subscribe 方法，它可以把 event 进行分类： 通过不同的 block 回调处理不同类型的 event。（其中 onDisposed 表示订阅行为被 dispose 后的回调，这个我后面会说） 同时会把 event 携带的数据直接解包出来作为参数，方便我们使用。1234567891011let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable.subscribe(onNext: &#123; element in print(element)&#125;, onError: &#123; error in print(error)&#125;, onCompleted: &#123; print(&quot;completed&quot;)&#125;, onDisposed: &#123; print(&quot;disposed&quot;)&#125;) 2）subscribe() 方法的 onNext、onError、onCompleted 和 onDisposed 这四个回调 block 参数都是有默认值的，即它们都是可选的。所以我们也可以只处理 onNext 而不管其他的情况。12345let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable.subscribe(onNext: &#123; element in print(element)&#125;) 监听事件的生命周期1、 doOn 介绍（1）我们可以使用 doOn 方法来监听事件的生命周期，它会在每一次事件发送前被调用。（2）同时它和 subscribe 一样，可以通过不同的 block 回调处理不同类型的 event。比如： do(onNext:) 方法就是在 subscribe(onNext:) 前调用 而 do(onCompleted:) 方法则会在 subscribe(onCompleted:) 前面调用。 使用样例123456789101112131415161718192021let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable .do(onNext: &#123; element in print(&quot;Intercepted Next：&quot;, element) &#125;, onError: &#123; error in print(&quot;Intercepted Error：&quot;, error) &#125;, onCompleted: &#123; print(&quot;Intercepted Completed&quot;) &#125;, onDispose: &#123; print(&quot;Intercepted Disposed&quot;) &#125;) .subscribe(onNext: &#123; element in print(element) &#125;, onError: &#123; error in print(error) &#125;, onCompleted: &#123; print(&quot;completed&quot;) &#125;, onDisposed: &#123; print(&quot;disposed&quot;) &#125;) Observable 的销毁（Dispose）1、Observable 从创建到终结流程（1）一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。（2）而 Observable 序列激活之后要一直等到它发出了 .error 或者 .completed 的 event 后，它才被终结。 2、dispose() 方法（1）使用该方法我们可以手动取消一个订阅行为。（2）如果我们觉得这个订阅结束了不再需要了，就可以调用 dispose() 方法把这个订阅给销毁掉，防止内存泄漏。（2）当一个订阅行为被 dispose 了，那么之后 observable 如果再发出 event，这个已经 dispose 的订阅就收不到消息了。下面是一个简单的使用样例。 123456789let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) &#x2F;&#x2F;使用subscription常量存储这个订阅方法let subscription &#x3D; observable.subscribe &#123; event in print(event)&#125; &#x2F;&#x2F;调用这个订阅的dispose()方法subscription.dispose() 3、DisposeBag除了 dispose() 方法之外，我们更经常用到的是一个叫 DisposeBag 的对象来管理多个订阅行为的销毁：我们可以把一个 DisposeBag 对象看成一个垃圾袋，把用过的订阅行为都放进去。而这个 DisposeBag 就会在自己快要 dealloc 的时候，对它里面的所有订阅行为都调用 dispose() 方法。下面是一个简单的使用样例。 12345678910111213let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;第1个Observable，及其订阅let observable1 &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)observable1.subscribe &#123; event in print(event)&#125;.disposed(by: disposeBag) &#x2F;&#x2F;第2个Observable，及其订阅let observable2 &#x3D; Observable.of(1, 2, 3)observable2.subscribe &#123; event in print(event)&#125;.disposed(by: disposeBag) 观察者（Observer）介绍观察者（Observer）的作用就是监听事件，然后对这个事件做出响应。或者说任何响应事件的行为都是观察者。比如： 当我们点击按钮，弹出一个提示框。那么这个“弹出一个提示框”就是观察者 Observer 当我们请求一个远程的 json 数据后，将其打印出来。那么这个“打印 json 数据”就是观察者 Observer 直接在 subscribe、bind 方法中创建观察者1. 在 subscribe 方法中创建（1）创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述当事件发生时，需要如何做出响应。（2）比如下面的样例，观察者就是由后面的 onNext，onError，onCompleted 这些闭包构建出来的。 123456789let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) observable.subscribe(onNext: &#123; element in print(element)&#125;, onError: &#123; error in print(error)&#125;, onCompleted: &#123; print(&quot;completed&quot;)&#125;) 2. 在 bind 方法中创建下面代码我们创建一个定时生成索引数的 Observable 序列，并将索引数不断显示在 label 标签上： 123456789101112131415161718192021222324import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;Observable序列（每隔1秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; &quot;当前索引数：\\($0 )&quot;&#125; .bind &#123; [weak self](text) in &#x2F;&#x2F;收到发出的索引数后显示到label上 self?.label.text &#x3D; text &#125; .disposed(by: disposeBag) &#125;&#125; 使用 AnyObserver 创建观察者AnyObserver 可以用来描叙任意一种观察者。 1、配合 subscribe 方法使用比如上面第一个样例我们可以改成如下代码： 1234567891011121314&#x2F;&#x2F;观察者let observer: AnyObserver&lt;String&gt; &#x3D; AnyObserver &#123; (event) in switch event &#123; case .next(let data): print(data) case .error(let error): print(error) case .completed: print(&quot;completed&quot;) &#125;&#125; let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)observable.subscribe(observer) 2、配合 bindTo 方法使用也可配合 Observable 的数据绑定方法（bindTo）使用。比如上面的第二个样例我可以改成如下代码： 12345678910111213141516171819202122232425262728293031import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;观察者 let observer: AnyObserver&lt;String&gt; &#x3D; AnyObserver &#123; [weak self] (event) in switch event &#123; case .next(let text): &#x2F;&#x2F;收到发出的索引数后显示到label上 self?.label.text &#x3D; text default: break &#125; &#125; &#x2F;&#x2F;Observable序列（每隔1秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; &quot;当前索引数：\\($0 )&quot;&#125; .bind(to: observer) .disposed(by: disposeBag) &#125;&#125; 使用 Binder 创建观察者1、基本介绍（1）相较于 AnyObserver 的大而全，Binder 更专注于特定的场景。Binder 主要有以下两个特征： 不会处理错误事件 确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler） （2）一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。 使用样例（1）在上面序列数显示样例中，label 标签的文字显示就是一个典型的 UI 观察者。它在响应事件时，只会处理 next 事件，而且更新 UI 的操作需要在主线程上执行。那么这种情况下更好的方案就是使用 Binder。（2）上面的样例我们改用 Binder 会简单许多： 1234567891011121314151617181920212223242526import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;观察者 let observer: Binder&lt;String&gt; &#x3D; Binder(label) &#123; (view, text) in &#x2F;&#x2F;收到发出的索引数后显示到label上 view.text &#x3D; text &#125; &#x2F;&#x2F;Observable序列（每隔1秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; &quot;当前索引数：\\($0 )&quot;&#125; .bind(to: observer) .disposed(by: disposeBag) &#125;&#125; 附：Binder 在 RxCocoa 中的应用（1）其实 RxCocoa 在对许多 UI 控件进行扩展时，就利用 Binder 将控件属性变成观查者，比如 UIControl+Rx.swift 中的 isEnabled 属性便是一个 observer ： 123456789101112import RxSwiftimport UIKit extension Reactive where Base: UIControl &#123; &#x2F;&#x2F;&#x2F; Bindable sink for &#96;enabled&#96; property. public var isEnabled: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; control, value in control.isEnabled &#x3D; value &#125; &#125;&#125; （2）因此我们可以将序列直接绑定到它上面。比如下面样例，button 会在可用、不可用这两种状态间交替变换（每隔一秒）。 123456&#x2F;&#x2F;Observable序列（每隔1秒钟发出一个索引数）let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)observable .map &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; .bind(to: button.rx.isEnabled) .disposed(by: disposeBag) 自定义可绑定属性有时我们想让 UI 控件创建出来后默认就有一些观察者，而不必每次都为它们单独去创建观察者。比如我们想要让所有的 UIlabel 都有个 fontSize 可绑定属性，它会根据事件值自动改变标签的字体大小。 方式一：通过对 UI 类进行扩展这里我们通过对 UILabel 进行扩展，增加了一个 fontSize 可绑定属性。 12345678910111213141516171819202122232425262728import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;Observable序列（每隔0.5秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance) observable .map &#123; CGFloat($0) &#125; .bind(to: label.fontSize) &#x2F;&#x2F;根据索引数不断变放大字体 .disposed(by: disposeBag) &#125;&#125; extension UILabel &#123; public var fontSize: Binder&lt;CGFloat&gt; &#123; return Binder(self) &#123; label, fontSize in label.font &#x3D; UIFont.systemFont(ofSize: fontSize) &#125; &#125;&#125; 方式二：通过对 Reactive 类进行扩展既然使用了 RxSwift，那么更规范的写法应该是对 Reactive 进行扩展。这里同样是给 UILabel 增加了一个 fontSize 可绑定属性。（注意：这种方式下，我们绑定属性时要写成 label.rx.fontSize） 12345678910111213141516171819202122232425262728import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;Observable序列（每隔0.5秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance) observable .map &#123; CGFloat($0) &#125; .bind(to: label.rx.fontSize) &#x2F;&#x2F;根据索引数不断变放大字体 .disposed(by: disposeBag) &#125;&#125; extension Reactive where Base: UILabel &#123; public var fontSize: Binder&lt;CGFloat&gt; &#123; return Binder(self.base) &#123; label, fontSize in label.font &#x3D; UIFont.systemFont(ofSize: fontSize) &#125; &#125;&#125; RxSwift 自带的可绑定属性（UI 观察者）（1）其实 RxSwift 已经为我们提供许多常用的可绑定属性。比如 UILabel 就有 text 和 attributedText 这两个可绑定属性。 1234567891011121314151617181920import RxSwiftimport UIKit extension Reactive where Base: UILabel &#123; &#x2F;&#x2F;&#x2F; Bindable sink for &#96;text&#96; property. public var text: Binder&lt;String?&gt; &#123; return Binder(self.base) &#123; label, text in label.text &#x3D; text &#125; &#125; &#x2F;&#x2F;&#x2F; Bindable sink for &#96;attributedText&#96; property. public var attributedText: Binder&lt;NSAttributedString?&gt; &#123; return Binder(self.base) &#123; label, text in label.attributedText &#x3D; text &#125; &#125; &#125; （2）那么上文那个定时显示索引数的样例，我们其实不需要自定义 UI 观察者，直接使用 RxSwift 提供的绑定属性即可。 1234567891011121314151617181920import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag &#x3D; DisposeBag() override func viewDidLoad() &#123; &#x2F;&#x2F;Observable序列（每隔1秒钟发出一个索引数） let observable &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; &quot;当前索引数：\\($0 )&quot;&#125; .bind(to: label.rx.text) &#x2F;&#x2F;收到发出的索引数后显示到label上 .disposed(by: disposeBag) &#125;&#125; Subjects 介绍Subjects 基本介绍（1）Subjects 既是订阅者，也是 Observable： 说它是订阅者，是因为它能够动态地接收新的值。 说它又是一个 Observable，是因为当 Subjects 有了新的值之后，就会通过 Event 将新值发出给他的所有订阅者。 （2）一共有四种 Subjects，分别为：PublishSubject、BehaviorSubject、ReplaySubject、Variable。他们之间既有各自的特点，也有相同之处： 首先他们都是 Observable，他们的订阅者都能收到他们发出的新的 Event。 直到 Subject 发出 .complete 或者 .error 的 Event 后，该 Subject 便终结了，同时它也就不会再发出 .next 事件。 对于那些在 Subject 终结后再订阅他的订阅者，也能收到 subject 发出的一条 .complete 或 .error 的 event，告诉这个新的订阅者它已经终结了。 他们之间最大的区别只是在于：当一个新的订阅者刚订阅它的时候，能不能收到 Subject 以前发出过的旧 Event，如果能的话又能收到多少个。 （3）Subject 常用的几个方法： onNext(:)：是 on(.next(:)) 的简便写法。该方法相当于 subject 接收到一个 .next 事件。 onError(:)：是 on(.error(:)) 的简便写法。该方法相当于 subject 接收到一个 .error 事件。 onCompleted()：是 on(.completed) 的简便写法。该方法相当于 subject 接收到一个 .completed 事件。 PublishSubject（1）基本介绍 PublishSubject 是最普通的 Subject，它不需要初始值就能创建。 PublishSubject 的订阅者从他们开始订阅的时间点起，可以收到订阅后 Subject 发出的新 Event，而不会收到他们在订阅前已发出的 Event。（2）时序图 最上面一条是 BehaviorSubject。 下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 BehaviorSubject 的订阅者一开始就能收到 BehaviorSubjects 之前发出的一个 Event。（3）使用样例1234567891011121314151617181920let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;创建一个BehaviorSubjectlet subject &#x3D; BehaviorSubject(value: &quot;111&quot;) &#x2F;&#x2F;第1次订阅subjectsubject.subscribe &#123; event in print(&quot;第1次订阅：&quot;, event)&#125;.disposed(by: disposeBag) &#x2F;&#x2F;发送next事件subject.onNext(&quot;222&quot;) &#x2F;&#x2F;发送error事件subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil)) &#x2F;&#x2F;第2次订阅subjectsubject.subscribe &#123; event in print(&quot;第2次订阅：&quot;, event)&#125;.disposed(by: disposeBag) ReplaySubject（1）基本介绍 ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个 .next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event 外，还会收到那个终结的 .error 或者 .complete 的 event。 （2）时序图 最上面一条是 ReplaySubject（bufferSize 设为为 2）。 下面两条分别表示两个新的订阅，它们订阅的时间点不同。可以发现 ReplaySubject 的订阅者一开始就能收到 ReplaySubject 之前发出的两个 Event（如果有的话）。（3）使用样例123456789101112131415161718192021222324252627282930let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;创建一个bufferSize为2的ReplaySubjectlet subject &#x3D; ReplaySubject&lt;String&gt;.create(bufferSize: 2) &#x2F;&#x2F;连续发送3个next事件subject.onNext(&quot;111&quot;)subject.onNext(&quot;222&quot;)subject.onNext(&quot;333&quot;) &#x2F;&#x2F;第1次订阅subjectsubject.subscribe &#123; event in print(&quot;第1次订阅：&quot;, event)&#125;.disposed(by: disposeBag) &#x2F;&#x2F;再发送1个next事件subject.onNext(&quot;444&quot;) &#x2F;&#x2F;第2次订阅subjectsubject.subscribe &#123; event in print(&quot;第2次订阅：&quot;, event)&#125;.disposed(by: disposeBag) &#x2F;&#x2F;让subject结束subject.onCompleted() &#x2F;&#x2F;第3次订阅subjectsubject.subscribe &#123; event in print(&quot;第3次订阅：&quot;, event)&#125;.disposed(by: disposeBag) Variable（注意：由于 Variable 在之后版本中将被废弃，建议使用 Varible 的地方都改用下面介绍的 BehaviorRelay 作为替代。）（1）基本介绍 Variable 其实就是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 Variable 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 不同的是，Variable 还把会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送 .complete 的 event，不需要也不能手动给 Variables 发送 completed 或者 error 事件来结束它。 简单地说就是 Variable 有一个 value 属性，我们改变这个 value 属性的值就相当于调用一般 Subjects 的 onNext() 方法，而这个最新的 onNext() 的值就被保存在 value 属性里了，直到我们再次修改它。 注意：Variables 本身没有 subscribe() 方法，但是所有 Subjects 都有一个 asObservable() 方法。我们可以使用这个方法返回这个 Variable 的 Observable 类型，拿到这个 Observable 类型我们就能订阅它了。 （2）使用样例 12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;创建一个初始值为111的Variable let variable &#x3D; Variable(&quot;111&quot;) &#x2F;&#x2F;修改value值 variable.value &#x3D; &quot;222&quot; &#x2F;&#x2F;第1次订阅 variable.asObservable().subscribe &#123; print(&quot;第1次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 variable.value &#x3D; &quot;333&quot; &#x2F;&#x2F;第2次订阅 variable.asObservable().subscribe &#123; print(&quot;第2次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 variable.value &#x3D; &quot;444&quot; &#125;&#125; BehaviorRelay（1）基本介绍 BehaviorRelay 是作为 Variable 的替代者出现的。它的本质其实也是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 BehaviorRelay 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 与 BehaviorSubject 不同的是，不需要也不能手动给 BehaviorReply 发送 completed 或者 error 事件来结束它（BehaviorRelay 会在销毁时也不会自动发送 .complete 的 event）。 BehaviorRelay 有一个 value 属性，我们通过这个属性可以获取最新值。而通过它的 accept() 方法可以对值进行修改。 （2）上面的 Variable 样例我们可以改用成 BehaviorRelay，代码如下： 12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;创建一个初始值为111的BehaviorRelay let subject &#x3D; BehaviorRelay&lt;String&gt;(value: &quot;111&quot;) &#x2F;&#x2F;修改value值 subject.accept(&quot;222&quot;) &#x2F;&#x2F;第1次订阅 subject.asObservable().subscribe &#123; print(&quot;第1次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 subject.accept(&quot;333&quot;) &#x2F;&#x2F;第2次订阅 subject.asObservable().subscribe &#123; print(&quot;第2次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 subject.accept(&quot;444&quot;) &#125;&#125; （3）如果想将新值合并到原值上，可以通过 accept() 方法与 value 属性配合来实现。（这个常用在表格上拉加载功能上，BehaviorRelay 用来保存所有加载到的数据） 12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag &#x3D; DisposeBag() &#x2F;&#x2F;创建一个初始值为包含一个元素的数组的BehaviorRelay let subject &#x3D; BehaviorRelay&lt;[String]&gt;(value: [&quot;1&quot;]) &#x2F;&#x2F;修改value值 subject.accept(subject.value + [&quot;2&quot;, &quot;3&quot;]) &#x2F;&#x2F;第1次订阅 subject.asObservable().subscribe &#123; print(&quot;第1次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 subject.accept(subject.value + [&quot;4&quot;, &quot;5&quot;]) &#x2F;&#x2F;第2次订阅 subject.asObservable().subscribe &#123; print(&quot;第2次订阅：&quot;, $0) &#125;.disposed(by: disposeBag) &#x2F;&#x2F;修改value值 subject.accept(subject.value + [&quot;6&quot;, &quot;7&quot;]) &#125;&#125;","categories":[],"tags":[{"name":"第三方库","slug":"第三方库","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}]},{"title":"iOS第三方库-FMDB-模型进行存取(Model)","slug":"iOS第三方库-FMDB-模型进行存取(Model)","date":"2020-01-16T08:04:24.813Z","updated":"2020-01-20T01:48:38.873Z","comments":true,"path":"2020/01/16/iOS第三方库-FMDB-模型进行存取(Model)/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-FMDB-%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%8F%96(Model)/","excerpt":"","text":"写这个Blog的目的是为了记录的学习经历，代码写的不是很好，希望读者理解。日常对数据库的操作，需要设计字段，感觉太繁琐了，想找个简化的方法，就想通过这样进行实现，这也就是一种思考方式。实际实现还是看需求。具体看代码：1、导入FMDB 1import FMDB 2、使用单利模式和必要属性 1234static let defaultManger &#x3D; WDDataBaseManager()typealias successBlock &#x3D; () -&gt;Voidtypealias failBlock &#x3D; () -&gt;Voidprivate var tableName:String? 3、懒加载创建数据库（名称我随便取得） 12345lazy var fmdb:FMDatabase &#x3D; &#123; let path &#x3D; NSHomeDirectory().appending(&quot;&#x2F;Documents&#x2F;testDB.db&quot;) let db &#x3D; FMDatabase(path: path) return db &#125;() 4、创建表 123456789func creatTable(tableName:String) -&gt; Void &#123; fmdb.open() self.tableName &#x3D; tableName let creatSql &#x3D; &quot;create table if not exists \\(tableName) (id integer primary key autoincrement,model BLOB)&quot; let result &#x3D; fmdb.executeUpdate(creatSql, withArgumentsIn:[]) if result&#123; print(&quot;创建表成功&quot;) &#125; &#125; 5、删除表 1234567func dropTable() -&gt; Void &#123; let sql &#x3D; &quot;drop table if exists &quot; + tableName! let result &#x3D; fmdb.executeUpdate(sql, withArgumentsIn:[]) if result&#123; print(&quot;删除表成功&quot;) &#125; &#125; 6、插入数据 1234567891011func insert(model:NSObject, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let modelData &#x3D; try! NSKeyedArchiver.archivedData(withRootObject: model, requiringSecureCoding: false) let insertSql &#x3D; &quot;insert into &quot; + tableName! + &quot; (model) values(?)&quot; do &#123; try fmdb.executeUpdate(insertSql, values: [modelData]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 7、更新表 1234567891011func update(model:NSObject,uid:Int32, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let modelData &#x3D; try! NSKeyedArchiver.archivedData(withRootObject: model, requiringSecureCoding: false) let updateSql &#x3D; &quot;update &quot; + tableName! + &quot; set model &#x3D; ? where id &#x3D; ?&quot; do &#123; try fmdb.executeUpdate(updateSql, values: [modelData, uid]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 8、查询数据（这是查询所有数据，其他按需求设计） 123456789101112131415161718func selectAll() -&gt; [NSObject] &#123; var tmpArr &#x3D; [NSObject]() let selectSql &#x3D; &quot;select * from &quot; + tableName! do &#123; let rs &#x3D; try fmdb.executeQuery(selectSql, values:nil) while rs.next() &#123; var model &#x3D; NSObject() let modelData &#x3D; rs.data(forColumn:&quot;model&quot;) let id &#x3D; rs.int(forColumn: &quot;id&quot;) model &#x3D; try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(modelData!) as! NSObject model.wd_fmdb_id &#x3D; id tmpArr.append(model) &#125; &#125; catch &#123; print(fmdb.lastError()) &#125; return tmpArr &#125; 9、删除数据（这是根据Id删除的） 12345678910func delete(uid:Int32, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let deleteSql &#x3D; &quot;delete from &quot; + tableName! + &quot; where id &#x3D; ?&quot; do &#123; try fmdb.executeUpdate(deleteSql, values: [uid]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 10、新增分类添加默认Id 1234567891011private var wd_id_key: String &#x3D; &quot;key&quot;extension NSObject &#123; open var wd_fmdb_id:Int32? &#123; get &#123; return (objc_getAssociatedObject(self, &amp;wd_id_key) as? Int32) &#125; set(newValue) &#123; objc_setAssociatedObject(self, &amp;wd_id_key, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125; 11、使用方法 12345678910111213141516171819202122232425&#x2F;&#x2F;1. 在Appdelegate中打开数据库func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; DataBaseManager.defaultManger.creatTable() return true &#125;&#x2F;&#x2F;2、添加数据WDDataBaseManager.defaultManger.insert(model: model, successBlock: &#123; print(&quot;成功&quot;) &#125;, failBlock: &#123; print(&quot;失败&quot;) &#125;)&#x2F;&#x2F;3、修改数据WDDataBaseManager.defaultManger.update(model: model, uid: self.model!.wd_fmdb_id!, successBlock: &#123; print(&quot;成功&quot;) &#125;, failBlock: &#123; print(&quot;失败&quot;) &#125;)&#x2F;&#x2F;4、删除数据WDDataBaseManager.defaultManger.delete(uid: model.wd_fmdb_id!, successBlock: &#123; print(&quot;成功&quot;) &#125;, failBlock: &#123; print(&quot;失败&quot;) &#125;)&#x2F;&#x2F; 5、查询数据WDDataBaseManager.defaultManger.selectAll() 遵循NSCoding 重写三个方法12345678910111213141516171819202122232425import UIKitclass Model: NSObject , NSCoding&#123; public var name:String? public var phone:String? public var addres:String? override init() &#123; super.init() &#125; func encode(with aCoder: NSCoder) &#123; aCoder.encode(name, forKey: &quot;name&quot;) aCoder.encode(phone, forKey: &quot;phone&quot;) aCoder.encode(addres, forKey: &quot;addres&quot;) &#125; required init?(coder aDecoder: NSCoder) &#123; super.init() self.name &#x3D; aDecoder.decodeObject(forKey: &quot;name&quot;) as? String self.addres &#x3D; aDecoder.decodeObject(forKey: &quot;addres&quot;) as? String self.phone &#x3D; aDecoder.decodeObject(forKey: &quot;phone&quot;) as? String &#125;&#125; 12、效果图 13、Demo地址:https://github.com/wudan-ios/FMDB-Model.git 补充Objective-C版本1、接口文件 12345678910111213141516171819202122232425262728293031#import &lt;Foundation&#x2F;Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSObject (addId)@property (nonatomic) NSInteger wd_fmdb_id;@endtypedef void(^successBlock)(void);typedef void(^failBlock)(void);@interface WDDataBaseManager : NSObject+ (instancetype)manager;&#x2F;** 创建表 *&#x2F;- (void)createTableWithName:(NSString *)name;&#x2F;** 删除表 *&#x2F;- (void)dropTable;&#x2F;** 添加数据 *&#x2F;- (void)insertDataWithModel:(NSObject *)model successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;&#x2F;** 更新数据 *&#x2F;- (void)updateDataWithModel:(NSObject *)model uid:(NSInteger)aUid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;&#x2F;** 删除数据 *&#x2F;- (void)deleteDataWithUid:(NSInteger)uid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;&#x2F;** 查询全部数据 *&#x2F;- (NSArray&lt;NSObject *&gt; *)queryAllData;@endNS_ASSUME_NONNULL_END 2、实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#import &quot;WDDataBaseManager.h&quot;#import &lt;FMDB.h&gt;#import &lt;objc&#x2F;runtime.h&gt;static char *wd_id_key &#x3D; &quot;key&quot;;@implementation NSObject (addId)- (NSInteger)wd_fmdb_id &#123; NSNumber *numberValue &#x3D; objc_getAssociatedObject(self, wd_id_key); return numberValue.integerValue;&#125;- (void)setWd_fmdb_id:(NSInteger)wd_fmdb_id &#123; objc_setAssociatedObject(self, wd_id_key, @(wd_fmdb_id), OBJC_ASSOCIATION_ASSIGN);&#125;@end@interface WDDataBaseManager ()@property (nonatomic, strong) FMDatabase *fmdb;@property (nonatomic, copy) NSString *tableName;@end@implementation WDDataBaseManager+ (instancetype)manager &#123; static dispatch_once_t onceToken; static WDDataBaseManager *manager &#x3D; nil; dispatch_once(&amp;onceToken, ^&#123; manager &#x3D; [[WDDataBaseManager alloc] init]; &#125;); return manager;&#125;- (void)createTableWithName:(NSString *)name &#123; [self.fmdb open]; self.tableName &#x3D; name; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;create table if not exists %@ (id integer primary key autoincrement,model BLOB)&quot;, name]; BOOL result &#x3D; [self.fmdb executeUpdate:sql]; if (result) &#123; NSLog(@&quot;表创建成功&quot;); &#125;&#125;- (void)dropTable &#123; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;drop table if exists %@&quot;, self.tableName]; BOOL result &#x3D; [self.fmdb executeUpdate:sql]; if (result) &#123; NSLog(@&quot;表删除成功&quot;); &#125;&#125;- (void)insertDataWithModel:(NSObject *)model successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSData *modelData &#x3D; [NSKeyedArchiver archivedDataWithRootObject:model]; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;insert into %@ (model) values(?)&quot;, self.tableName]; BOOL result &#x3D; [self.fmdb executeUpdate:sql withArgumentsInArray:@[modelData]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (void)updateDataWithModel:(NSObject *)model uid:(NSInteger)aUid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSData *modelData &#x3D; [NSKeyedArchiver archivedDataWithRootObject:model]; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;update %@ set model &#x3D; ? where id &#x3D; ?&quot;, self.tableName]; BOOL result &#x3D; [self.fmdb executeUpdate:sql withArgumentsInArray:@[modelData, @(aUid)]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (void)deleteDataWithUid:(NSInteger)uid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;delete from %@ where id &#x3D; ?&quot;, self.tableName]; BOOL result &#x3D; [self.fmdb executeUpdate:sql withArgumentsInArray:@[@(uid)]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (NSArray&lt;NSObject *&gt; *)queryAllData &#123; NSMutableArray *array &#x3D; [NSMutableArray array]; NSString *sql &#x3D; [NSString stringWithFormat:@&quot;select * from %@&quot;,self.tableName]; @try &#123; FMResultSet *rs &#x3D; [self.fmdb executeQuery:sql]; while (rs.next) &#123; NSObject *model &#x3D; [[NSObject alloc] init]; NSData *modelData &#x3D; [rs dataForColumn:@&quot;model&quot;]; int uid &#x3D; [rs intForColumn:@&quot;id&quot;]; model &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:modelData]; model.wd_fmdb_id &#x3D; uid; [array addObject:model]; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;%@&quot;, self.fmdb.lastError); &#125; @finally &#123; NSLog(@&quot;查询数据&quot;); &#125; return array;&#125;- (FMDatabase *)fmdb &#123; if (!_fmdb) &#123; NSString *path &#x3D; [NSHomeDirectory() stringByAppendingString:@&quot;&#x2F;Documents&#x2F;testDB.db&quot;]; _fmdb &#x3D; [[FMDatabase alloc] initWithPath:path]; &#125; return _fmdb;&#125;@end 3、使用方法 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 1、打开数据库，并创建表- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[WDDataBaseManager manager] createTableWithName:@&quot;test&quot;]; return YES;&#125;&#x2F;&#x2F; 2、添加数据 [[WDDataBaseManager manager] insertDataWithModel:model successBlock:^&#123; &#x2F;&#x2F; TODO: &#125; failBlock:^&#123; &#x2F;&#x2F; TODO: &#125;];&#x2F;&#x2F; 3、查询数据[[WDDataBaseManager manager] queryAllData]&#x2F;&#x2F; 4、修改数据[[WDDataBaseManager manager] updateDataWithModel:model uid:self.model.wd_fmdb_id successBlock:^&#123; &#x2F;&#x2F; TODO: &#125; failBlock:^&#123; &#x2F;&#x2F; TODO: &#125;];&#x2F;&#x2F; 5、删除数据[[WDDataBaseManager manager] deleteDataWithUid:model.wd_fmdb_id successBlock:^&#123; &#x2F;&#x2F; TODO: &#125; failBlock:^&#123; &#x2F;&#x2F; TODO: &#125;];&#x2F;&#x2F; 6、删除表[[WDDataBaseManager manager] dropTable]; 插入表中的Model需要遵循(实例代码)1234567891011121314- (void)encodeWithCoder:(nonnull NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@&quot;name&quot;]; [aCoder encodeObject:self.phone forKey:@&quot;phone&quot;]; [aCoder encodeObject:self.address forKey:@&quot;address&quot;];&#125;- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder &#123; if (self &#x3D;&#x3D; [super init]) &#123; self.name &#x3D; [aDecoder decodeObjectForKey:@&quot;name&quot;] ; self.phone &#x3D; [aDecoder decodeObjectForKey:@&quot;phone&quot;]; self.address &#x3D; [aDecoder decodeObjectForKey:@&quot;address&quot;]; &#125; return self;&#125;","categories":[],"tags":[{"name":"第三方库","slug":"第三方库","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}]},{"title":"iOS第三方库-AFNetworking&SDWebImage原理","slug":"iOS第三方库-AFNetworking&SDWebImage原理","date":"2020-01-16T08:04:20.887Z","updated":"2020-01-20T01:48:47.482Z","comments":true,"path":"2020/01/16/iOS第三方库-AFNetworking&SDWebImage原理/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-AFNetworking&SDWebImage%E5%8E%9F%E7%90%86/","excerpt":"","text":"AFNetworkingNSURLSession NSURLSession NSURLSessionConfiguation NSURLSessionTask NSURLSessionTask NSURLSessionDataTask NSURLSessionDownLoadTask NSURLSessionUploadTask 网络请求的过程 创建NSURLSessionConfig对象–用创建的config对象配置初始化NSURLSession–创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。 AFURLSessionManager封装了上述网络交互功能 AFURLSessionManager请求过程 1.初始化AFURLSessionManager。 2.获取AFURLSessionManager的Task对象 3.启动Task AFNetworking由五个模块组成： NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager,AFHTTPSessionManager是继承于AFURLSessionmanager Security：网络通讯安全策略模块 对应 AFSecurityPolicy Reachability：网络状态监听模块 对应AFNetworkReachabilityManager Seriaalization：网络通信信息序列化、反序列化模块 对应 AFURLResponseSerialization UIKit：对于IOSUIKit的扩展库 SDWebImage图片解释： 内存层面的相当是个缓存器，以Key-Value的形式存储图片。 当内存不够的时候会清除所有缓存图片。 用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。 当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。 实现过程 1、入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 2、进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:. 3、如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。 4、SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。 5、如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。 6、根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。 7、如果硬盘中有该图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。 8、如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。 9、共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 10、图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。 11、imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。 12、通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 13、将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。","categories":[],"tags":[{"name":"第三方库","slug":"第三方库","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}]},{"title":"iOS底层-RunLoop","slug":"iOS底层-RunLoop","date":"2020-01-16T08:04:14.498Z","updated":"2020-01-20T02:34:50.181Z","comments":true,"path":"2020/01/16/iOS底层-RunLoop/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%BA%95%E5%B1%82-RunLoop/","excerpt":"","text":"一、概念RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象。 1、没有消息处理时，休眠已避免资源占用，由用户态切换到内核态(CPU-内核态和用户态)2、有消息需要处理时，立刻被唤醒，由内核态切换到用户态 为什么main函数不会退出？ 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段无限循环的代码（不是简单的for循环或while循环） 12345678910&#x2F;&#x2F;无限循环代码模式(伪代码)int main(int argc, char * argv[]) &#123; BOOL running &#x3D; YES; do &#123; &#x2F;&#x2F; 执行各种任务，处理各种事件 &#x2F;&#x2F; ...... &#125; while (running); return 0;&#125; UIApplicationMain函数一直没有返回，而是不断地接收处理消息以及等待休眠，所以运行程序之后会保持持续运行状态。 二、RunLoop的数据结构NSRunLoop(Foundation)是CFRunLoop(CoreFoundation)的封装，提供了面向对象的APIRunLoop 相关的主要涉及五个类： CFRunLoop：RunLoop对象CFRunLoopMode：运行模式CFRunLoopSource：输入源/事件源CFRunLoopTimer：定时源CFRunLoopObserver：观察者 1、CFRunLoop 由pthread(线程对象，说明RunLoop和线程是一一对应的)、currentMode(当前所处的运行模式)、modes(多个运行模式的集合)、commonModes(模式名称字符串集合)、commonModelItems(Observer,Timer,Source集合)构成 2、CFRunLoopMode 由name、source0、source1、observers、timers构成 3、CFRunLoopSource 分为source0和source1两种 source0:即非基于port的，也就是用户触发的事件。需要手动唤醒线程，将当前线程从内核态切换到用户态 source1:基于port的，包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒RunLoop，接收分发系统事件。具备唤醒线程的能力 4、CFRunLoopTimer 基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒RunLoop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。 5、CFRunLoopObserver 监听以下时间点:CFRunLoopActivity kCFRunLoopEntryRunLoop准备启动 kCFRunLoopBeforeTimersRunLoop将要处理一些Timer相关事件 kCFRunLoopBeforeSourcesRunLoop将要处理一些Source事件 kCFRunLoopBeforeWaitingRunLoop将要进行休眠状态,即将由用户态切换到内核态 kCFRunLoopAfterWaitingRunLoop被唤醒，即从内核态切换到用户态后 kCFRunLoopExitRunLoop退出 kCFRunLoopAllActivities监听所有状态 6、各数据结构之间的联系 线程和RunLoop一一对应， RunLoop和Mode是一对多的，Mode和source、timer、observer也是一对多的 三、RunLoop的Mode关于Mode首先要知道一个RunLoop 对象中可能包含多个Mode，且每次调用 RunLoop 的主函数时，只能指定其中一个 Mode(CurrentMode)。切换 Mode，需要重新指定一个 Mode 。主要是为了分隔开不同的 Source、Timer、Observer，让它们之间互不影响。 当RunLoop运行在Mode1上时，是无法接受处理Mode2或Mode3上的Source、Timer、Observer事件的 总共是有五种CFRunLoopMode: kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行 UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响） UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案 四、RunLoop的实现机制对于RunLoop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。RunLoop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。 RunLoop通过mach_msg()函数接收、发送消息。它的本质是调用函数mach_msg_trap()，相当于是一个系统调用，会触发内核状态切换。在用户态调用 mach_msg_trap()时会切换到内核态；内核态中内核实现的mach_msg()函数会完成实际的工作。即基于port的source1，监听端口，端口有消息就会触发回调；而source0，要手动标记为待处理和手动唤醒RunLoop Mach消息发送机制大致逻辑为：1、通知观察者 RunLoop 即将启动。2、通知观察者即将要处理Timer事件。3、通知观察者即将要处理source0事件。4、处理source0事件。5、如果基于端口的源(Source1)准备好并处于等待状态，进入步骤9。6、通知观察者线程即将进入休眠状态。7、将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。 一个基于 port 的Source1 的事件(图里应该是source0)。 一个 Timer 到时间了。 RunLoop 自身的超时时间到了。 被其他调用者手动唤醒。 8、通知观察者线程将被唤醒。9、处理唤醒时收到的事件。 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。 如果输入源启动，传递相应的消息。 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2 10、通知观察者RunLoop结束。 五、RunLoop与NSTimer一个比较常见的问题：滑动tableView时，定时器还会生效吗？默认情况下RunLoop运行在kCFRunLoopDefaultMode下，而当滑动tableView时，RunLoop切换到UITrackingRunLoopMode，而Timer是在kCFRunLoopDefaultMode下的，就无法接受处理Timer的事件。怎么去解决这个问题呢？把Timer添加到UITrackingRunLoopMode上并不能解决问题，因为这样在默认情况下就无法接受定时器事件了。所以我们需要把Timer同时添加到UITrackingRunLoopMode和kCFRunLoopDefaultMode上。那么如何把timer同时添加到多个mode上呢？就要用到NSRunLoopCommonModes了 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; Timer就被添加到多个mode上，这样即使RunLoop由kCFRunLoopDefaultMode切换到UITrackingRunLoopMode下，也不会影响接收Timer事件 六、RunLoop和线程 线程和RunLoop是一一对应的,其映射关系是保存在一个全局的 Dictionary 里 自己创建的线程默认是没有开启RunLoop的 1、怎么创建一个常驻线程？ 1、为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）2、向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）3、启动该RunLoop 123456789@autoreleasepool &#123; NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop]; [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125; 2、输出下边代码的执行顺序 123456789101112131415161718NSLog(@&quot;1&quot;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [self performSelector:@selector(test) withObject:nil afterDelay:10]; NSLog(@&quot;3&quot;);&#125;);NSLog(@&quot;4&quot;);- (void)test&#123; NSLog(@&quot;5&quot;);&#125; 答案是1423，test方法并不会执行。原因是如果是带afterDelay的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的RunLoop中。也就是如果当前线程没有开启RunLoop，该方法会失效。那么我们改成: 12345678910dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [[NSRunLoop currentRunLoop] run]; [self performSelector:@selector(test) withObject:nil afterDelay:10]; NSLog(@&quot;3&quot;); &#125;); 然而test方法依然不执行。原因是如果RunLoop的mode中一个item都没有，RunLoop会退出。即在调用RunLoop的run方法后，由于其mode中没有添加任何item去维持RunLoop的时间循环，RunLoop随即还是会退出。所以我们自己启动RunLoop，一定要在添加item后 12345678910dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [self performSelector:@selector(test) withObject:nil afterDelay:10]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;3&quot;); &#125;); 3、怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？ 当我们在子请求数据的同时滑动浏览当前页面，如果数据请求成功要切回主线程更新UI，那么就会影响当前正在滑动的体验。我们就可以将更新UI事件放在主线程的NSDefaultRunLoopMode上执行即可，这样就会等用户不再滑动页面，主线程RunLoop由UITrackingRunLoopMode切换到NSDefaultRunLoopMode时再去更新UI 1[self performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]]; 问题1. 如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？一般做法是向 Runloop 中放一个 port。创建一条常驻的后台线程，做任何你想做的事。 2. 为什么 NSTimer 有时候不好使？因为创建的 NSTimer 默认是被加入到了 defaultMode，所以当 Runloop 的 Mode 变化时，当前的 NSTimer 就不会工作了。 3. autoreleasePool 在何时被释放？App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 4. PerformSelector 的实现原理？当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 5. PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？不起作用，子线程默认没有 Runloop，也就没有 Timer。解决的办法是可以使用 GCD 来实现：Dispatch_after\u0010 6. 讲一下 Observer ？12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 7. 解释一下 事件响应 的过程？苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 8. 解释一下 手势识别 的过程？当上面的 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 9. 解释一下 GCD 在 Runloop 中的使用？GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。 10. 解释一下 NSTimer。NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。 11. 利用 runloop 解释一下页面的渲染的过程？当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。 这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。 紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。 CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。 如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。 如果没有 delegate，那么会调用 [CALayer drawInContext:]。 以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。 至此绘制的过程结束。","categories":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"runloop","slug":"runloop","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/runloop/"}]},{"title":"iOS底层-Block","slug":"iOS底层-Block","date":"2020-01-16T08:01:00.860Z","updated":"2020-01-20T01:49:59.044Z","comments":true,"path":"2020/01/16/iOS底层-Block/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%BA%95%E5%B1%82-Block/","excerpt":"","text":"Block的实质本质上也是一个OC对象，他内部也有一个isa指针。Block是封装了函数调用以及函数调用环境的OC对象。 Block三种类型 类型 存储区域 GlobalBlock 数据区 StackBlock 栈区 MallocBlock 堆区 Block避免循环引用的三种方式1、利用 __weak和__strong 123456 __weak typeof(self) weakSelf &#x3D; self;self.block &#x3D; ^&#123; __strong typeof(self) strongSelf &#x3D; weakSelf; NSLog(@&quot;%@&quot;, NSStringFromCGRect(strongSelf.view.frame));&#125;;self.block(); 2、利用造成循环引用的临时变量 123456__block ViewController *vc &#x3D; self;self.block &#x3D; ^&#123; NSLog(@&quot;%@&quot;, NSStringFromCGRect(vc.view.frame)); vc &#x3D; nil;&#125;;self.block(); 3、直接声明Block中添加造成循环引用的参数 123456typedef void(^Block)(UIViewController *vc);self.block &#x3D; ^(UIViewController *vc)&#123; NSLog(@&quot;%@&quot;, NSStringFromCGRect(vc.view.frame));&#125;;self.block(self);","categories":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Block","slug":"Block","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/Block/"}]},{"title":"iOS多线程-GCD","slug":"iOS多线程-GCD","date":"2020-01-16T08:00:40.362Z","updated":"2020-01-20T01:46:03.175Z","comments":true,"path":"2020/01/16/iOS多线程-GCD/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/","excerpt":"","text":"任务就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。 同步执行（sync）同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。只能在当前线程中执行任务，不具备开启新线程的能力。 异步执行（async）异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。可以在新的线程中执行任务，具备开启新线程的能力。 队列执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。 串行队列（Serial Dispatch Queue）每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务） 并发队列（Concurrent Dispatch Queue）可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务） 注意：并发队列 的并发功能只有在异步（dispatch_async）函数下才有效 dispatch_queue_t 任务 队列 同步 串行 异步 并发 #### 组合结果 组合 结果 — — 同步执行 + 并发队列 在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务 异步执行 + 并发队列 可以开启多个线程，任务交替（同时）执行 同步执行 + 串行队列 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务 异步执行 + 串行队列 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务 同步执行 + 主队列 在主线程中调用会出现死锁，而在其他线程中则不会 异步执行 + 主队列 互相等待卡住不可行 创建串行队列常用宏定义 名称 值 DISPATCH_QUEUE_SERIAL NULL DISPATCH_QUEUE_SERIAL_INACTIVE dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL) DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL dispatch_queue_attr_make_with_autorelease_frequency(DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM) 1dispatch_queue_create(&quot;标识&quot;, DISPATCH_QUEUE_SERIAL); 并发队列常用宏定义 名称 值 DISPATCH_QUEUE_CONCURRENT NULL DISPATCH_QUEUE_CONCURRENT_INACTIVE dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT) DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL dispatch_queue_attr_make_with_autorelease_frequency(DISPATCH_QUEUE_SERIAL,DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM) 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;标识&quot;, DISPATCH_QUEUE_CONCURRENT); 获取主线程1dispatch_get_main_queue(); 获取系统默认的全局并发队列iOS 8.0 名称 意义 QOS_CLASS_USER_INTERACTIVE 用户交互(希望尽快完成，用户对结果很期望，不要放太耗时操作) QOS_CLASS_USER_INITIATED 用户期望(不要放太耗时操作) QOS_CLASS_DEFAULT 默认(不是给程序员使用的，用来重置对列使用的) QOS_CLASS_UTILITY 实用工具(耗时操作，可以使用这个选项) QOS_CLASS_BACKGROUND 后台 QOS_CLASS_UNSPECIFIED 未指定 iOS 8.0之前 名称 意义 DISPATCH_QUEUE_PRIORITY_HIGH 高优先级 DISPATCH_QUEUE_PRIORITY_DEFAULT 默认优先级 DISPATCH_QUEUE_PRIORITY_LOW 低优先级 DISPATCH_QUEUE_PRIORITY_BACKGROUND 后台优先级 1dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 异步执行123456789101112131415161718int context &#x3D; 10;&#x2F;** 队列异步执行 @param queue 队列 @param context 要传递给函数的应用程序定义的上下文参数。 @param asyncMethod c操作方法 @return dispatch_queue_t*&#x2F;dispatch_async_f(queue, &amp;context, asyncMethod);void asyncMethod() &#123; &#x2F;&#x2F; TODO&#125;dispatch_sync(queue, ^&#123; &#x2F;&#x2F; TODO&#125;); 同步执行123456789101112131415161718int context &#x3D; 10;&#x2F;** 队列同步执行 @param queue 队列 @param context 要传递给函数的应用程序定义的上下文参数。 @param syncMethod c操作方法 @return dispatch_queue_t *&#x2F;dispatch_sync_f(queue, &amp;context, syncMethod);void syncMethod() &#123; &#x2F;&#x2F; TODO&#125;dispatch_sync(queue, ^&#123; &#x2F;&#x2F; TODO&#125;); 延迟操作12345678910int context &#x3D; 10;dispatch_after_f(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.2 * NSEC_PER_SEC)), queue, &amp;context, afterMethod);void afterMethod() &#123; &#x2F;&#x2F; TODO&#125;dispatch_queue_t queue &#x3D; dispatch_get_main_queue(); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.2 * NSEC_PER_SEC)), queue, ^&#123; &#x2F;&#x2F; TODO&#125;); 快速迭代12345678910int context &#x3D; 1;&#x2F;&#x2F; 执行10次applyMethod函数dispatch_apply_f(10, queue, &amp;context, applyMethod);void applyMethod() &#123; &#x2F;&#x2F; TODO&#125;dispatch_apply(10, queue, ^(size_t index) &#123; &#x2F;&#x2F; TODO&#125;); 执行一次123456789dispatch_once_f(&amp;onceToken, &amp;context, onceMethod);void onceMethod() &#123; &#x2F;&#x2F; TODO&#125;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; &#x2F;&#x2F; TODO&#125;); 栅栏方法将队列执行的操作组给分割起来。 dispatch_barrier_async12345678910int context &#x3D; 10;dispatch_barrier_async_f(queue, &amp;context, barrierAsync);void barrierAsync() &#123; &#x2F;&#x2F; TODO&#125;dispatch_barrier_async(queue, ^&#123; &#x2F;&#x2F; TODO&#125;); dispatch_barrier_sync12345678910int context &#x3D; 10;dispatch_barrier_sync_f(queue, &amp;context, barrierAsync);void barrierSync() &#123; &#x2F;&#x2F; TODO&#125;dispatch_barrier_sync(queue, ^&#123; &#x2F;&#x2F; TODO&#125;); dispatch_barrier_sync和dispatch_barrier_async的共同点： 1、都会等待在它前面插入队列的任务先执行完 2、都会等待他们自己的任务执行完再执行后面的任务 dispatch_barrier_sync和dispatch_barrier_async的不共同点： 在将任务插入到queue的时候，dispatch_barrier_sync需要等待自己的任务结束之后才会继续程序，然后插入被写在它后面的任务，然后执行后面的任务而dispatch_barrier_async将自己的任务插入到queue之后，不会等待自己的任务结束，它会继续把后面的任务插入到queue。 所以，dispatch_barrier_async的不等待（异步）特性体现在将任务插入队列的过程，它的等待特性体现在任务真正执行的过程。 dispatch_semaphoreGCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。 Dispatch Semaphore 提供了三个函数。 dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量 dispatch_semaphore_signal：发送一个信号，让信号总量加1 dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。 Dispatch Semaphore 在实际开发中主要用于： 保持线程同步，将异步执行任务转换为同步执行任务 保证线程安全，为线程加锁 Dispatch Semaphore 线程同步我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。 123456789101112131415161718192021- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks &#x3D; nil; dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks &#x3D; dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks &#x3D; uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks &#x3D; downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks &#x3D; [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;]; &#125; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125; Dispatch Semaphore 线程安全和线程同步（为线程加锁） 线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。 非线程安全（不使用 semaphore）先来看看不考虑线程安全的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;** * 非线程安全：不使用 semaphore * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票 *&#x2F;- (void)initTicketStatusNotSave &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 NSLog(@&quot;semaphore---begin&quot;); self.ticketSurplusCount &#x3D; 50; &#x2F;&#x2F; queue1 代表北京火车票售卖窗口 dispatch_queue_t queue1 &#x3D; dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL); &#x2F;&#x2F; queue2 代表上海火车票售卖窗口 dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL); __weak typeof(self) weakSelf &#x3D; self; dispatch_async(queue1, ^&#123; [weakSelf saleTicketNotSafe]; &#125;); dispatch_async(queue2, ^&#123; [weakSelf saleTicketNotSafe]; &#125;);&#125;&#x2F;** * 售卖火车票(非线程安全) *&#x2F;- (void)saleTicketNotSafe &#123; while (1) &#123; if (self.ticketSurplusCount &gt; 0) &#123; &#x2F;&#x2F;如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; &#x2F;&#x2F;如果已卖完，关闭售票窗口 NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; &#125;&#125; 输出结果（部分）：2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread—&lt;NSThread: 0x604000068880&gt;{number = 1, name = main} 2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore—begin 2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)} 2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：&lt;NSThread: 0x60000027e740&gt;{number = 4, name = (null)} 2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：&lt;NSThread: 0x60000027e740&gt;{number = 4, name = (null)} 2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)} 2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)} 可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。 线程安全（使用 semaphore 加锁）考虑线程安全的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x2F;** * 线程安全：使用 semaphore 加锁 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票 *&#x2F;- (void)initTicketStatusSave &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 NSLog(@&quot;semaphore---begin&quot;); semaphoreLock &#x3D; dispatch_semaphore_create(1); self.ticketSurplusCount &#x3D; 50; &#x2F;&#x2F; queue1 代表北京火车票售卖窗口 dispatch_queue_t queue1 &#x3D; dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL); &#x2F;&#x2F; queue2 代表上海火车票售卖窗口 dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL); __weak typeof(self) weakSelf &#x3D; self; dispatch_async(queue1, ^&#123; [weakSelf saleTicketSafe]; &#125;); dispatch_async(queue2, ^&#123; [weakSelf saleTicketSafe]; &#125;);&#125;&#x2F;** * 售卖火车票(线程安全) *&#x2F;- (void)saleTicketSafe &#123; while (1) &#123; &#x2F;&#x2F; 相当于加锁 dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER); if (self.ticketSurplusCount &gt; 0) &#123; &#x2F;&#x2F;如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; &#x2F;&#x2F;如果已卖完，关闭售票窗口 NSLog(@&quot;所有火车票均已售完&quot;); &#x2F;&#x2F; 相当于解锁 dispatch_semaphore_signal(semaphoreLock); break; &#125; &#x2F;&#x2F; 相当于解锁 dispatch_semaphore_signal(semaphoreLock); &#125;&#125; 输出结果为：2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread—&lt;NSThread: 0x6000000783c0&gt;{number = 1, name = main} 2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore—begin 2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)} 2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)} 2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)} …2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)} 2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)} 2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)} 2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)} 2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)} 2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完 2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完 可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。 dispatch_group多个任务放到一个组中。 dispatch_group_t创建1dispatch_group_t group &#x3D; dispatch_group_create(); 添加任务1234567891011dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL);int context &#x3D; 10;dispatch_group_async_f(group, queue, &amp;context, groupMethod);void groupMethod() &#123; &#x2F;&#x2F; TODO&#125;dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL);dispatch_group_async(group, queue, ^&#123; &#x2F;&#x2F; TODO&#125;); 其他操作1. 获取任务组任务完成，进行操作1234567891011&#x2F;&#x2F; 所有任务执行完，通知调度组，在queue上异步执行block，不会阻塞当前任务dispatch_group_notify_f(group, queue5, &amp;context, groupMethod);void groupMethod() &#123; &#x2F;&#x2F; TODO&#125;&#x2F;&#x2F; dispatch_group_notify_f的封装 dispatch_group_notify(group, queue, ^&#123; &#x2F;&#x2F; TODO&#125;); 2. 通知group，下面的任务马上要放到group中执行了。1dispatch_group_enter(group); 3. 通知group，任务完成了，该任务要从group中移除了。1dispatch_group_leave(group); 4. 设置超时假设创建dispatch_group_wait里的dispatch_time等待时间是4秒,那么group里的内容在4s内完成的话,那wait直接结束,如果group在4s内没有执行完,那么wait也会结束,结束之后,周末的任务就会被加进来了。 123456long result &#x3D; dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 4.0 * NSEC_PER_SEC));if (result) &#123; NSLog(@&quot;超过等待时间了&quot;);&#125; else &#123; NSLog(@&quot;时间没有超过等待时间&quot;);&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/Objective-C/"}],"tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}]},{"title":"iOS底层-Runtime-消息转发","slug":"iOS底层-Runtime-消息转发","date":"2020-01-16T07:59:00.220Z","updated":"2020-01-20T01:49:12.480Z","comments":true,"path":"2020/01/16/iOS底层-Runtime-消息转发/","link":"","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/2020/01/16/iOS%E5%BA%95%E5%B1%82-Runtime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/","excerpt":"","text":"iOS 方法的动态解析和消息转发 以创建的Message类为示例Message.h 1234567@interface Message : NSObject- (void)sendMessage:(NSString *)message;+ (void)sendClassMessage:(NSString *)message;@end Message.m 123@implementation Message@end 动态方法解析征询接收者所属的类，是否需要动态添加类方法或实例方法，来处理这个未找到的方法。 首先判断是否实现了 resolveInstanceMethod，如果没有实现，进入下一步处理； 如果实现了，调用 resolveInstanceMethod，获取返回值； 如果返回值为 YES，表示 resolveInstanceMethod 声称它已经提供了 selector 的实现，因此再次查找 method list，如果找到对应的 IMP，则返回该实现，否则提示警告信息，进入下一步处理； 如果返回值为 NO，进入下一步处理；1. 对象方法通过+ (BOOL)resolveInstanceMethod:(SEL)sel;方法进行解析1234567891011+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel &#x3D;&#x3D; @selector(sendMessage:)) &#123; class_addMethod([self class], sel, (IMP)innerSenderMessageMetod, &quot;v@:@&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void innerSenderMessageMetod(id obj, SEL _cmd) &#123; NSLog(@&quot;对象方法，动态解析&quot;);&#125; 2. 类方法通过+ (BOOL)resolveClassMethod:(SEL)sel;方法进行解析1234567891011+ (BOOL)resolveClassMethod:(SEL)sel &#123; if (sel &#x3D;&#x3D; @selector(sendClassMessage:)) &#123; class_addMethod(object_getClass(self), sel, (IMP)innerSenderClassMessageMetod, &quot;v@:@&quot;); return YES; &#125; return [super resolveClassMethod:sel];&#125;void innerSenderClassMessageMetod(id obj, SEL _cmd) &#123; NSLog(@&quot;类方法，动态解析&quot;);&#125; 重定向如果没有动态添加方法，则会进入此阶段，此时询问是否要将这条消息转发给其他的对象，来处理这个方法。如果返回nil，即表示不转发给其他对象，此时会进入第3阶段创建了一个备用类MessageTempMessageTemp.h12345@interface MessageTemp : NSObject- (void)sendMessage:(NSString *)message;- (void)sendClassMessage:(NSString *)message;@end MessageTemp.m12345678@implementation MessageTemp- (void)sendMessage:(NSString *)message &#123; NSLog(@&quot;备用Message，解析对象方法&quot;);&#125;- (void)sendClassMessage:(NSString *)message &#123; NSLog(@&quot;备用Message，解析类方法&quot;);&#125;@end 1. 对象方法123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector &#x3D;&#x3D; @selector(sendMessage:)) &#123; return [MessageTemp new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 2. 类方法123456+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector &#x3D;&#x3D; @selector(sendClassMessage:)) &#123; return [MessageTemp new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 消息转发当 forwardingTargetForSelector: 方法未做出任何响应的话，会来到消息转发流程。消息转发时会首先调用 methodSignatureForSelector: 方法，在方法内部生成 NSMethodSignature 类型的方法签名对象。在生成签名对象时，可以指定 target 和 SEL，可以将这两个参数换成其他参数，将消息转发给其他对象。1. 对象方法1234567891011121314- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([anInvocation selector] &#x3D;&#x3D; @selector(sendMessage:)) &#123; [anInvocation invokeWithTarget:[MessageTemp new]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector &#x3D;&#x3D; @selector(sendMessage:)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125; 2. 类方法1234567891011121314+ (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([anInvocation selector] &#x3D;&#x3D; @selector(sendClassMessage:)) &#123; [anInvocation invokeWithTarget:[MessageTemp new]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector &#x3D;&#x3D; @selector(sendClassMessage:)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125; 应用场景 适用于把操作给另外一个类来实现 利用分类，防止应用程序因为未处理消息而崩溃 Jspatch Aspects BlocksKit","categories":[{"name":"底层原理","slug":"底层原理","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"https://github.com/wuvdan/wuvdan.github.io.git/tags/runtime/"}]}]}